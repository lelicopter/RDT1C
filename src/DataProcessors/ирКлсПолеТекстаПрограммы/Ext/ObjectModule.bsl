//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирКлиент Экспорт;

Перем ИмяКласса Экспорт;
Перем СсылочнаяФормаКласса Экспорт;
Перем ДопКнопкиКомандныхПанелей Экспорт;
Перем СоответствиеЭУ Экспорт;
Перем мФормаАвтодополнение Экспорт;
Перем мФормаВызовМетода Экспорт;

Перем мРегВыражение Экспорт;
Перем мСлужебнаяФорма Экспорт; 
Перем СлужебноеПолеТекстаДолгое Экспорт;
Перем мПолеТекстаВременное Экспорт;
Перем мПарсер;
Перем мШиринаТабуляции;
Перем мПлатформа Экспорт;
Перем мНачальнаяСтрока Экспорт; // снаружи только для чтения
Перем мНачальнаяКолонка Экспорт; // снаружи только для чтения
Перем мКонечнаяСтрока Экспорт; // снаружи только для чтения
Перем мКонечнаяКолонка Экспорт; // снаружи только для чтения
Перем мТекущаяСтрокаНачало;
//Перем ОригинальнаяСтрока;
Перем мТекущаяСтрокаКонец;
Перем мНачалоКонтекста;
Перем мНачалоСлова;
Перем мКонецКонтекста;
Перем мОригинальныйТекст Экспорт;
Перем мСтарыйОригинальныйТекст Экспорт;
Перем мТекстБезКомментариевИОпасныхСтрок Экспорт;
Перем мТекстБезТекстовыхЛитералов Экспорт;
Перем мТекстДляПоискаОпределения Экспорт;
Перем мТекстБлока Экспорт;
Перем мПозицияТекстаДляПоискаОпределения;
Перем мРодительскийКонтекст Экспорт;
Перем мКонтекст Экспорт;  // Для отладки сделан экспортным
Перем мВызовМетода Экспорт;
Перем мЭтоСтроковыйЛитерал Экспорт;
Перем мЭтоОбъявлениеПсевдонима Экспорт;
Перем мТекущееСлово;
Перем мПозицияВТексте;
Перем мПредшествующийТекст Экспорт;
Перем мНомерПараметра Экспорт;
Перем мИмяМетодаВызова Экспорт;
Перем мЭтоКонструктор Экспорт;
Перем мФактическиеПараметры Экспорт;
Перем мПервыйФактическийПараметр;
Перем мРазбиратьКонтекст;
Перем мРекурсивныйПуть Экспорт;
Перем мАвтоКонтекстнаяПомощь Экспорт;
Перем мРасширенноеПолучениеМетаданныхADO Экспорт;
Перем мПравилаВычисленияФункций;
Перем мПоследнийРежимВызоваСправки;
Перем мИменаОбщихТиповПоИменамКлассовCOM;
Перем мДиалектSQL Экспорт;
Перем мДиалектыSQL Экспорт;
Перем мПараметрыДиалектаSQL Экспорт; 
Перем мТерминалыЯзыкаЗапросов Экспорт;
Перем мПрефиксыПараметров Экспорт;
Перем мАнглийский1С;
Перем мМаркерСлужебногоКомментария Экспорт;
Перем мМаркерПорядкаОтладки Экспорт;
Перем мОткрытьСправкуПоПараметру Экспорт; // снаружи только для чтения
Перем мМодульМетаданных Экспорт;
Перем мИмяМодуля Экспорт;
Перем мСтруктурыТиповПодсказкиУдержания;
Перем МассивКомКлассов;
Перем мКонкретныйТипКонтекста;
Перем мСтруктураТипаКонтекста;
Перем мЭтоЛокальныйКонтекстТаблицыСлов;
Перем мТолькоСсылочныеИменаТипов;
Перем мСоответствиеТиповСловHTML;
Перем РазрешеноСобытиеПередПоказомАвтодополнения;
Перем АвтоматическаяПодсказкаПоВызовуМетода Экспорт;
Перем АвтоматическаяПодсказкаАвтодополненияHTML Экспорт;
Перем ПоказыватьВсеТипыВСпискеАвтодополненияHTML Экспорт;
Перем ПредпочитатьHTMLРедакторКода Экспорт;
Перем мЭтоАвтоВызов;
Перем МаксСловНаходитьВТекстеПрограммы;
Перем мДоступныеПоляТаблиц;  
Перем мМетодМодуля Экспорт;
Перем мНомерПервойСтрокиТелаМетода Экспорт;
Перем мНомерПоследнейСтрокиТелаМетода Экспорт;
Перем мИсторияПереходов;
Перем мФлагиКомпиляции Экспорт;
Перем мЯзыкПрограммы; // Может меняться на вложенный язык в РазобратьТекущийКонтекст()

Перем шЧисло;
Перем шЛюбой;
Перем шБуква;
Перем шСтрокаПрограммы Экспорт;
Перем шНачалоСтрокиПрограммы;
Перем шСтрокаЗапроса;
Перем шИндекс;
Перем шСкобки;
Перем шНачалоСкобок;
Перем шИмя;
Перем шИмяСкобки;
Перем шПараметрЗапроса;
Перем шПредИмя;
Перем шРазделитель;
Перем шВыражениеПрограммы Экспорт;
Перем шВыражениеЗапроса;
Перем шВызовМетодаПрограммы;
Перем шВызовМетодаЗапроса;
Перем шИЗ;
Перем шОписаниеТаблицы;
Перем шОписаниеТаблицыСЗахватом;
Перем шПока;
Перем шЕсли;
Перем шВызватьИсключение;
Перем шНачалоТокена;  
Перем шКонецТокена;
Перем шКомментарий;
Перем шПрисваивание;
Перем шПоискОписанияТаблицы;
Перем шСимволыПрефиксаПараметра;
Перем шПрефиксПараметраНеобяз;

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура ИнициироватьНеинтерактивно(пЯзыкПрограммы = 0, пМетодВыполнения = "", пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено,
	Знач пПолеТекстовогоДокумента = Неопределено) Экспорт

	ЭтотОбъект.ЯзыкПрограммы = пЯзыкПрограммы;
	мЯзыкПрограммы = пЯзыкПрограммы;
	ЭтотОбъект.МетодВыполнения = пМетодВыполнения;
	ЭтотОбъект.ТипТекста = пТипТекста;
	#Если Клиент Тогда
		Если пПолеТекстовогоДокумента = Неопределено Тогда 
			пПолеТекстовогоДокумента = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма, "1");
		КонецЕсли;
		ЭтотОбъект.ПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекстовогоДокумента);
	#Иначе
		ЭтотОбъект.ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли    
	УстановитьКонфигурациюМетаданных(пКонфигурация, пКонтекстВыполнения);
	мПрефиксыПараметров = мДиалектыSQL.Скопировать(, "ПрефиксПараметра");
	мПрефиксыПараметров.Свернуть("ПрефиксПараметра");
	мПрефиксыПараметров.ВыгрузитьКолонку(0); 
	//Если ЯзыкПрограммы = 0 Тогда
	//	ОбновитьМодульМетаданных("");
	//КонецЕсли;
	
	Если ЯзыкПрограммы = 1 Тогда
		Если КонтекстВыполнения = Неопределено Тогда
			КонтекстВыполнения = Новый ПостроительЗапроса;
		КонецЕсли;
		ИнициироватьТерминалыЯзыкаЗапросов();
	КонецЕсли;
	шПредИмя = "(?:^|[^" + шСимволыПрефиксаПараметра + шБуква + "\d\.])"; // Мультиметка10201956
	
	Если МетодВыполнения = "" Тогда
		ЭтотОбъект.МетодВыполнения = "ВыполнитьЛокально";
	КонецЕсли;
	Попытка
		ПроверитьПрограммныйКод(, "");
	Исключение
		ирОбщий.СообщитьСУчетомМодальностиЛкс(ОписаниеОшибки());
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Задан неверный контекст выполнения программы. Будет использован общий контекст выполнения");
		ЭтотОбъект.КонтекстВыполнения = ЭтотОбъект;
		ЭтотОбъект.МетодВыполнения = "ВыполнитьПрограмму";
	КонецПопытки; 
	#Если Сервер И Не Сервер Тогда
		ВычислитьПолучитьФорму();
	#КонецЕсли
	ДобавитьПравилоВычисленияФункции("ПолучитьФорму", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьФормуСписка", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьФормуВыбора", "ВычислитьПолучитьФорму", "*");
	ДобавитьПравилоВычисленияФункции("ПолучитьОбщуюФорму", "ВычислитьПолучитьФорму", "*");
	#Если Сервер И Не Сервер Тогда
		ВычислитьКоллекцияДобавить();
	#КонецЕсли
	ДобавитьПравилоВычисленияФункции("Добавить", "ВычислитьКоллекцияДобавить", "*");
	
КонецПроцедуры

Процедура ИнициироватьТерминалыЯзыкаЗапросов() Экспорт 
	
	Если мТерминалыЯзыкаЗапросов = Неопределено Тогда
		мТерминалыЯзыкаЗапросов = Новый Соответствие;
		мТерминалыЯзыкаЗапросов = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ТерминалыЯзыкаЗапросов"),,,, Истина);
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("Ключ");
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("МожетБытьПсевдонимом, Русский");
		мТерминалыЯзыкаЗапросов.Индексы.Добавить("МожетБытьПсевдонимом, Английский");
	КонецЕсли;

КонецПроцедуры

Процедура ПроверитьИнициировать() Экспорт 
	Если Не ЗначениеЗаполнено(ТипТекста) Тогда
		ИнициироватьНеинтерактивно();
	КонецЕсли;
КонецПроцедуры

#Если Клиент Тогда

// Инициализирует экземпляр класса.
//
// Параметры:
//  *СтруктураЭкземляров - Структура, *Неопределено - содержит все объекты данного класса для данной формы;
//  пФорма       - Форма - владелец элементов управления;
//  пПолеТекстовогоДокумента - ПолеТекста;
//  *пКоманднаяПанель - КоманднаяПанель, *Неопределено - в конце которой будут размещены кнопки;
//  *пЛиЯзыкЗапросов - Булево, *Ложь - режим языка запросов, иначе внутренний язык;
//  *пМетодВыполнения - Строка, *"" - имя метода выполнения программного кода;
//  *пКонтекстВыполнения - Тип, Запрос, Произвольный, *Неопределено - контекст выполнения программного кода или текста запроса;
//  *пТипТекста  - Строка, *"Алгоритм" - "Алгоритм" или "Выражение".
//
Процедура Инициализировать(СтруктураЭкземляров = Неопределено, пФорма, пПолеТекстовогоДокумента, пКоманднаяПанель = Неопределено, пЯзыкПрограммы = 0, пМетодВыполнения = "",
	пКонтекстВыполнения = Неопределено, пТипТекста = "Алгоритм", пКонфигурация = Неопределено, НеДобавлятьКнопкиЕслиСуществуют = Ложь, Знач пЭтоЧастиныйЗапрос = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПлатформа.ПодключитьПерехватКлавиатуры();
	СсылочнаяФормаКласса = Ложь;
	КоманднаяПанель = пКоманднаяПанель;
	УстановитьФормуВладельца(пФорма);
	ЭтотОбъект.ЭтоЧастичныйЗапрос = пЭтоЧастиныйЗапрос;
	ИнициироватьНеинтерактивно(пЯзыкПрограммы, пМетодВыполнения, пКонтекстВыполнения, пТипТекста, пКонфигурация, пПолеТекстовогоДокумента);
	
	Имя = ПолеТекста.ЭлементФормы.Имя;
	Если КоманднаяПанель = Неопределено Тогда
		КоманднаяПанель = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КоманднаяПанель" + Имя, Ложь);
		ПолеТекста.ЭлементФормы.КонтекстноеМеню = КоманднаяПанель;
	КонецЕсли;
	
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")].Кнопки;
	Если ЯзыкПрограммы = 1 Тогда
		КнопкаИсследоватьСхемуЗапроса = КнопкиМакета.Найти("ИсследоватьСхемуЗапроса");
		КнопкаФорматировать = КнопкиМакета.Найти("Форматировать");
		КнопкаВставитьИзБуфераОбменаВесьТекст = КнопкиМакета.Найти("ВставитьИзБуфераОбменаВесьТекст");
		КнопкаКопироватьВБуферОбменаВесьТекст = КнопкиМакета.Найти("КопироватьВБуферОбменаВесьТекст");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		Если Не ирКэш.ДоступнаСхемаЗапросаЛкс() Или ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаИсследоватьСхемуЗапроса));
		КонецЕсли;
		Если ЭтоЧастичныйЗапрос Тогда
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаФорматировать));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаВставитьИзБуфераОбменаВесьТекст));
			КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаКопироватьВБуферОбменаВесьТекст));
		КонецЕсли;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки;
	Если пКоманднаяПанель = Неопределено Тогда
		КнопкаУстановитьФокус = КнопкиМакета.Найти("УстановитьФокус");
		КнопкиМакета = ирОбщий.МассивИзКоллекцииЛкс(КнопкиМакета);
		КнопкиМакета.Удалить(КнопкиМакета.Найти(КнопкаУстановитьФокус));
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КоманднаяПанель,,, НеДобавлятьКнопкиЕслиСуществуют);
	
	Попытка
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 100);;
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	Исключение
		//КоманднаяПанель.Кнопки.Удалить(ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь"));
		Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
		Кнопка.Доступность = Ложь;
	КонецПопытки;
	
	//ФайлШаблоновТекста = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ФайлШаблоновТекста");
	//Если Ложь
	//	Или ТипЗнч(ФайлШаблоновТекста) <> Тип("Строка")
	//	Или ФайлШаблоновТекста = ""
	//Тогда
	//	КнопкаВыполнитьШаблон = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "ВыполнитьШаблон");
	//	КнопкаВыполнитьШаблон.Доступность = Ложь;
	//	КнопкаВыполнитьШаблон.СочетаниеКлавиш = Новый СочетаниеКлавиш(Клавиша.Нет); // Чтобы освободить сочетание клавиш
	//КонецЕсли; 
	
	Если СтруктураЭкземляров <> Неопределено Тогда
		СтруктураЭкземляров.Вставить(Имя, ЭтотОбъект);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьФормуВладельца(пФорма) Экспорт

	ФормаВладелец = пФорма;

КонецПроцедуры

// Освобождает ресурсы занятые экземпляром класса.
// Самое главное - очистить ссылки на формы и объекты БД.
//
// Параметры:
//  Нет.
//
Процедура Уничтожить() Экспорт

	Для Каждого Реквизит Из Метаданные().Реквизиты Цикл
		ЭтотОбъект[Реквизит.Имя] = Неопределено;
	КонецЦикла;
	Если мФормаВызовМетода <> Неопределено Тогда
		ЭтотОбъект.мФормаВызовМетода.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаВызовМетода = Неопределено;
	Если ЭтотОбъект.мФормаАвтодополнение <> Неопределено Тогда
		ЭтотОбъект.мФормаАвтодополнение.ВладелецФормы = Неопределено;
	КонецЕсли; 
	ЭтотОбъект.мФормаАвтодополнение = Неопределено;
	ОчиститьТаблицуСловЛокальногоКонтекста();
	СохранитьСтатистикуВыбораПодсказки();

КонецПроцедуры

Процедура СохранитьСтатистикуВыбораПодсказки() Экспорт 
	
	ирОбщий.СохранитьЗначениеЛкс("ирПлатформа.ТаблицаСтатистикиВыбора", мПлатформа.ТаблицаСтатистикиВыбора);

КонецПроцедуры

Процедура ВнешнееСобытиеОбъекта(Источник, Событие, Данные) Экспорт 
	
	Если Источник <> "KeyboardHook" Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ФормаВладелец = Неопределено 
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) // Для поля HTML это затратно
	Тогда
		Возврат;
	КонецЕсли;
	ирКлиент.Форма_ВнешнееСобытиеЛкс(ФормаВладелец, Источник, Событие, Данные);
	//Формат строки данные:
	//Первые 5 символов десятичное число в котором закодированы двоичные данные
	//биты 0-7 - виртуальный код клавиши (http://msdn.microsoft.com/en-us/library/dd375731%28v=VS.85%29.aspx)
	//бит 08 - 1 = нажата расширенная клавиша
	//бит 09 - 1 = Правый alt
	//бит 10 - 1 = Левый alt
	//бит 11 - 1 = Правый ctrl
	//бит 12 - 1 = Левый ctrl
	//бит 13 - 1 = Правый shift
	//бит 14 - 1 = Левый shift
	//
	//6 символ и возможно следующие символы могут быть или не быть (максимальное количество 10)
	//Это результат интерпретации клавиши с учетом языковой раскладки. (http://msdn.microsoft.com/en-us/library/ms646320%28v=VS.85%29.aspx)
	//
	ПолученноеЧисло	= Лев(Данные,5);
	ПолученноеЧисло	= Число(ПолученноеЧисло);
	ВиртуальнаяКлавиша	= ПолученноеЧисло % 256;
	ПолученноеЧисло		= ПолученноеЧисло - ВиртуальнаяКлавиша;
	РасширеннаяКлавиша	= ПолученноеЧисло % 512;
	ПолученноеЧисло		= ПолученноеЧисло - РасширеннаяКлавиша;
	ПравыйАльт	= ПолученноеЧисло % 1024;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйАльт;
	ЛевыйАльт	= ПолученноеЧисло % 2048;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйАльт;
	ПравыйСонтрол	= ПолученноеЧисло % 4096;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйСонтрол;
	ЛевыйСонтрол	= ПолученноеЧисло % 8192;
	ПолученноеЧисло		= ПолученноеЧисло - ЛевыйСонтрол;
	ПравыйШифт	= ПолученноеЧисло % 16384;
	ПолученноеЧисло		= ПолученноеЧисло - ПравыйШифт;
	ЛевыйШифт	= ПолученноеЧисло;
	Если СтрДлина(Данные) > 5 Тогда
		Символ = Сред(Данные, 6);
	Иначе
		Символ = "";
	КонецЕсли;
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
		Если Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+Space"]) = 1
		Тогда
			#Если Сервер И Не Сервер Тогда
				ОткрытьАвтодополнение();
			#КонецЕсли
			ВыполнитьКоманду("ОткрытьАвтодополнение", Данные);
		ИначеЕсли Найти(Данные, КодыКлавиш["ALT+F2"]) = 1 Тогда
			// Антибаг платформы 8.3.19+ не обновляются пометки закладок
			ирКлиент.ОткрытьИЗакрытьПустуюФормуЛкс();
		ИначеЕсли Найти(Данные, КодыКлавиш["CTRL+[-]"]) = 1 Тогда
			#Если Сервер И Не Сервер Тогда
				ВернутьсяИзПерехода();
			#КонецЕсли
			ВыполнитьКоманду("ВернутьсяИзПерехода", Данные);
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL"]) = 1 // Мультиметка00452941 Так будет много лишних точек
			Или Найти(Данные, КодыКлавиш["CTRL+ALT+P"]) = 1 
			Или Найти(Данные, КодыКлавиш["CTRL+F3"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+G"]) = 1
			Или Найти(Данные, КодыКлавиш["F3"]) = 1
		Тогда 
			// Запоминание срабатывает после системной обработки сочетания!
			ЗапомнитьИсточникПерехода();
		ИначеЕсли Ложь
			Или Найти(Данные, КодыКлавиш["CTRL+C"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+V"]) = 1 
		Тогда 
			// Мультиметка00452941 Удаляем избыточные точки истории
			УдалитьПоследнийПереходИзИстории();
		КонецЕсли; 
		Если Ложь
			Или ЛиДоступноОткрытиеСвободнойФормы()
			Или ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента")
		Тогда
			// Подсказка по вызову метода
			Если Ложь
				Или Найти(Данные, КодыКлавиш["CTRL+SHIFT+Space"]) = 1
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметр");
			КонецЕсли; 
			ФормаВызовМетода = ФормаВызовМетода();
			БылаОткрыта = ФормаВызовМетода.Открыта();
			Если Истина
				И Не БылаОткрыта
				И ЛиДоступноОткрытиеСвободнойФормы()
				И (Ложь
					Или Символ = "(" 
					Или Символ = ",")
				И АвтоматическаяПодсказкаПоВызовуМетода()
			Тогда
				ВыполнитьКоманду("ПодсказатьПараметрАвто");
			КонецЕсли;
			Если БылаОткрыта Тогда
				ОбновитьПодсказкуПоВызовуМетода();
			КонецЕсли; 
			Если Ложь
				Или Найти(Данные, КодыКлавиш["ALT+Up"]) = 1
				Или Найти(Данные, КодыКлавиш["ALT+Down"]) = 1
				//Или Найти(Данные, КодыКлавиш["CTRL+Up"]) = 1
				//Или Найти(Данные, КодыКлавиш["CTRL+Down"]) = 1
				Или Найти(Данные, КодыКлавиш["Esc"]) = 1 // Работает только в поле HTML документа. В остальных местах платформа делает полный перехват 
			Тогда  
				ФормаВызовМетода.ВнешнееСобытие(Источник, Событие, Данные);
			КонецЕсли; 
			
			ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ);
			//_РежимОтладки = Ложь;  
			//Если _РежимОтладки Тогда // ирОбщий.ПрЛкс(_РежимОтладки,1,1)
				//Сообщить(Данные);
			//КонецЕсли;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

//.
// Параметры:
//    Источник - ? - 
//    Событие - ? - 
//    Данные - ? - 
//    КодыКлавиш - Соответствие - 
//    Символ - Строка - 
Процедура ПриНажатииКлавишиАвтодополнение(Источник, Событие, Данные, Символ) Экспорт
	Если ТипЗнч(ПолеТекста.ЭлементФормы) <> Тип("ПолеТекстовогоДокумента") Тогда 
		Возврат;
	КонецЕсли;  
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	ФормаАвтодополнение = ФормаАвтодополнение();
	БылаОткрыта = ФормаАвтодополнение.Открыта();
	Если БылаОткрыта Тогда 
    	Если Ложь
			Или Найти(Данные, КодыКлавиш["Enter"]) = 1
			Или Найти(Данные, КодыКлавиш["Up"]) = 1
			Или Найти(Данные, КодыКлавиш["Down"]) = 1
			Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
			Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
			Или Найти(Данные, КодыКлавиш["CTRL+F1"]) = 1
		Тогда
			Если ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено Тогда 
				ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
				ВыделениеДвумерное.НачальнаяКолонка = мНачальнаяКолонка;
				ВыделениеДвумерное.НачальнаяСтрока = мНачальнаяСтрока;
				ВыделениеДвумерное.КонечнаяКолонка = мКонечнаяКолонка;
				ВыделениеДвумерное.КонечнаяСтрока = мКонечнаяСтрока;
				ПолеТекста.ФиксированноеВыделениеДвумерное = ВыделениеДвумерное;
			КонецЕсли;
			ПолеТекста.УстановитьВыделениеДвумерное(ПолеТекста.ФиксированноеВыделениеДвумерное);
			// Подстраховка
			ПараметрыОбработчика = Новый Структура("ПолеТекста, Текст", ПолеТекста, ПолеТекста.ПолучитьТекст());
			ирКлиент.ПодключитьОбработчикОжиданияСПараметрамиЛкс("ирКлиент.АктивироватьЭлементФормыОтложенноЛкс", ПараметрыОбработчика,,, Ложь);
			
			Если Найти(Данные, КодыКлавиш["Enter"]) = 1 Тогда
				// Отменим вставленный перенос строки
				ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
				НоваяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока + 1);
				ПолеТекста.УдалитьСтроку(мКонечнаяСтрока + 1);
				ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока) + Сред(НоваяСтрока, ВыделениеДвумерное.НачальнаяКолонка));
			КонецЕсли;
			ФормаАвтодополнение.ВнешнееСобытие(Источник, Событие, Данные);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	ПолеТекста.ФиксированноеВыделениеДвумерное = Неопределено;
	СтарыйКонтекст = мРодительскийКонтекст;
	Если Ложь
		//Или Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 
		Или Найти(Данные, КодыКлавиш["Tab"]) = 1
		Или Найти(Данные, КодыКлавиш["Space"]) = 1
		Или Найти(Данные, КодыКлавиш["Enter"]) = 1
	Тогда
		// Чтобы закрылась форма
		СтарыйКонтекст = Null;
	КонецЕсли;
	ПолучитьГраницыВыделения();
	ПрочитатьНачалоИКонецТекущейСтроки();
	Если Истина
		И ЯзыкПрограммы = 0
		И Найти(Данные, КодыКлавиш["Enter"]) = 1 
		И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока - 1)) 
	Тогда
		ПолеТекста.ВыделенныйТекст("|");
	КонецЕсли;
	Если Истина
		И ЛиДоступноОткрытиеСвободнойФормы()
		И АвтоматическаяПодсказкаАвтодополненияHTML()
	Тогда 
		РазобратьКонтекстСтроки();
		Последние2Символа = Прав(мТекущаяСтрокаНачало, 2);
		//ПоказатьСписок = МожноПоказатьСписокСлов(Символ, мТекущаяСтрокаНачало, мТекущееСлово);
		Если Ложь
			Или Истина
				И Не БылаОткрыта 
				И Не (ЯзыкПрограммы = 1 И мЭтоОбъявлениеПсевдонима)
				И ирОбщий.СтрНачинаетсяСЛкс(Данные, "00") // Без модификаторов
				И Не ирОбщий.ЛиВнутриКомментарияЛкс(мТекущаяСтрокаНачало)
				И ирОбщий.НайтиРегВыражениеЛкс(Символ, "[" + шБуква + "]").Количество() > 0 
			Или Символ = "&" И Последние2Символа <> "&&" И ЯзыкПрограммы = 1
			Или Символ = "~" И Последние2Символа <> "~~" И ЯзыкПрограммы = 0
			Или Символ = "." И Последние2Символа <> ".."
			Или Символ = """" И Последние2Символа <> """""" И ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало)
		Тогда
			ВыполнитьКоманду("ОткрытьАвтодополнение", Данные); 
			СтарыйКонтекст = мРодительскийКонтекст;
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Найти(Данные, КодыКлавиш["CTRL"]) = 1
		Или Найти(Данные, КодыКлавиш["Up"]) = 1
		Или Найти(Данные, КодыКлавиш["Down"]) = 1
		Или Найти(Данные, КодыКлавиш["PgUp"]) = 1
		Или Найти(Данные, КодыКлавиш["PgDown"]) = 1
	Тогда
		//  
	ИначеЕсли ФормаАвтодополнение.Открыта() Тогда
		РазобратьКонтекстСтроки();
		//ПредпоследнееСлово = ""; // TODO
		//ПоказатьСписок = МожноПоказатьСписокСлов(Символ, мТекущаяСтрокаНачало, ПредпоследнееСлово);
		Если Ложь
			Или СтарыйКонтекст <> мРодительскийКонтекст 
			Или Не ЗначениеЗаполнено(мКонтекст) И Не мЭтоСтроковыйЛитерал
		Тогда
			ФормаАвтодополнение.Закрыть();
			Возврат;
		КонецЕсли;
		БылЗаполненФильтр = ЗначениеЗаполнено(ФормаАвтодополнение.ЭлементыФормы.ПолеОтбораПоПодстроке.Значение);
		ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
		ФормаАвтодополнение.ЭлементыФормы.ПолеОтбораПоПодстроке.Значение = мНачалоСлова;
		Если Найти(Данные, КодыКлавиш["CTRL+Space"]) = 1 И БылЗаполненФильтр Тогда
			ФормаАвтодополнение.ПереброситьВведеннуюСтроку();
		КонецЕсли;
		ФормаАвтодополнение.ПриИзмененииОтбора();
	КонецЕсли; 
КонецПроцедуры

Процедура ОбновитьПодсказкуПоВызовуМетода()
	
	ФормаВызовМетода = ФормаВызовМетода();
	Если Не ФормаВызовМетода.Открыта() Или Не ФормаВызовМетода.Автообновление Тогда
		Возврат;
	КонецЕсли; 
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = Неопределено;
	//Если Форма.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	//КонецЕсли;

КонецПроцедуры

Функция ЛиМожноЗакрытьФорму() Экспорт 
	Результат = Истина;
	ФормаВызовМетода = ФормаВызовМетода();
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	ФормаАвтодополнение = ФормаАвтодополнение();
	Если ФормаАвтодополнение.Открыта() Тогда
		ФормаАвтодополнение.Закрыть();
		Результат = Ложь;
	КонецЕсли; 
	Возврат Результат;
КонецФункции

Функция ФормаВызовМетода() Экспорт 
	
	Если мФормаВызовМетода = Неопределено Тогда
		мФормаВызовМетода = ПолучитьФорму("ВызовМетода", ФормаВладелец);
	КонецЕсли; 
	Возврат мФормаВызовМетода;

КонецФункции 

Процедура ОткрытьПрикрепленнуюФормуВызоваМетода(Знач СтруктураТипаКонтекста, Знач ЭтаФорма = Неопределено) Экспорт 
	
	ТаблицаВладелец = СтруктураТипаКонтекста.СтрокаОписания.Владелец();
	#Если Сервер И Не Сервер Тогда
		ТаблицаВладелец = Новый ТаблицаЗначений;
	#КонецЕсли
	ФормаВызовМетода = ПолучитьФорму("ВызовМетода", ЭтаФорма, "Прикрепленное");
	Если Не ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.СоединяемоеОкно = Истина;
		ФормаВызовМетода.КлючСохраненияПоложенияОкна = ФормаВызовМетода.КлючУникальности;
		ФормаВызовМетода.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное;
		ФормаВызовМетода.ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Низ;
	КонецЕсли; 
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипаКонтекста;
	Если ФормаВызовМетода.Открыта() Тогда
		ФормаВызовМетода.ОбновитьИлиЗакрытьФорму();
	Иначе
		ФормаВызовМетода.Открыть();
	КонецЕсли;

КонецПроцедуры
	
// Получает номер текущей строки в тексте (по конечной границе выделения).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьНомерТекущейСтроки(Начальной = Ложь) Экспорт

	Если ПолеТекста <> Неопределено Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		Если Начальной Тогда
			Возврат мНачальнаяСтрока;
		Иначе
			Возврат мКонечнаяСтрока;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции // ПолучитьНомерТекущейСтроки()

// Получает текущее объектное выражение (на котором установлен курсор).
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка - объектное выражение, в котором находится курсов.
//
Функция ТекущееОбъектноеВыражение(НомерСтроки = 0, НомерКолонки = 0, выхЕстьТочкаСправа = Ложь, КончитьОбработкуКоманды = Истина, Знач ЭтоПродолжениеОбработки = Ложь) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	Если ЭтоПродолжениеОбработки Тогда
		ПродолжитьОбработкуКоманды();
	Иначе
		КончитьОбработкуКоманды();
	КонецЕсли;
	Если НомерСтроки > ПолеТекста.КоличествоСтрок() Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазобратьТекущийКонтекст(, выхЕстьТочкаСправа,, НомерСтроки, НомерКолонки, Истина);
	Если КончитьОбработкуКоманды Тогда
		КончитьОбработкуКоманды();
	КонецЕсли; 
	Если мЭтоСтроковыйЛитерал Тогда
		мКонтекст = "";
	КонецЕсли; 
	Возврат мКонтекст;

КонецФункции

// Получает текущее контекст параметра. 
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура -
//    "ОбъектноеВыражение"
//    "НомерПараметра"
//
Функция ПолучитьТекущийКонтекстПараметра() Экспорт

	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	КончитьОбработкуКоманды();
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
	СтруктураРезультата.Вставить("ПервыйПараметр", мПервыйФактическийПараметр);
	СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
	Возврат СтруктураРезультата;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция ТекущийВызовМетода()

	мРегВыражение.Global = Истина;
	мКонтекст = "";
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	ПредшествующийТекст = "";
	СледующийТекст = "";
	МаксЧислоПредшествующихСтрок = 20; // Чтобы снизить вероятность зацикливания при вычислении рег.выражения
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(Макс(1, мКонечнаяСтрока - МаксЧислоПредшествующихСтрок - 1), 1, мКонечнаяСтрока - 1, 333);
		ПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли; 
	
	МаксЧислоСтрокАнализировать = 50;
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + МаксЧислоСтрокАнализировать);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	
	ТекстДоКурсора = ПредшествующийТекст + мТекущаяСтрокаНачало; // Так почему то иногда возникало смещение на 1 символ
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	ТекстПослеКурсора = ЗалитьКомментарииИСтроковыеЛитералы(ТекстПослеКурсора,,, Ложь); // Защита от больших откатов https://www.hostedredmine.com/issues/967498
	Если мЭтоСтроковыйЛитерал Тогда
		//ТекстДоКурсора = ТекстДоКурсора + """";
		ТекстПослеКурсора = """" + ТекстПослеКурсора;
		Если ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(ТекстПослеКурсора) Тогда
			ТекстПослеКурсора = ТекстПослеКурсора + """";
		КонецЕсли; 
	КонецЕсли; 
	Если мЯзыкПрограммы = 0 Тогда
		ШаблонПараметра = "(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*";
	Иначе
		ШаблонПараметра = "(?:" + шВыражениеЗапроса   + ")?" + шРазделитель + "*";
	КонецЕсли;
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^(?:" + ШаблонПараметра + ",)*" + ШаблонПараметра + "\)";
	Результат = мРегВыражение.НайтиВхождения(ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		//КонецВыражения = Лев(ТекстПослеКурсора, Результат[0].Length);
		КонецВыражения = Результат[0].Value;
		Если мЭтоСтроковыйЛитерал Тогда
			КонецВыражения = Сред(КонецВыражения, 2);
		КонецЕсли;
	КонецЕсли;  
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	Если мЯзыкПрограммы = 1 Тогда
		мРегВыражение.Pattern = шВызовМетодаЗапроса + "$";
	Иначе 
		мРегВыражение.Pattern = шВызовМетодаПрограммы + "$";
	КонецЕсли;
	Результат = мРегВыражение.НайтиВхождения(ТекстДоКурсора + Лев(КонецВыражения, СтрДлина(КонецВыражения) - 1) + ",");
	//Результат = RegExp.НайтиВхождения(Лев(ОригинальныйТекст, СтрДлина(ТекстДоКурсора)+ СтрДлина(КонецВыражения) - 1) + ","); // Отрезаем последний символ зачем то
	мФактическиеПараметры = Новый Массив;
	Если Результат.Количество() > 0 Тогда
		//ПоследнееВхождение = Результат[Результат.Количество() - 1];
		ПоследнееВхождение = Результат[0];
		//ДлинаТекста = СтрДлина(ОригинальныйТекст);
		//Попытка
		//	СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
		//		Мин(ДлинаТекста, ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length));
		//Исключение
		//	СлужебноеПолеТекста.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
		//		Мин(ДлинаТекста, ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1)); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		//КонецПопытки;
		//СлужебноеПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		мВызовМетода = ПоследнееВхождение.SubMatches(1) + "(";
		ТекстПараметров = ПоследнееВхождение.SubMatches(5) + ПоследнееВхождение.SubMatches(14);
		мЭтоКонструктор = ЗначениеЗаполнено(ПоследнееВхождение.SubMatches(0));
		мРегВыражение.Global = Истина;
		Если мЯзыкПрограммы = 0 Тогда
			ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" ;
		Иначе
			ШаблонПараметра = "(" + шВыражениеЗапроса   + ")?";
		КонецЕсли;
		мРегВыражение.Pattern = ШаблонПараметра + шРазделитель + "*,";
		Результат = мРегВыражение.НайтиВхождения(ТекстПараметров);
		ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) + 1 - СтрДлина(КонецВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			ПозицияВхождения = Вхождение.FirstIndex;
			Если Истина
				И (ПозицияВхождения + 1) <= ЛокальнаяПозицияКурсора 
				И (ПозицияВхождения + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			Тогда
				мНомерПараметра = Счетчик;
			КонецЕсли;
			мФактическиеПараметры.Добавить(СокрЛП(Вхождение.SubMatches(0)));
		КонецЦикла;
		Если мФактическиеПараметры.Количество() > 0 Тогда
			мПервыйФактическийПараметр = мФактическиеПараметры[0];
		КонецЕсли; 
		мИмяМетодаВызова = ирОбщий.ПервыйФрагментЛкс(ирОбщий.ПоследнийФрагментЛкс(мВызовМетода), "(");
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ОбъектноеВыражение", мВызовМетода);
		СтруктураРезультата.Вставить("ОригинальныйТекст", Лев(ПоследнееВхождение.Value, СтрДлина(ПоследнееВхождение.Value) - 1) + ")");
		СтруктураРезультата.Вставить("МассивПараметров", мФактическиеПараметры);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		СтруктураРезультата.Вставить("ЭтоКонструктор", мЭтоКонструктор);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

// Разбирает контекст метода.
//
// Параметры:
//  Нет.
//
Функция УстановитьТекущийКонтекстМетода(НовыйТекст) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	ВыделенныйТекст(НовыйТекст);
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мНачальнаяСтрока, мНачальнаяКолонка,, ФормаВладелец);

КонецФункции

// Разбирает контекст УК.
//
// Параметры:
//  Нет.
//
Функция ПолучитьТекущийКонтекстУК() Экспорт

	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	мРегВыражение.Global = Истина;
	ПрочитатьНачалоИКонецТекущейСтроки();
	РазобратьКонтекстСтроки();
	ИмяСтруктурыПараметров = "";
	
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	//СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	мПредшествующийТекст = "";
	СледующийТекст = "";
	Если мКонечнаяСтрока > 1 Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока - 1, 333);
		мПредшествующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли; 
	МаксНомерСтроки = Мин(СлужебноеПолеТекстаДолгое.КоличествоСтрок(), мКонечнаяСтрока + 100);
	Если Истина
		И МаксНомерСтроки > 0
		И МаксНомерСтроки <= СлужебноеПолеТекстаДолгое.КоличествоСтрок() 
	Тогда
		СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мКонечнаяСтрока + 1, 1, МаксНомерСтроки, 333);
		СледующийТекст = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	КонецЕсли;
	ТекстДоКурсора = мПредшествующийТекст + Символы.ПС + мТекущаяСтрокаНачало;
	ТекстПослеКурсора = мТекущаяСтрокаКонец + Символы.ПС + СледующийТекст;
	
	ШаблонУК = "(" + шИмя + ")" + шРазделитель + "*=" + шРазделитель + "*УК\((" + шИмя + ")\)";
	мРегВыражение.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		Смещение = Результат[0].SubMatches(0);
		ИмяСтруктурыПараметров = Результат[0].SubMatches(1);
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить(Результат[0].SubMatches(2));
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ШаблонПараметра = шРазделитель + "*" + ИмяСтруктурыПараметров + "\.(" + шИмя + ")" + шРазделитель + "*=" 
		+ шРазделитель + "*(" + шВыражениеПрограммы + ")?" + шРазделитель + "*" + ";";
	мРегВыражение.Pattern = "^" + "(" + шРазделитель + "*)" + ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)";
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало + ТекстПослеКурсора);
	Если Результат.Количество() > 0 Тогда
		ПолныйТекстВыражения = Результат[0].Value;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	//RegExp.Global = Ложь;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = ШаблонУК + ";" + "((?:" + ШаблонПараметра  + шРазделитель + "*" + ")*)$";
	Результат = мРегВыражение.НайтиВхождения(мПредшествующийТекст + ПолныйТекстВыражения);
	СтруктураПараметров = Новый Структура;
	Если Результат.Количество() > 0 Тогда
		ПоследнееВхождение = Результат[Результат.Количество() - 1];
		Попытка
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length);
		Исключение
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(ПоследнееВхождение.FirstIndex + 1, 
				ПоследнееВхождение.FirstIndex + 1 + ПоследнееВхождение.Length - 1); // -1 надо делать из-за бага платформы (она не дает выделить последний символ в тексте)
		КонецПопытки;
		СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
		//ИмяСтруктурыПараметров = Результат[0].SubMatches(0);
		ТекстПараметров = ПоследнееВхождение.SubMatches(2);
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = ШаблонПараметра;
		Результат = мРегВыражение.НайтиВхождения(ТекстПараметров);
		//ЛокальнаяПозицияКурсора = СтрДлина(ТекстПараметров) - СтрДлина(ПолныйТекстВыражения);
		Счетчик = 0;
		Для Каждого Вхождение Из Результат Цикл
			Счетчик = Счетчик + 1;
			//Если Истина
			//	И (Вхождение.FirstIndex + 1) <= ЛокальнаяПозицияКурсора 
			//	И (Вхождение.FirstIndex + Вхождение.Length + 1) >= ЛокальнаяПозицияКурсора 
			//Тогда
			//	мНомерПараметра = Счетчик;
			//КонецЕсли;
			СтруктураПараметров.Вставить(СокрЛП(Вхождение.SubMatches(0)), СокрЛП(Вхождение.SubMatches(1)));
		КонецЦикла;
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("ИмяСтруктурыПараметров", ИмяСтруктурыПараметров);
		СтруктураРезультата.Вставить("МассивПараметров", МассивПараметров);
		СтруктураРезультата.Вставить("ОригинальныйТекст", ПоследнееВхождение.Value);
		СтруктураРезультата.Вставить("Смещение", Смещение);
		СтруктураРезультата.Вставить("СтруктураПараметров", СтруктураПараметров);
		СтруктураРезультата.Вставить("НомерПараметра", мНомерПараметра);
		Возврат СтруктураРезультата;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

Процедура ПродолжитьОбработкуКоманды() Экспорт 
	
	мРазбиратьКонтекст = Ложь;

КонецПроцедуры

// Вызывается в конце обработки команды.
//
// Параметры:
//  Нет.
//
Процедура КончитьОбработкуКоманды() Экспорт

	мРазбиратьКонтекст = Истина;

КонецПроцедуры

// Находит первое вхождение слова в тексте. Если слово найдено, устанавливается выделение и фокус.
//
// Параметры:
//  СтрокаПоиска			 - 	 - 
//  СловоЦеликом	 - Булево, "Переменная" - 
//  ПолеТекста	 - 	 - 
// 
// Возвращаемое значение:
//   - Булево - была ли найдена и выделена строка
//
Функция НайтиПоказатьСловоВТексте(СтрокаПоиска, Знач СловоЦеликомИлиШаблон = Истина, ПолеТекста = Неопределено, УстановитьФокус = Ложь, ИскатьСНачала = Ложь, Знач ВТекущемБлоке = Ложь,
	Знач ИскатьСНачалаЕслиНеНайдено = Ложь) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли;
	Если СловоЦеликомИлиШаблон = "Переменная" Тогда
		СловоЦеликомИлиШаблон = ШаблонШаблонаПоискаСлова();
	КонецЕсли;
	Если мМетодМодуля <> Неопределено И ВТекущемБлоке Тогда
		НачалоОбласти = мМетодМодуля.ПозицияОпределения;
		КонецОбласти = мМетодМодуля.ПозицияТела + СтрДлина(мМетодМодуля.Тело);
	Иначе
		НачалоОбласти = Неопределено;
		КонецОбласти = Неопределено;
	КонецЕсли;
	Если УстановитьФокус Тогда
		ЗапомнитьИсточникПерехода();
	КонецЕсли;
	Результат = ирКлиент.НайтиПоказатьФрагментВПолеТекстаЛкс(ФормаВладелец, ПолеТекста, СтрокаПоиска, СловоЦеликомИлиШаблон, ИскатьСНачала,,, НачалоОбласти, КонецОбласти, ИскатьСНачалаЕслиНеНайдено);
	Если УстановитьФокус Тогда
		УстановитьФокус();
	КонецЕсли; 
	Возврат Результат; 
	
КонецФункции

Функция ШаблонШаблонаПоискаСлова(ЛиМетод = Ложь) Экспорт 
	
	Шаблон = шСтрокаПрограммы + "|(?:Новый|New)\s*#Слово#|(^|[^_a-zа-яё0-9"".])(#Слово#)\s*";
	Если ЛиМетод Тогда
		Возврат Шаблон + "\(";
	Иначе
		Возврат Шаблон + "($|[^_a-zа-яё0-9\(])";
	КонецЕсли;

КонецФункции

// Вставляет в текущую позицию поля текстового документа ссылку на объект БД.
//
// Параметры:
//  ЗначенияСвойствНового - Структура - если параметр будет добавлен, то к его строке будут применены эти значения свойств;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  - <Тип.Вид> - <описание значения>
//                 <продолжение описания значения>.
//
Функция ВставитьСсылкуНаОбъектБД(ТабличноеПолеПараметров, ИмяКолонкиИмени = "Имя", ИмяКолонкиЗначения = "Значение", ИмяСтруктурыПараметров = "",
	ОбновитьКопиюСвойстваВНижнемРегистре = Ложь, НачальноеЗначениеВыбора = Неопределено, РазрешитьВыбор = Истина, ВставитьВТекст = Истина) Экспорт

	ТаблицаПараметров = ТабличноеПолеПараметров.Значение;
	ТекущееОбъектноеВыражение = ТекущееОбъектноеВыражение();
	
	Если Истина
		И РазрешитьВыбор
		И НачальноеЗначениеВыбора = Неопределено
		И ВставитьВТекст
	Тогда
		Если Ложь
			Или ЯзыкПрограммы = 0
			Или Лев(ТекущееОбъектноеВыражение, 1) = "&" 
		Тогда
			ИмяПараметра = ТекущееОбъектноеВыражение;
			Если ЯзыкПрограммы = 1 Тогда
				ИмяПараметра = Сред(ИмяПараметра, 2);
			Иначе
				Если Истина
					И Не ПустаяСтрока(ИмяСтруктурыПараметров)
					И Найти(НРег(ИмяПараметра), НРег(ИмяСтруктурыПараметров) + ".") = 1 
				Тогда
					ИмяПараметра = Сред(ИмяПараметра, СтрДлина(ИмяСтруктурыПараметров) + 2);
				КонецЕсли; 
			КонецЕсли; 
			СтрокаНайденногоПараметра = ТаблицаПараметров.Найти(ИмяПараметра, ИмяКолонкиИмени);
			Если СтрокаНайденногоПараметра <> Неопределено Тогда
				Ответ = Вопрос("Использовать тип и значение выделенного в тексте параметра?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ЗначениеПараметра = СтрокаНайденногоПараметра[ИмяКолонкиЗначения];
					Если ирОбщий.ЛиСсылкаНаОбъектБДЛкс(ЗначениеПараметра, Ложь) Тогда
						НачальноеЗначениеВыбора = ЗначениеПараметра;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	//Если ЗначениеЗаполнено(НачальноеЗначениеВыбора) Тогда
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ТипСсылки = ТипЗнч(НачальноеЗначениеВыбора);
		Если Не ирОбщий.ЛиТипСсылкиБДЛкс(ТипСсылки, Ложь) Тогда
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	Если РазрешитьВыбор Тогда
		ВыделитьТекущееОбъектноеВыражение();
	КонецЕсли; 
	
	Если ТипСсылки = Неопределено И Не ЗначениеЗаполнено(ТекущееОбъектноеВыражение) Тогда
		СтруктураТипаКонтекста = ПолучитьСтруктуруТипаСправаОтРавно();
		Если СтруктураТипаКонтекста <> Неопределено Тогда
			Если ТипЗнч(СтруктураТипаКонтекста.Метаданные) = Тип("ОбъектМетаданных") Тогда
				ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(СтруктураТипаКонтекста.Метаданные.ПолноеИмя()));
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
	Если РазрешитьВыбор И ТипСсылки = Неопределено Тогда
		ПараметрыВыбораМетаданных = Новый Структура;
		ПараметрыВыбораМетаданных.Вставить("ОтображатьСсылочныеОбъекты", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьПеречисления", Истина);
		ПараметрыВыбораМетаданных.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
		ФормаВыбора = ирКлиент.ПолучитьФормуВыбораОбъектаМетаданныхСтруктуройЛкс(ФормаВладелец,,, ПараметрыВыбораМетаданных);
		Результат = ФормаВыбора.ОткрытьМодально();
		Если Результат = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ТипСсылки = Тип(ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(Результат.ПолноеИмяОбъекта));
	КонецЕсли;
	
	Если НачальноеЗначениеВыбора = Неопределено Тогда
		НачальноеЗначениеВыбора = Новый (ТипСсылки);
	КонецЕсли;
	
	Если РазрешитьВыбор Тогда
		ЗначениеПараметра = ирКлиент.ВыбратьСсылкуЛкс(ТипСсылки, НачальноеЗначениеВыбора);
		УстановитьФокус();
	Иначе
		ЗначениеПараметра = НачальноеЗначениеВыбора;
	КонецЕсли; 
	Если ЗначениеПараметра = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТабличноеПолеПараметров.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 
	
	СтрокаПараметра = ирОбщий.НайтиДобавитьПараметрСсылкуВТаблицуЛкс(ТаблицаПараметров, ИмяКолонкиИмени, ИмяКолонкиЗначения, ЗначениеПараметра,, ОбновитьКопиюСвойстваВНижнемРегистре);
	Если ВставитьВТекст Тогда
		ТекстВставки = СтрокаПараметра[ИмяКолонкиИмени];
		Если Ложь
			Или ЯзыкПрограммы = 1
			Или ЯзыкПрограммы = 2
		Тогда
			ТекстВставки = "&" + ТекстВставки;
		КонецЕсли;
		Если ЯзыкПрограммы = 0 Тогда
			Если Не ПустаяСтрока(ИмяСтруктурыПараметров) Тогда
				ТекстВставки = ИмяСтруктурыПараметров + "." + ТекстВставки;
			КонецЕсли; 
		КонецЕсли;
		ВыделенныйТекст(ТекстВставки);
	КонецЕсли; 
	Возврат СтрокаПараметра;

КонецФункции

// Обрабатывает нажатие на кнопки
//
// Параметры:
//  Кнопка - Кнопка.
//
// Возвращаемое значение:
//  Булево - результат проверки.
//
Функция Нажатие(Кнопка, ОбновитьКонтекст = Ложь) Экспорт
	
	Перем Результат;
	Команда = ирОбщий.ПоследнийФрагментЛкс(Кнопка.Имя, "_");
	Если Команда = "АвтоКонтекстнаяПомощь" Тогда
	    УстановитьАвтоКонтекстнаяПомощь(Не Кнопка.Пометка);
	КонецЕсли;
	Результат = ВыполнитьКоманду(Команда,, ОбновитьКонтекст);
	Возврат Результат;
	
КонецФункции

Функция ВыполнитьКоманду(Знач Команда, Знач КодКлавиши = "", ОбновитьКонтекст = Истина)
	
	Если ОбновитьКонтекст Тогда
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
	КонецЕсли;
	Результат = Неопределено;
	Попытка
		мПлатформа.ИнициацияОписанияМетодовИСвойств();
		ПолучитьГраницыВыделения();
		мОткрытьСправкуПоПараметру = Ложь;
		Если Команда = "ОткрытьАвтодополнение" Тогда
			ОткрытьАвтодополнение(КодКлавиши, Не ЗначениеЗаполнено(КодКлавиши));
		ИначеЕсли Команда = "ПоискОбщегоМетода" Тогда
			ОткрытьСписокОбщихМетодов();
		ИначеЕсли Команда = "НайтиВызовыМетода" Тогда
			НайтиВызовыМетода();
		ИначеЕсли Команда = "ЗаменитьТабуляции" Тогда
			ЗаменитьТабуляции();
		ИначеЕсли Команда = "ВыделитьСлово" Тогда
			// В платформе есть аналогичная системная команда, но для HTML редактора нужна.
			ВыделитьТекущееСлово();
		ИначеЕсли Команда = "ПереименоватьСлово" Тогда
			ПереименоватьСлово();
		ИначеЕсли Команда = "СписокМетодов" Тогда
			//
		ИначеЕсли Команда = "ВыделитьМетод" Тогда
			ВыделитьМетод();
		ИначеЕсли Команда = "СравнитьТекст" Тогда
			ВариантСинтаксиса = Неопределено;
			Если ЯзыкПрограммы = 0 Тогда
				ВариантСинтаксиса = "ВстроенныйЯзык";
			ИначеЕсли ЯзыкПрограммы = 1 Тогда
				ВариантСинтаксиса = "ЯзыкЗапросов";
			ИначеЕсли ЯзыкПрограммы = 2 Тогда
				ВариантСинтаксиса = "ЯзыкКомпоновки";
			КонецЕсли; 
			ирКлиент.ЗапомнитьСодержимоеЭлементаФормыДляСравненияЛкс(ФормаВладелец, ПолеТекста, ВариантСинтаксиса);
		ИначеЕсли Истина
			И ЯзыкПрограммы = 1
			И Команда = "УдалитьПереносы"
		Тогда
			УдалитьПереносы();
		ИначеЕсли Команда = "КонструкторЗапросов1С" Тогда
			Результат = ВызватьКонструкторЗапросов(Ложь);
		ИначеЕсли Команда = "КонструкторЗапросовИР" Тогда
			Результат = ВызватьКонструкторЗапросов(Истина);
		ИначеЕсли Команда = "КонструкторЗапросов" Тогда
			Результат = ВызватьКонструкторЗапросов();
		ИначеЕсли Команда = "КонсольЗапросов" Тогда
			Результат = РедактироватьВКонсолиЗапросов();
		ИначеЕсли Команда = "КонсольКода" Тогда
			Результат = РедактироватьВКонсолиКода();
		ИначеЕсли Команда = "ВставитьИзБуфераОбменаВесьТекст" Тогда
			ирКлиент.УстановитьТекстСОткатомЛкс(ПолеТекста, ирКлиент.ТекстИзБуфераОбменаОСЛкс());
		ИначеЕсли Команда = "КопироватьВБуферОбменаВесьТекст" Тогда
			ирКлиент.ТекстВБуферОбменаОСЛкс(ПолеТекста.ПолучитьТекст(), ?(ЯзыкПрограммы = 0, "ВстроенныйЯзык", "ЯзыкЗапросов"));
		ИначеЕсли Команда = "КопироватьВБуферОбменаТекстВВидеКода" Тогда
			КопироватьВБуферОбменаТекстВВидеКода();
		ИначеЕсли Команда = "Закомментировать" Тогда
			Закомментировать();
		ИначеЕсли Команда = "Раскомментировать" Тогда
			Раскомментировать();
		ИначеЕсли Команда = "РедакторСтроковогоЛитерала" Тогда
			Результат = ОткрытьРедакторСтроковогоЛитерала();
		ИначеЕсли Команда = "ИсследоватьСхемуЗапроса" Тогда
			Если ПроверитьПрограммныйКод() Тогда 
				СхемаЗапроса = Вычислить("Новый схемаЗапроса");
				#Если Сервер И Не Сервер Тогда
					СхемаЗапроса = Новый СхемаЗапроса;
				#КонецЕсли
				Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
					СхемаЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
				КонецЕсли;
				СхемаЗапроса.УстановитьТекстЗапроса(ПолеТекста.ПолучитьТекст());
				ирОбщий.ИсследоватьЛкс(СхемаЗапроса);
			КонецЕсли;
		ИначеЕсли Команда = "ПерейтиКОпределению" Тогда
			ПерейтиКОпределению();
			Результат = мТекущееСлово;
		ИначеЕсли Команда = "Проверить" Тогда
			ПроверитьПрограммныйКод(Истина);
		ИначеЕсли Команда = "УстановитьФокус" Тогда
			УстановитьФокус();
		ИначеЕсли Команда = "Форматировать" Тогда
			ФорматироватьТекст();
		ИначеЕсли Истина
			И ЯзыкПрограммы = 0
			И Команда = "Выполнить"
		Тогда
			ВыполнитьПрограммныйКод();
		ИначеЕсли Команда = "КонтекстныйСинтаксПомощник" Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьКонтекстнуюСправку(, ФормаВладелец);
		ИначеЕсли Команда = "СинтаксПомощник" Тогда
			ОткрытьСправкуПоЯзыкуПрограммы();
		ИначеЕсли Команда = "ПодсказатьПараметр" Тогда
			мПоследнийРежимВызоваСправки = Команда;
			ОткрытьСправкуПоПараметру();
		ИначеЕсли Команда = "ПодсказатьПараметрАвто" Тогда
			#Если ТолстыйКлиентОбычноеПриложение Тогда
				Если ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы Тогда
					ОткрытьСправкуПоПараметру(, Ложь);
				КонецЕсли; 
			#КонецЕсли
		ИначеЕсли Команда = "Настройка" Тогда
			ПолучитьФорму("ФормаНастройки", ФормаВладелец).Открыть();
		ИначеЕсли Команда = "ВыполнитьШаблон" Тогда
			ВыполнитьШаблонТекста();
		ИначеЕсли Команда = "КонструкторОписанияТипов" Тогда
			КонструкторОписанияТипов();
		ИначеЕсли Команда = "НайтиСледующееHTML" Тогда
			НайтиСледующееHTML();
		ИначеЕсли Команда = "НайтиПредыдущееHTML" Тогда
			НайтиПредыдущееHTML();
		ИначеЕсли Команда = "ЗаменитьВхожденияHTML" Тогда
			ЗаменитьВхожденияHTML();
		ИначеЕсли Команда = "СочетанияКлавишHTML" Тогда
			СочетанияКлавишHTML();
		ИначеЕсли Команда = "КонструкторФорматнойСтроки" Тогда
			КонструкторФорматнойСтроки();
		ИначеЕсли Команда = "ВернутьсяИзПерехода" Тогда
			ВернутьсяИзПерехода();
		КонецЕсли;
		
		Если Ложь
			Или Команда = "ВыделитьСлово"
			Или Команда = "Форматировать"
			Или Команда = "ВыполнитьШаблон"
			Или Команда = "ОткрытьАвтодополнение"
			Или Команда = "ПодсказатьПараметрАвто"
			Или Команда = "ЗаменитьТабуляции"
			Или Команда = "УдалитьПереносы"
			Или Команда = "ПерейтиКОпределению"
			Или Команда = "КонструкторЗапросов1С"
			Или Команда = "КонструкторЗапросовИР"
			Или Команда = "КонструкторЗапросов"
			Или Команда = "РедакторСтроковогоЛитерала"
		Тогда
			Если Результат <> Ложь Тогда 
				ВосстановитьГраницыВыделенияПослеКоманды();
			КонецЕсли;
		КонецЕсли;
	Исключение
		КончитьОбработкуКоманды();
		ВосстановитьФокусВвода();
		ВызватьИсключение;
	КонецПопытки;
	КончитьОбработкуКоманды();
	ВосстановитьФокусВвода();
	Возврат Результат;

КонецФункции

Процедура ВосстановитьГраницыВыделенияПослеКоманды()
	
	УстановитьГраницыВыделения();
	Если мОткрытьСправкуПоПараметру Тогда
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			// Антибаг 8.3.19+ https://www.hostedredmine.com/issues/956304
			//ОткрытьСправкуПоПараметру(, Ложь);
			ФормаПодсказкаПоПараметрам = ФормаВызовМетода();
			ФормаПодсказкаПоПараметрам.ПодключитьОбработчикОжидания("ОткрытьОтложенно", 0.1, Истина);
		#КонецЕсли
	КонецЕсли;

КонецПроцедуры

Процедура ПолучитьГраницыВыделения() Экспорт
	ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
КонецПроцедуры

Процедура УстановитьГраницыВыделения() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//Структура = ПолеТекста.ВыделениеДвумерное();
	//Если Ложь
	//	// Экономная установка для подавления угасания мигания каретки из-за антибага платформы https://www.hostedredmine.com/issues/936432
	//	// Но баг платформы ЗаменитьСтроку() вызывает фактическое выделение всего предшествующего текста иногда без возможности получить настоящие границы выделения на 8.3.18 https://www.hostedredmine.com/issues/936821
	//	Или Структура.НачальнаяСтрока <> мНачальнаяСтрока 
	//	Или Структура.НачальнаяКолонка <> мНачальнаяКолонка 
	//	Или Структура.КонечнаяСтрока <> мКонечнаяСтрока 
	//	Или Структура.КонечнаяКолонка <> мКонечнаяКолонка 
	//Тогда
		ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);
	//КонецЕсли; 

КонецПроцедуры

Процедура ФорматироватьТекст()
	
	ВыделениеДвумерное = ПолеТекста.ВыделениеДвумерное();
	ВыделенныйТекст = ВыделенныйТекст();
	ТолькоВыделенныйТекст = СтрДлина(ВыделенныйТекст) > 1;
	Если ТолькоВыделенныйТекст Тогда
		ТекстЗапроса = ВыделенныйТекст;
	Иначе
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Попытка
		Если ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда 
			НовыйТекст = КонструкторЗапроса.СобратьПолныйТекст(, Истина);
			Если Не ТолькоВыделенныйТекст Тогда
				ВыделитьВесьТекст();
			КонецЕсли;
			ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекст);
		КонецЕсли;
		ПолеТекста.УстановитьВыделениеДвумерное(ВыделениеДвумерное);
		ПолучитьГраницыВыделения();
	Исключение
		Сообщить(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки; 

КонецПроцедуры

Функция ВыделенныйТекст(Знач НовыйТекст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Результат = ПолеТекста.ВыделенныйТекст(НовыйТекст);
	Если НовыйТекст <> Неопределено Тогда
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьВТекстЗапросаОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата, ИменаПолей = Неопределено) Экспорт 
	ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
	КонструкторЗапроса.ВосстановитьНастройкиФормы();
	Если КонструкторЗапроса.ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса) Тогда
		КонструкторЗапроса.ЗагрузитьПоследнийЗапрос();
		КонструкторЗапроса.ДобавитьОтборыПоСтрокеРезультата(ТекущаяСтрокаРезультата,, ИменаПолей);
		ВыделитьВесьТекст();
		ВыделенныйТекст(КонструкторЗапроса.СобратьПолныйТекст(, Истина));
		КонструкторЗапроса.ЗагрузитьПараметрыВОбъект();
		ПослеУстановкиВыделенногоМногострочногоТекста();
	КонецЕсли;
КонецПроцедуры

Процедура ВыделитьВесьТекст(ПолеТекста = Неопределено) Экспорт 
	
	Если ПолеТекста = Неопределено Тогда
		ПолеТекста = ЭтотОбъект.ПолеТекста;
	КонецЕсли; 
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекста.УстановитьГраницыВыделения(1, 1, Макс(1, КоличествоСтрок), СтрДлина(ПолеТекста.ПолучитьСтроку(КоличествоСтрок) + 1),, ФормаВладелец);

КонецПроцедуры

Процедура ПослеУстановкиВыделенногоМногострочногоТекста()
	
	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ФормаВладелец = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеТекстовогоДокумента") Тогда
		
		// Антибаг платформы https://partners.v8.1c.ru/forum/topic/1860281 , http://www.hostedredmine.com/issues/840411
		ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
		ПолеТекста.УстановитьГраницыВыделения(1, 1, 1, 1);
		ПолеТекста.ЭлементФормы.ВыделенныйТекст = "";
		ПолеТекста.УстановитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка,, ФормаВладелец);
		
		УстановитьПризнакМодифицированностиФормы();
	КонецЕсли; 

КонецПроцедуры

// Устанавливает фокус на связанное поле текста программы
Процедура УстановитьФокус(Знач Мягко = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ирОбщий.ПрисвоитьЕслиНеРавноЛкс(ФормаВладелец.ТекущийЭлемент, ПолеТекста.ЭлементФормы); // Условно меняем для ускорения
	Если Не Мягко Тогда
		ВосстановитьФокусВвода();
	КонецЕсли;

КонецПроцедуры

// https://www.hostedredmine.com/issues/931798 и куча похожих
Процедура ВосстановитьФокусВвода()
	
	Если Истина
		И ФормаВладелец <> Неопределено
		И ТипЗнч(ФормаВладелец.ТекущийЭлемент) = Тип("ПолеHTMLДокумента") 
	Тогда
		// https://github.com/salexdv/bsl_console/issues/122
		//ПолеТекста.РедакторHTML().focus();
		//ПолеТекста.РедакторHTML().editor.focus();
		ирКлиент.УстановитьФокусВводаФормеЛкс();
	КонецЕсли;

КонецПроцедуры

Процедура АвтоОбновитьСправку() Экспорт 
	
	Если Ложь
		Или Не ирКлиент.Форма_ВводДоступенЛкс(ФормаВладелец) 
		Или ФормаВладелец.ТекущийЭлемент <> ПолеТекста.ЭлементФормы
	Тогда
		Возврат;
	КонецЕсли; 
	Если мПоследнийРежимВызоваСправки = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	мЭтоАвтоВызов = Истина;
	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, мПоследнийРежимВызоваСправки); 
	Нажатие(Кнопка);
	ФормаВладелец.Активизировать();
	мЭтоАвтоВызов = Ложь;
	
КонецПроцедуры

Функция ПолучитьВыделенныйИлиВесьТекст() Экспорт 

	НовыйТекстЗапроса = ВыделенныйТекст();
	Если ПустаяСтрока(НовыйТекстЗапроса) Тогда
		НовыйТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	Возврат НовыйТекстЗапроса;

КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура КопироватьВБуферОбменаТекстВВидеКода() Экспорт

	ПрограммныйКод = ПолучитьВыделенныйИлиВесьТекст();
	ЛиВыделенВесьТекст = ПрограммныйКод = ПолеТекста.ПолучитьТекст();
	Если Прав(ПрограммныйКод, 1) <> Символы.ПС Тогда
		ПрограммныйКод = ПрограммныйКод + Символы.ПС;
	КонецЕсли; 
	ПрограммныйКод = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(ПрограммныйКод);
	Если ЛиВыделенВесьТекст Тогда
		ИменованныеЗапросы = мПлатформа.СтруктураРезультатаПакетногоЗапроса(ПрограммныйКод);
		ПрограммныйКод = ПрограммныйКод + ";" + Символы.ПС;
		Для Каждого КлючИЗначение Из ИменованныеЗапросы Цикл
			ПрограммныйКод = ПрограммныйКод + "Индекс_" + КлючИЗначение.Ключ + " = " + XMLСтрока(КлючИЗначение.Значение) + ";" + Символы.ПС;
		КонецЦикла;
	Иначе
		ПрограммныйКод = "|" + ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(ПрограммныйКод, """", Символы.ПС + "|""");
	КонецЕсли; 
	ирКлиент.ТекстВБуферОбменаОСЛкс(ПрограммныйКод);

КонецПроцедуры

Процедура Закомментировать() Экспорт

	#Если Сервер И Не Сервер Тогда
	    ПолеТекста = Новый ТекстовыйДокумент;
	#КонецЕсли
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = 0;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = Макс(1, СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока)));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + "//" + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + "//" +Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры  

Процедура Раскомментировать() Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПерваяСтрока = мНачальнаяСтрока;
	ПерваяКолонка = мНачальнаяКолонка;
	ПоследняяСтрока = мКонечнаяСтрока;
	ПоследняяКолонка = мКонечнаяКолонка;
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если Лев(СокрЛ(Фрагмент), 2) = "//" Тогда
				Позиция = Найти(Фрагмент, "//");
				Фрагмент = Лев(Фрагмент, Позиция - 1) + Сред(Фрагмент, Позиция + 2);
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + 3;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);
	
КонецПроцедуры

Процедура УдалитьЛевыеТабуляции(ЧислоШагов = 1) Экспорт

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	КоличествоСтрок = ирОбщий.СтрЧислоСтрокЛкс(ПолеТекста.ПолучитьТекст());  
	ПерваяСтрока = 1;
	ПерваяКолонка = 1;
	ПоследняяСтрока = КоличествоСтрок;
	ПоследняяКолонка = 50;
	ВыделенныйФрагмент = "";
	ДлинаПоследнейСтроки = ПоследняяКолонка;
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока - 1;
	КонецЕсли;
	Если ПерваяСтрока >= ПоследняяСтрока И ПоследняяКолонка = 1 Тогда 
		ПоследняяКолонка = СтрДлина(ПолеТекста.ПолучитьСтроку(ПерваяСтрока));
		ПоследняяСтрока = ПерваяСтрока;
	КонецЕсли;
	Маркер = Символы.Таб;
	УдаляемыйФрагмент = "";
	Для Счетчик = 1 По ЧислоШагов Цикл
		УдаляемыйФрагмент = УдаляемыйФрагмент + Маркер;
	КонецЦикла;
	Для НомерСтроки = 1 По КоличествоСтрок Цикл
		Фрагмент = ПолеТекста.ПолучитьСтроку(НомерСтроки);
		Если НомерСтроки >= ПерваяСтрока И НомерСтроки <= ПоследняяСтрока Тогда
			Если ирОбщий.СтрНачинаетсяСЛкс(Фрагмент, УдаляемыйФрагмент) Тогда
				Фрагмент = Сред(Фрагмент, СтрДлина(УдаляемыйФрагмент) + 1);
			КонецЕсли;
			Если НомерСтроки = ПерваяСтрока Тогда 
				ВыделенныйФрагмент = ВыделенныйФрагмент + Фрагмент;
			Иначе
				ВыделенныйФрагмент = ВыделенныйФрагмент + Символы.ПС + Фрагмент;
			КонецЕсли;
			Если НомерСтроки = ПоследняяСтрока Тогда 
				ДлинаПоследнейСтроки = СтрДлина(Фрагмент) + СтрДлина(УдаляемыйФрагмент) + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	ЗаменитьФрагментТекстаВПоле(ПолеТекста, ВыделенныйФрагмент, ДлинаПоследнейСтроки, ПерваяСтрока, ПоследняяСтрока, ПоследняяКолонка);

КонецПроцедуры

Процедура ЗаменитьФрагментТекстаВПоле(Знач ПолеТекста, Знач ВыделенныйФрагмент, Знач ДлинаПоследнейСтроки, Знач ПерваяСтрока, Знач ПоследняяСтрока, Знач ПоследняяКолонка)
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПоследняяКолонка = 1 Тогда 
		ПоследняяСтрока = ПоследняяСтрока + 1;
		ДлинаПоследнейСтроки = 1;
		ВыделенныйФрагмент =  ВыделенныйФрагмент + Символы.ПС;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки);
	ЧислоПереносовСтрокНачальное = СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1;
	Если ЧислоПереносовСтрокНачальное > ПоследняяСтрока - ПерваяСтрока Тогда
		// https://www.hostedredmine.com/issues/925662
		Для Счетчик = 1 По Мин(2, ДлинаПоследнейСтроки - 1) Цикл 
			ДлинаПоследнейСтрокиБезПереноса = ДлинаПоследнейСтроки - Счетчик;
			ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтрокиБезПереноса);
			Если СтрЧислоСтрок(ВыделенныйТекст() + "й") - 1 < ЧислоПереносовСтрокНачальное Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	ВыделенныйТекст(ВыделенныйФрагмент);
	ПолеТекста.УстановитьГраницыВыделения(ПерваяСтрока, 1, ПоследняяСтрока, ДлинаПоследнейСтроки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры 

Процедура ПрочитатьНачалоИКонецТекущейСтроки(Знач ОригинальнаяСтрока = "", Знач НомерПозиции = 0) Экспорт
	СброситьРезультатРазбораПозицииВТексте();   
	Если Не ЗначениеЗаполнено(ОригинальнаяСтрока) Тогда
		//ОригинальнаяСтрока = СокрП(ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока));
		ОригинальнаяСтрока = ПолеТекста.ПолучитьСтроку(мКонечнаяСтрока);
	КонецЕсли;
	Если НомерПозиции = 0 Тогда
		НомерПозиции = мКонечнаяКолонка;
	КонецЕсли;
	Для Счетчик = 0 По НомерПозиции - СтрДлина(ОригинальнаяСтрока) - 2 Цикл
		ОригинальнаяСтрока = ОригинальнаяСтрока + " ";
	КонецЦикла;
	мТекущаяСтрокаНачало = Лев(ОригинальнаяСтрока, НомерПозиции - 1);
	мТекущаяСтрокаКонец = Сред(ОригинальнаяСтрока, НомерПозиции);
	мЭтоСтроковыйЛитерал = ирОбщий.ЛиВнутриТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало);
КонецПроцедуры

Процедура РазобратьКонтекстСтроки(Знач ЛиСправаОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Ложь) Экспорт
	мЭтоОбъявлениеПсевдонима = Ложь;
	мВызовМетода = "";
	Если Ложь
		Или КакВызовМетода = Истина
		Или КакВызовМетода = Неопределено И мЭтоСтроковыйЛитерал 
	Тогда
		ТекущийВызовМетода();
	КонецЕсли; 
	мРегВыражение.Global = Ложь;
		
	// Начало контекста 
	СтрокаШаблона = шПредИмя + "(";
	Если Ложь
		Или мЯзыкПрограммы = 1
		Или мЯзыкПрограммы = 2
	Тогда
		СтрокаШаблона = "(?:" + шРазделитель + "+(КАК|AS|(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?))" + шРазделитель + "*)?" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?";
	Иначе
		СтрокаШаблона = "()" + СтрокаШаблона + шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + шСкобки + "?" + "((\.(" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*\.?)?"; 
	Если ЛиСправаОтРавенства Тогда
		СтрокаШаблона = СтрокаШаблона + шРазделитель + "*=" + шРазделитель + "*";
	КонецЕсли;
	СтрокаШаблона = СтрокаШаблона + "$";
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		мНачалоКонтекста = "" + ПервоеВхождение.SubMatches(1);
		мЭтоОбъявлениеПсевдонима = ПервоеВхождение.SubMatches(0) <> Неопределено И Найти(мНачалоКонтекста, ".") = 0;
	КонецЕсли;
	
	// Конец контекста
	мРегВыражение.Global = Ложь;
	Если Не ЛиСправаОтРавенства Тогда
		мРегВыражение.Pattern = "([" + шБуква + "\d]*\(?)(\.)?";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаКонец);
		Если Результат.Количество() > 0 Тогда
			мКонецКонтекста = Результат[0].SubMatches(0);
			выхЕстьТочкаСправа = Результат[0].SubMatches(1) <> Неопределено;
		КонецЕсли;
	КонецЕсли; 

	СтрокаШаблона = шПрефиксПараметраНеобяз + "(?:" + шИмя + ")?"; 
	СтрокаШаблона = "(?:((?:" + шИмяСкобки + "?" + "(?:(?:\." + шИмяСкобки + "?)|" + шИндекс + ")*))\.)?(" + СтрокаШаблона + ")?$";
	// Родительский контекст по позиции курсора
	мРегВыражение.Pattern = СтрокаШаблона;
	Результат = мРегВыражение.НайтиВхождения(мНачалоКонтекста);
	Если Результат.Количество() > 0 Тогда
		ПервоеВхождение = Результат[0];
		Если ПервоеВхождение.SubMatches(0) <> Неопределено Тогда 
			мРодительскийКонтекст = ПервоеВхождение.SubMatches(0);
		КонецЕсли;
		Если ПервоеВхождение.SubMatches(4) <> Неопределено Тогда 
			мНачалоСлова = ПервоеВхождение.SubMatches(4);
		КонецЕсли;
	КонецЕсли;
	мТекущееСлово = мНачалоСлова + ирОбщий.ПервыйФрагментЛкс(мКонецКонтекста);
	мКонтекст = мНачалоКонтекста + мКонецКонтекста;
КонецПроцедуры

// Замена операторов внешнего перехода https://partners.v8.1c.ru/forum/t/1849050/m/1849050
Функция ЗаменитьОператорыВнешнегоПерехода(Знач Текст = Неопределено, выхТипыВнешнихПереходов, выхЗаглушкаВозврата = "", выхИмяПараметраТипаВыхода = "") Экспорт 
	
	Перем ИмяМетода;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	УникальнаяСтрока = "1092383289";
	Если Не ЗначениеЗаполнено(выхЗаглушкаВозврата) Тогда
		выхЗаглушкаВозврата = "Возврат" + УникальнаяСтрока + "=0";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(выхИмяПараметраТипаВыхода) Тогда
		выхИмяПараметраТипаВыхода = "ТипВыхода";
	КонецЕсли; 
	Если Текст <> Неопределено Тогда
		ПолеТекста.УстановитьТекст(Текст);
	КонецЕсли; 
	Если выхТипыВнешнихПереходов = Неопределено Тогда
		выхТипыВнешнихПереходов = Новый Структура;
	КонецЕсли; 
	СтартоваяСтрока = 0;
	Пока Истина Цикл
		ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
		Если ИнформацияОбОшибке = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		ОписаниеОшибки = ИнформацияОбОшибке.Описание;
		Если Найти(ОписаниеОшибки, "Оператор Прервать") > 0 Тогда
			ИмяОператора = "Прервать";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Продолжить") > 0 Тогда
			ИмяОператора = "Продолжить";
		ИначеЕсли Найти(ОписаниеОшибки, "Оператор Возврат") > 0 Тогда
			ИмяОператора = "Возврат";
		//ИначеЕсли Найти(ОписаниеОшибки, "Оператор Перейти") > 0 Тогда
		//	ИмяОператора = "Перейти"; // TODO
		Иначе
			Прервать;
		КонецЕсли; 
		КоординатыОшибки = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
		выхТипыВнешнихПереходов.Вставить(ИмяОператора);
		
		// Выделяем вхождение имени оператора в ПолеТекста
		ПолеТекста.УстановитьГраницыВыделения(1, 1, КоординатыОшибки.НомерСтроки, КоординатыОшибки.НомерКолонки);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(СокрП(ВыделенныйТекст()));
		КоличествоСтрок = ТекстовыйДокумент.КоличествоСтрок();
		ДлинаПоследнейСтроки = СтрДлина(ТекстовыйДокумент.ПолучитьСтроку(КоличествоСтрок) + 1);
		ПолеТекста.УстановитьГраницыВыделения(Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки - СтрДлина(ИмяОператора), Макс(1, КоличествоСтрок), ДлинаПоследнейСтроки);
		
		ВыделенныйТекст(выхИмяПараметраТипаВыхода + " = """ + ИмяОператора + """; " + выхЗаглушкаВозврата);
		Если ИмяОператора = "Возврат" Тогда
			ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(, СтартоваяСтрока,,, Истина);
			Если ИнформацияОбОшибке <> Неопределено Тогда
				#Если Сервер И Не Сервер Тогда
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				#КонецЕсли
				ОписаниеОшибки = ИнформацияОбОшибке.Описание;
				КоординатыОшибкиПосле = КоординатыОшибки(ИнформацияОбОшибке, СтартоваяСтрока);
				Если КоординатыОшибкиПосле.НомерСтроки = КоординатыОшибки.НомерСтроки Тогда
					ВыделенныйТекст("=");
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Текст = ПолеТекста.ПолучитьТекст();
	Возврат Текст;

КонецФункции

Функция КоординатыОшибки(Знач ИнформацияОбОшибке, Знач СтартоваяСтрока = 0) Экспорт 
	
	КоординатыОшибки = Новый Структура("НомерСтроки, НомерКолонки");
	мРегВыражение.Pattern = "{[^\(]*\(([^\)]+)\)}";
	ТекстКоординат = мРегВыражение.НайтиВхождения(ИнформацияОбОшибке.Описание)[0].SubMatches(0);  
	Фрагменты = ирОбщий.СтрРазделитьЛкс(ТекстКоординат, ",", Истина);
	КоординатыОшибки.НомерСтроки = Число(Фрагменты[0]) + СтартоваяСтрока;
	КоординатыОшибки.НомерКолонки = Число(Фрагменты[1]);
	Возврат КоординатыОшибки;

КонецФункции

Процедура ВыделитьТекущееСлово() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	Если Не ПустаяСтрока(мРодительскийКонтекст) Тогда
		мНачальнаяКолонка = мНачальнаяКолонка + СтрДлина(мРодительскийКонтекст) + 1;
	КонецЕсли;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры  

Функция ПереименоватьСлово() Экспорт 

	Форма = ПолучитьФорму("ПереименоватьСлово");
	РезультатФормы = Форма.ОткрытьМодально();
	Возврат РезультатФормы;

КонецФункции

Функция ВыделитьМетод(Знач Параметры = Неопределено, Знач ИмяВременногоМодуля = "") Экспорт 

	Перем НачСтрока, НачКолонка, КонСтрока, КонКолонка;
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст();  
	АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс();
	#Если Сервер И Не Сервер Тогда
		АнализаторКода = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		ПараметрыВходаАлгоритма = Новый Структура;
	#КонецЕсли
	АнализаторКода.ИнициироватьНеинтерактивно();
	АнализаторКода.мФлагиКомпиляции = мФлагиКомпиляции;
	АнализаторКода.ЭтоМодуль = Истина;
	НомераПервойСтрокиТела = 1;
	АнализаторКода.УстановитьТекст(ТелоАктивногоМетода(НомераПервойСтрокиТела));
	//НевидимоеПолеТекста.мМодульМетаданных = мМодульМетаданных;
	СмещениеНомеровСтрок = НомераПервойСтрокиТела - 1;
	Если Не ЗначениеЗаполнено(ВыделенныйТекст()) Тогда
		ПолеТекста.УстановитьГраницыВыделения(мНомерПервойСтрокиТелаМетода, 1, мНомерПоследнейСтрокиТелаМетода + 1, 1);
	КонецЕсли;  
	Если Параметры = Неопределено Тогда
		Параметры = ЭтотОбъект.Параметры;
	КонецЕсли;
	ПолеТекста.ПолучитьГраницыВыделения(НачСтрока, НачКолонка, КонСтрока, КонКолонка);
	Если КонСтрока - СмещениеНомеровСтрок < 1 Или НачСтрока - СмещениеНомеровСтрок < 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
	ТекстНовогоМетода = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	Если Не ЗначениеЗаполнено(ТекстНовогоМетода) Тогда
		Возврат Ложь;
	КонецЕсли;  
	ОчиститьСообщения();
	ТекстСмещения = ирОбщий.ПервыеНепечатныеСимволыПервойНепустойСтрокиЛкс(ТекстНовогоМетода);
	//ФормаВладелец.Модифицированность = Истина;
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(1, 1, НачСтрока - СмещениеНомеровСтрок, НачКолонка);
	ТекстДо = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(КонСтрока - СмещениеНомеровСтрок, КонКолонка, Макс(1, АнализаторКода.ПолеТекста.КоличествоСтрок()), 300);
	ТекстПосле = АнализаторКода.ПолеТекста.ВыделенныйТекст();
	АнализаторКода.ПолеТекста.УстановитьГраницыВыделения(НачСтрока - СмещениеНомеровСтрок, НачКолонка, КонСтрока - СмещениеНомеровСтрок, КонКолонка);
	ФормаНовогоМетода = АнализаторКода.ПолучитьФорму("ВыделениеМетода", ФормаВладелец);
	ЛиКорректныйФрагмент = Истина; 
	ЗаглушкаВозврата = "";
	ИмяПараметраТипаВыхода = "";
	ИмяПеременнойЗаглушки = "Пустышка845234571";
	ТекстДо = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстДо, , ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
	ТекстПосле = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстПосле, , ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
	СтруктураПараметровКода = Новый Структура;
	МетаОбщиеМодули = Метаданные.ОбщиеМодули;
	ТипыВнешнихПереходов = Новый Структура;
	ТекстНовогоМетода = АнализаторКода.ЗаменитьОператорыВнешнегоПерехода(ТекстНовогоМетода, ТипыВнешнихПереходов, ЗаглушкаВозврата, ИмяПараметраТипаВыхода);
	Если ТипыВнешнихПереходов.Количество() > 0 Тогда
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = ИмяПараметраТипаВыхода;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.Вход = Ложь;
		СтрокаПараметра.Выход = Истина;
		СтрокаПараметра.ТипЗначения = "Строка";
		СтрокаПараметра.Комментарий = "Служебный параметр для перехода после вызова метода";
	КонецЕсли;
	
	ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент,, Истина);
	Если Не ЛиКорректныйФрагмент Тогда
		Возврат "Ошибка";
	КонецЕсли; 
	
	// Добавим переменные, которые не определены в выделенном фрагменте текста, как входные параметры
	ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма(ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент,,, Ложь);
	ЗаглушкаТекстаМетода = "";
	ЭтоВыражение = Ложь;
	Если Не ЛиКорректныйФрагмент Тогда
		// Выделено выражение
		ЭтоВыражение = Истина;
		ЗаглушкаТекстаМетода = "0";
		ПараметрыВходаАлгоритма = ПараметрыИзАлгоритма("ми7ва7в9вц3ая = " + ТекстНовогоМетода, АнализаторКода, ЛиКорректныйФрагмент);
		Если Не ЛиКорректныйФрагмент Тогда
			Возврат "Ошибка";
		КонецЕсли; 
	КонецЕсли; 
	АнализаторКода.УстановитьТекст(ТекстДо);
	ФормаНовогоМетода.ТекстСмещения = ТекстСмещения;
	Для Каждого КлючИЗначение Из ПараметрыВходаАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
		СтрокаПараметра.Имя = КлючИЗначение.Ключ;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		СтрокаПараметра.Вход = Истина;
		// TODO сделать более универсальное экранирование конструктора "Новый <ИмяПеременной>"
		Пока АнализаторКода.НайтиПоказатьСловоВТексте("Новый " + КлючИЗначение.Ключ) Цикл
			АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
		КонецЦикла;
		Пока АнализаторКода.НайтиПоказатьСловоВТексте(КлючИЗначение.Ключ) Цикл
			АнализаторКода.ПолеТекста.ВыделенныйТекст(ИмяПеременнойЗаглушки);
		КонецЦикла;
	КонецЦикла;
	ТекстДоПереименованный = АнализаторКода.ПолеТекста.ПолучитьТекст();
	
	// Добавим внутренние переменные, чтобы пользователь мог включить их передачу на выход
	АнализаторКода.УстановитьТекст(ТекстНовогоМетода);
	АнализаторКода.РазобратьТекущийКонтекст();
	АнализаторКода.ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(,,,, Истина,,, Истина);
	СтрокиЛокальныхПеременных = АнализаторКода.ТаблицаСлов.НайтиСтроки(Новый Структура("ТипСлова, Определение", "Свойство", "Статистический"));
	Для Каждого СтрокаПеременной Из СтрокиЛокальныхПеременных Цикл
		Если мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(СтрокаПеременной.НСлово) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если ирОбщий.СтрокиРавныЛкс(СтрокаПеременной.НСлово, ирОбщий.ПервыйФрагментЛкс(ЗаглушкаВозврата, "=", Ложь)) Тогда
			Продолжить;
		КонецЕсли; 
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(СтрокаПеременной.НСлово, "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = СтрокаПеременной.Слово;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		КонецЕсли; 
	КонецЦикла;
	
	// Добавим переменные, которые не определены начиная с первой выделеной строки и до конца текста, как свозные параметры
	ПараметрыСквозныеАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ТекстНовогоМетода + ТекстПосле, АнализаторКода, ЛиКорректныйФрагмент,
		ИмяПеременнойЗаглушки); 
	Если Не ЛиКорректныйФрагмент Тогда
		Возврат "Ошибка";
	КонецЕсли;  
	#Если Сервер И Не Сервер Тогда
		ПараметрыСквозныеАлгоритма = Новый Структура;
	#КонецЕсли
	Для Каждого КлючИЗначение Из ПараметрыСквозныеАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = КлючИЗначение.Ключ;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		КонецЕсли; 
		СтрокаПараметра.Вход = Истина;
		СтрокаПараметра.Выход = Истина;
	КонецЦикла;
	
	// Добавим переменные, которые не определены в следующем тексте, как параметры выхода
	ПараметрыВыходаАлгоритма = ПараметрыИзАлгоритма(ТекстДоПереименованный + ЗаглушкаТекстаМетода + ТекстПосле, АнализаторКода,, ИмяПеременнойЗаглушки);
	#Если Сервер И Не Сервер Тогда
		ПараметрыВыходаАлгоритма = Новый Структура;
	#КонецЕсли
	ТаблицаЛокальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаМодуля(),,,,,, "Свойство", мФлагиКомпиляции,,,,, Истина);
	ирОбщий.ОбновитьКопиюКолонкиВНижнемРегистреЛкс(ТаблицаЛокальногоКонтекста, "Слово");
	ИмяРезультатаВыражения = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(ТаблицаЛокальногоКонтекста, "Результат", "Слово");
	Если ЭтоВыражение Тогда
		ПараметрыВыходаАлгоритма.Вставить(ИмяРезультатаВыражения);
	КонецЕсли; 
	Для Каждого КлючИЗначение Из ПараметрыВыходаАлгоритма Цикл
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра = Неопределено Тогда
			СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Добавить();
			СтрокаПараметра.Имя = КлючИЗначение.Ключ;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
		КонецЕсли; 
		СтрокаПараметра.Выход = Истина;
	КонецЦикла; 
	
	// Удалим переменные, которые не определены в оригнальном тексте
	ПараметрыВыходаЛожные = ПараметрыИзАлгоритма(ТекстДо + ТекстНовогоМетода + ТекстПосле, АнализаторКода,,,, Ложь);
	#Если Сервер И Не Сервер Тогда
		ПараметрыВыходаЛожные = Новый Структура;
	#КонецЕсли
	Для Каждого КлючИЗначение Из ПараметрыВыходаЛожные Цикл
		Если ПараметрыВходаАлгоритма.Свойство(КлючИЗначение.Ключ) Тогда
			Продолжить;
		КонецЕсли; 
		СтрокаПараметра = ФормаНовогоМетода.ТаблицаПараметров.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
		Если СтрокаПараметра <> Неопределено Тогда
			ФормаНовогоМетода.ТаблицаПараметров.Удалить(СтрокаПараметра);
		КонецЕсли; 
	КонецЦикла;
	
	Для Каждого СтрокаПараметра Из ФормаНовогоМетода.ТаблицаПараметров Цикл
		СтрокаПараметра.Обязательный = СтрокаПараметра.Вход; 
		СтрокаПараметра.Позиция = 200;
		
		// Параметры исходного метода
		ПараметрМетода = Неопределено;
		ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
		Если ПараметрыМетодаМодуля <> Неопределено Тогда
			ПараметрМетода = ПараметрыМетодаМодуля.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
			Если ПараметрМетода <> Неопределено Тогда
				СтрокаПараметра.Комментарий = ПараметрМетода.Описание;
				СтрокаПараметра.Позиция = ПараметрыМетодаМодуля.Индекс(ПараметрМетода);
				СтрокаПараметра.ТипЗначения = ПараметрМетода.ТипЗначения;
				Если ЗначениеЗаполнено(ПараметрМетода.Значение) Тогда
					СтрокаПараметра.Значение = Вычислить(ПараметрМетода.Значение);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если ПараметрМетода = Неопределено Тогда
			СтрокаПараметра.СвойствоМодуля = ТаблицаЛокальногоКонтекста.Найти(НРег(СтрокаПараметра.НИмя), "НСлово") <> Неопределено; 
			Если СтрокаПараметра.СвойствоМодуля Тогда
				СтрокаПараметра.Вход = Ложь;
				СтрокаПараметра.Выход = Ложь;
			КонецЕсли;
			// Динамический локальный контекст (например консоль кода)
			СтрокаЭтогоАлгоритмаПараметры = Параметры.Найти(НРег(СтрокаПараметра.Имя), "НИмя");
			Если Истина
				И СтрокаЭтогоАлгоритмаПараметры <> Неопределено 
				И (Ложь
					Или мМетодМодуля = Неопределено
					Или СтрокаЭтогоАлгоритмаПараметры.Модуль)
			Тогда
				СтрокаПараметра.Комментарий = СтрокаЭтогоАлгоритмаПараметры.Комментарий;
				СтрокаПараметра.Позиция = СтрокаЭтогоАлгоритмаПараметры.Позиция + 100;
				СтрокаПараметра.ТипЗначения = СтрокаЭтогоАлгоритмаПараметры.ИмяТипаЗначения;
				СтрокаПараметра.СвойствоМодуля = СтрокаЭтогоАлгоритмаПараметры.Модуль;
				ТипЗначения = ТипЗнч(СтрокаЭтогоАлгоритмаПараметры.Значение);
				Если Ложь
					Или ТипЗначения = Тип("Строка") И СтрДлина(СтрокаЭтогоАлгоритмаПараметры.Значение) < 100
					Или ТипЗначения = Тип("Число")
					Или ТипЗначения = Тип("Булево")
					Или ТипЗначения = Тип("Неопределено")
					Или ТипЗначения = Тип("Null")
				Тогда
					СтрокаПараметра.Значение = СтрокаЭтогоАлгоритмаПараметры.Значение;
				КонецЕсли; 
				Если СтрокаПараметра.Значение <> Неопределено Тогда
					СтрокаПараметра.Обязательный = Ложь;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(СтрокаПараметра.ТипЗначения) Тогда
			СтрокаПараметра.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ВычислитьТипЗначенияВыражения(СтрокаПараметра.Имя, ТекстДо + ТекстНовогоМетода));
		КонецЕсли; 
	КонецЦикла;
	//ЗаменаЗаглушки = Символы.ПС + ТекстСмещения + "Возврат";
	Если ЭтоВыражение Тогда
		ТекстНовогоМетода = Символы.Таб + ИмяРезультатаВыражения + " = " + ТекстНовогоМетода + ";";
	КонецЕсли; 
	ЗаменаЗаглушкиВозврата = "Возврат";
	ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата + "=", ЗаменаЗаглушкиВозврата);
	ЗаменаЗаглушкиВозврата = ЗаменаЗаглушкиВозврата + " Неопределено";
	ТекстНовогоМетода = СтрЗаменить(ТекстНовогоМетода, ЗаглушкаВозврата, ЗаменаЗаглушкиВозврата);
	Если мМетодМодуля <> Неопределено Тогда
		ИмяНовогоМетода = ирОбщий.АвтоУникальноеИмяВКоллекцииЛкс(мМодульМетаданных.Методы, мМетодМодуля.Имя);
		ФормаНовогоМетода.ЛиАсинх = мМетодМодуля.ЛиАсинх;
		ФормаНовогоМетода.ДирективаКомлиляции = Сред(мМетодМодуля.Аннотация, 2);
	Иначе
		ИмяНовогоМетода = ИмяВременногоМодуля;
	КонецЕсли;
	ФормаНовогоМетода.Имя = ИмяНовогоМетода;
	ФормаНовогоМетода.ЭлементыФормы.ПолеТела.УстановитьТекст(ТекстНовогоМетода);
	ФормаНовогоМетода.РежимВыбора = Истина;
	ФормаНовогоМетода.ЭтоВыражение = ЭтоВыражение;
	ФормаНовогоМетода.ИмяПараметраТипаВыхода = ИмяПараметраТипаВыхода;
	ФормаНовогоМетода.ТипыВнешнихПереходов = ТипыВнешнихПереходов;
	РезультатФормы = ФормаНовогоМетода.ОткрытьМодально();
	Если РезультатФормы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если Ложь
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр 
		Или ПолеТекста.ТолькоПросмотр() 
	Тогда
		ирКлиент.ОткрытьТекстЛкс(ФормаНовогоМетода.ПолноеОпределение, "Метод " + ФормаНовогоМетода.Имя, "ВстроенныйЯзык");
		ирОбщий.СообщитьЛкс("Поле текста недоступно для изменения.");
		Возврат Ложь;
	КонецЕсли;
	СтруктураВыделения = ПолеТекста.ВыделениеДвумерное();
	Если мМетодМодуля <> Неопределено Тогда
		ПолеТекста.ВставитьСтроку(мНомерПоследнейСтрокиТелаМетода + 2, Символы.ПС + ФормаНовогоМетода.ПолноеОпределение);
	КонецЕсли;
	ПолеТекста.УстановитьВыделениеДвумерное(СтруктураВыделения);
	ВыделенныйТекст(ФормаНовогоМетода.ТекстВставки);
	Если мМетодМодуля = Неопределено Тогда
		ПолеТекста.ВставитьСтроку(мНомерПервойСтрокиТелаМетода, Символы.ПС + ФормаНовогоМетода.ПолноеОпределение);
	КонецЕсли;
	Если ФормаВладелец = Неопределено Тогда
		Возврат ФормаНовогоМетода.ПолноеОпределение;
	КонецЕсли;
	Возврат Истина;

КонецФункции

Функция СтруктураТипаМодуля()
	
	СтруктураТипаМодуля = мМодульМетаданных.СтруктураТипа;
	Если СтруктураТипаМодуля = Неопределено Тогда
		СтруктураТипаМодуля = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОбщийМодуль"));
	КонецЕсли;
	Возврат СтруктураТипаМодуля;

КонецФункции

Функция ЗаменитьВозвратыНаПерейтиВТекстеМетода(Знач Текст = Неопределено, Знач ИмяПеременнойРезультата = "Результат", Знач ДобавлятьПереносыСтрок = Ложь, Знач ИмяМетки = "Конец", Знач ВставитьМетку = Ложь) Экспорт
	
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Результат = мПлатформа.ЗаменитьВозвратыНаПерейтиВТекстеМетода(Текст, ИмяПеременнойРезультата, ДобавлятьПереносыСтрок, ИмяМетки, ВставитьМетку);
	Возврат Результат;
	
КонецФункции

Функция ПараметрыИзАлгоритма(Знач ТекстДляПроверки, Знач НевидимоеПолеПрограммы, выхКорректныйФрагмент = Истина, Знач ИгнорироватьПеременную = "", Знач ПоказыватьСтрокуОшибки = Ложь, Знач ВыводитьОшибку = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НевидимоеПолеПрограммы = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтруктураПараметровКода = Новый Структура;
	МетаОбщиеМодули = Метаданные.ОбщиеМодули;
	мСмещениеНомеровСтрок = 0; 
	ТекстДляПроверки = мПлатформа.ЗаменитьВозвратыНаПерейтиВТекстеМетода(ТекстДляПроверки,,, "КонецСлужебный", Истина);
	НевидимоеПолеПрограммы.УстановитьТекст(ТекстДляПроверки);
	Пока Истина Цикл
		ИнформацияОбОшибке = НевидимоеПолеПрограммы.ПроверитьТекстИВернутьОшибку(, мСмещениеНомеровСтрок, , , Истина);
		НеопределенныйМетод = мПлатформа.ИмяНеопределенногоМетодаИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если НеопределенныйМетод <> Неопределено Тогда
			КоординатыОшибки = НевидимоеПолеПрограммы.КоординатыОшибки(ИнформацияОбОшибке, мСмещениеНомеровСтрок);
			НачальнаяКолонка = КоординатыОшибки.НомерКолонки;
			НевидимоеПолеПрограммы.ПолеТекста.УстановитьГраницыВыделения(КоординатыОшибки.НомерСтроки, НачальнаяКолонка, КоординатыОшибки.НомерСтроки, НачальнаяКолонка);
			НевидимоеПолеПрограммы.ПолеТекста.ВыделенныйТекст("ирОбщий.");
			Продолжить;
		КонецЕсли; 
		НеопределеннаяПеременная = мПлатформа.ИмяНеопределеннойПеременнойИзИнформацииОбОшибке(ИнформацияОбОшибке);
		Если Не ЗначениеЗаполнено(НеопределеннаяПеременная) Тогда
			выхКорректныйФрагмент = ИнформацияОбОшибке = Неопределено;
			Если Не выхКорректныйФрагмент И ВыводитьОшибку Тогда
				// Сообщим ошибку
				Если ПоказыватьСтрокуОшибки Тогда 
					Если ФормаВладелец <> Неопределено Тогда
						ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					КонецЕсли;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, мСмещениеНомеровСтрок,,,, ИнформацияОбОшибке);
				Иначе
					НевидимоеПолеПрограммы.ПроверитьПрограммныйКод();
				КонецЕсли; 
			КонецЕсли; 
			Прервать;
		КонецЕсли;
		Если мФлагиКомпиляции.Сервер И МетаОбщиеМодули.Найти(НеопределеннаяПеременная) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если Ложь
			Или Не ЗначениеЗаполнено(ИгнорироватьПеременную) 
			Или Не ирОбщий.СтрокиРавныЛкс(ИгнорироватьПеременную, НеопределеннаяПеременная) 
		Тогда
			СтруктураПараметровКода.Вставить(НеопределеннаяПеременная);
		КонецЕсли; 
		НевидимоеПолеПрограммы.ПолеТекста.ВставитьСтроку(1, НеопределеннаяПеременная + "=0;");
		мСмещениеНомеровСтрок = мСмещениеНомеровСтрок + 1;
	КонецЦикла;
	Возврат СтруктураПараметровКода;

КонецФункции

Процедура ВыделитьТекущееОбъектноеВыражение() Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущееОбъектноеВыражение();
	мНачальнаяКолонка = мКонечнаяКолонка - СтрДлина(мНачалоКонтекста);
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(мКонецКонтекста);
	Если Прав(мКонецКонтекста, 1) = "(" Тогда
		мКонечнаяКолонка = мКонечнаяКолонка - 1;
	КонецЕсли;
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец);

КонецПроцедуры

// Получает путь к описанию заданного контекста.
//
// Параметры:
//  ПутьКСлову   - Строка;
//  *СтрокаОписания - СтрокаТаблицыЗначений - возвращаемая строка описания;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
Функция НайтиПоказатьСправкуПоСлову(Знач ПутьКСлову, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, РазрешитьАнализИмениТипа = Истина,
	ВладелецФормы = Неопределено) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТаблицаСтруктурТиповКонтекста = ВычислитьТипЗначенияВыражения(ПутьКСлову, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, РазрешитьАнализИмениТипа, мЭтоКонструктор);
	ОтносительныйПутьКОписанию = "";
	Если ТаблицаСтруктурТиповКонтекста.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураТипаКонтекста = ТаблицаСтруктурТиповКонтекста[0];
	Результат = НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипаКонтекста, ВключатьПутьКОписаниюТипаЗначения, выхФормаВыбора, ВладелецФормы, ТаблицаСтруктурТиповКонтекста);
	Возврат Результат;

КонецФункции

Функция НайтиПоказатьСправкуПоСтруктуреТипа(Знач ПутьКСлову, Знач СтруктураТипа, ВключатьПутьКОписаниюТипаЗначения = Ложь, выхФормаВыбора = Неопределено, ВладелецФормы = Неопределено,
	Знач ТаблицаСтруктурТиповКонтекста = Неопределено)
	
	Если Истина
		И ТипЗнч(СтруктураТипа.СтрокаОписания) <> Тип("СтрокаТаблицыЗначений")
		И ТипЗнч(СтруктураТипа.Метаданные) = Тип("COMОбъект") 
	Тогда
		Если мНомерПараметра > 0 Тогда
			Возврат Неопределено;
		КонецЕсли; 
		МетаданныеСлова = СтруктураТипа.Метаданные;
		ИмяТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
		Попытка
			Пустышка = МетаданныеСлова.Path_;
		Исключение
			Пустышка = Неопределено;
		КонецПопытки;
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову, ".", Ложь);
		Если Прав(ПутьКСлову, 1) = "(" Тогда
			Слово = СтрЗаменить(Слово, "(", "");
		КонецЕсли; 
		Если Пустышка <> Неопределено Тогда
			// WMI
			ИмяКлассаWMI = МетаданныеСлова.Path_.Class;
			Если ЗначениеЗаполнено(Слово) Тогда
				ОписаниеСлова = ирОбщий.ДокументацияСвойстваWMIЛкс(ИмяКлассаWMI, Слово);
				Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(ОписаниеСлова);
					ТекстовыйДокумент.Показать(ИмяКласса + "." + Слово);
				КонецЕсли; 
			КонецЕсли;
		Иначе
			ЗапуститьПриложение("http://google.com/search?q=" + ирОбщий.ПервыйФрагментЛкс(ИмяТипа, " ") + "+" + Слово);
		КонецЕсли; 
	Иначе
		Если ВладелецФормы <> Неопределено И СтруктураТипа.СтрокаОписания <> Неопределено Тогда
			ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
			#Если Сервер И Не Сервер Тогда
				ТаблицаВладелец = Новый ТаблицаЗначений;
			#КонецЕсли
			Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено  Тогда
				ФормаВызовМетода = ФормаВызовМетода();
				ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = СтруктураТипа;
				БылаОткрыта = ФормаВызовМетода.Открыта();
				Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
					ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаВызовМетода, Ложь);
					ФормаВызовМетода.Автозакрытие = Ложь;
					Если Не БылаОткрыта Тогда
						ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец);
					КонецЕсли; 
				Иначе
					ФормаВызовМетода.ОткрытьМодально();
				КонецЕсли;
				Возврат ФормаВызовМетода;
			КонецЕсли; 
		КонецЕсли; 
		Если СтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда 
			ВключатьПутьКОписаниюТипаЗначения = Истина;
		КонецЕсли; 
		Слово = ирОбщий.ПоследнийФрагментЛкс(ПутьКСлову);
		// Возможные роли слова без учета вычисленного контекста
		ТаблицаСтруктурВозможныхТиповКонтекста = ирКлиент.НайтиВозможныеСтрокиОписанияСловаВСинтаксПомощникеЛкс(Слово, ЯзыкПрограммы);
		Если ТаблицаСтруктурТиповКонтекста = Неопределено Тогда
			ТаблицаСтруктурТиповКонтекста = Новый Массив;
			ТаблицаСтруктурТиповКонтекста.Добавить(СтруктураТипа);
		КонецЕсли; 
		СтруктураЦикла = Новый Соответствие;
		СтруктураЦикла.Вставить("1.Предсказанные:", ТаблицаСтруктурТиповКонтекста);
		СтруктураЦикла.Вставить("2.Возможные:", ТаблицаСтруктурВозможныхТиповКонтекста);
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли
		Если ВладелецФормы = Неопределено Тогда
			ВладелецФормы = ФормаВладелец;
		КонецЕсли; 
		мПлатформа.ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения, ВладелецФормы, Слово, мНомерПараметра,, выхФормаВыбора, мФактическиеПараметры.Количество());
	КонецЕсли;
	Возврат Неопределено;

КонецФункции

// Открывает контекстную справку по текущему слову или его типу.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Функция ОткрытьКонтекстнуюСправку(ПутьКСлову = "", ВладелецФормы = Неопределено) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	//КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	РазрешитьАнализИмениТипа = Не ЗначениеЗаполнено(ПутьКСлову);
	Если РазрешитьАнализИмениТипа Тогда 
		ПутьКСлову = мТекущееСлово;
	КонецЕсли;
	Если мРодительскийКонтекст <> "" Тогда 
		ПутьКСлову = мРодительскийКонтекст + "." + ПутьКСлову;
	КонецЕсли;
	НайтиПоказатьСправкуПоСлову(ПутьКСлову,,, РазрешитьАнализИмениТипа, ВладелецФормы);
	
КонецФункции 

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОткрытьСправкуПоЯзыкуПрограммы() Экспорт 

	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс() Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ЯзыкПрограммы = 0 Тогда
		Книга = "shcntx_ru";
	ИначеЕсли ЯзыкПрограммы = 1 Тогда
		Книга = "shquery_ru";
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		Книга = "dcsui_ru";
	КонецЕсли;
	ФормаСправка = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма", , ФормаВладелец);
	ФормаСправка.ТекущаяСтраницаУстановлена = Истина;
	ФормаСправка.ОткрытьАдрес("//" + Книга);

КонецПроцедуры

// Открывает контекстную справку по текущему параметру метода.
//
// Параметры:
//  *ПутьКСлову - Строка, *"" - используется для получения дочерних слов относительно текущего контекста.
//
Процедура ОткрытьСправкуПоПараметру(ПутьКСлову = "", ОткрыватьСинтаксПомощник = Истина) Экспорт
	
	//Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
	//	Возврат;
	//КонецЕсли; 
	РазобратьТекущийКонтекст(,, Истина,,, Истина);
	Если ПутьКСлову = "" Тогда
		ПутьКСлову = мВызовМетода;
	КонецЕсли;
	// Если раскомментировать, то при вызове через мОткрытьСправкуПоПараметру не будет открываться окно 
	//Если Не ЗначениеЗаполнено(ПутьКСлову) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ОткрыватьСинтаксПомощник И ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ФормаСинтаксПомощникаДо = Неопределено;
		ФормаСинтаксПомощникаПосле = Неопределено;
		Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ФормаСинтаксПомощникаДо = ирКлиент.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма");
		КонецЕсли; 
		НайтиПоказатьСправкуПоСлову(ПутьКСлову,, ФормаСинтаксПомощникаПосле);
	КонецЕсли;
	ФормаПодсказкаПоПараметрам = ФормаВызовМетода();
	ФормаПодсказкаПоПараметрам.ПараметрПостояннаяСтруктураТипа = Неопределено;
	
	Если Не ФормаПодсказкаПоПараметрам.Открыта() И ЗначениеЗаполнено(мИмяМетодаВызова) Тогда
		ФормаПодсказкаПоПараметрам.ЗапомнитьПозициюКаретки();
	КонецЕсли; 
	Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		Если Ложь
			Или ОткрыватьСинтаксПомощник
			Или Не ФормаПодсказкаПоПараметрам.Открыта() 
		Тогда 
			ОткрытьПодсказкуПоВызовуМетодаПассивно(ФормаПодсказкаПоПараметрам);
		КонецЕсли; 
	Иначе
		Если Истина
			И Не мЭтоАвтоВызов
			И ФормаСинтаксПомощникаДо <> Неопределено
			И ФормаСинтаксПомощникаДо.Открыта() = ФормаСинтаксПомощникаПосле.Открыта()
		Тогда
			ФормаПодсказкаПоПараметрам.ОткрытьМодально();
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ОткрытьПодсказкуПоВызовуМетодаПассивно(Знач ФормаПодсказкаПоПараметрам, Знач Автообновление = Истина)
	
	ФормаПодсказкаПоПараметрам.Автообновление = Автообновление;
	ФормаПодсказкаПоПараметрам.Открыть();
	ФормаПодсказкаПоПараметрам.Обновить(); // Нужно для ускорения срабатывания установки позиции окна и для 8.2, т.к. там форма форкус получает после завершения ПриОткрытии и только после этого сработает установка позиции окна
	//ирКлиент.УстановитьФокусВводаФормеЛкс(); Не помогает восстановить мигание каретки
	
КонецПроцедуры

Функция УдалитьКомментарии(Текст) Экспорт 
	
	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		// Не проверено
		мРегВыражение.Pattern = "(?:(?://[^\n]*" + ")|(" + шСтрокаЗапроса + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "\n\s*\|(?:(?:"""")|[^""\n])*""?";
		мРегВыражение.Pattern = "//[^\n]*|" + "(" + "#[^\n]*" + ")|(" + шОднострочнаяСтрокаПрограммыСКавычки + ")|(" + шОднострочнаяСтрокаПрограммыСЧерты + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	КонецЕсли;
	Результат = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	Возврат Результат;
	
КонецФункции

// Меняет RegExp!
Функция ЭтоРусскийВариантТекстаЗапроса(Текст) Экспорт 
	
	ТекстБезКомментариев = СокрЛП(ЗалитьКомментарииИСтроковыеЛитералы(Текст));
	мРегВыражение.Pattern = "[А-ЯЁ]";
	ЭтоРусскийЯзык = мРегВыражение.Проверить(Лев(ТекстБезКомментариев, 1));
	Возврат ЭтоРусскийЯзык;

КонецФункции

// Добавляет/заменяет/удаляет оператор ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса - Строка;
//  *ИмяВременнойТаблицы - Строка - если пустое, то оператор удаляется.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ИзменитьОператорПоместитьЗапроса(ТекстЗапроса, ИмяВременнойТаблицы = "") Экспорт 

	ЭтоРусскийЯзык = ЭтоРусскийВариантТекстаЗапроса(ТекстЗапроса); // Меняет RegExp!
	мРегВыражение.Global = Истина;
	шСтрокаЗапроса = """(?:(?:"""")|[^""\n])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n])*)*(?:""|$)";
	ШаблонПОМЕСТИТЬИЗ = "(" + шСтрокаЗапроса + ")|(?:(" + шРазделитель + ")+(" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|FROM|ГДЕ|WHERE|СГРУППИРОВАТЬ|GROUP|УПОРЯДОЧИТЬ|ORDER|ИМЕЮЩИЕ|HAVING|ОБЪЕДИНИТЬ|UNION)" + шРазделитель + "+))|(.|\r|\n)";
	мРегВыражение.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		Если ЭтоРусскийЯзык Тогда
			ТерминПоместить = "ПОМЕСТИТЬ";
		Иначе
			ТерминПоместить = "INTO";
		КонецЕсли; 
		Результат = мРегВыражение.НайтиВхождения(ТекстЗапроса);
		Текст = "";
		ПредложениеДобавлено = Ложь;
		Для Каждого Match Из Результат Цикл
			Если Ложь
				Или ПредложениеДобавлено
				Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(0))
				Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(4))
			Тогда
				Текст = Текст + Match.Value;
			Иначе
				Текст = Текст + "
				|" + ТерминПоместить + "
				|	" + ИмяВременнойТаблицы;
				Если Match.SubMatches(3) <> 0 Тогда // Видимо здесь ошибка
					Текст = Текст + Символы.ПС + Match.SubMatches(3);
				КонецЕсли;
				ПредложениеДобавлено = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не ПредложениеДобавлено Тогда
			Текст = Текст + "
			|" + ТерминПоместить + "
			|	" + ИмяВременнойТаблицы;
		КонецЕсли;
	Иначе
		Текст = мРегВыражение.Заменить(ТекстЗапроса, "$1$2$4$5");
	КонецЕсли; 
	Возврат Текст;

КонецФункции

Функция ШаблонЗапросаДопускаетВстройкуВРодительскийЗапрос(Текст) Экспорт 
	
	мРегВыражение.Global = Ложь;
	мРегВыражение.Pattern = шРазделитель + "*(?:ВЫБРАТЬ|SELECT)(?:" + шРазделитель + "+)\*(?:" + шРазделитель + "+)(?:ИЗ|FROM)(?:" + шРазделитель + "+(?:КАК|AS)?(?:" + шРазделитель + "+" + шИмя + "))" + шРазделитель + "*";
	Результат = мРегВыражение.Проверить(Текст);
	Возврат Результат;

КонецФункции

Функция ПолучитьКомментарийИзТокеновЯзыкаЗапросов(Токен1, Токен2 = Неопределено, выхИмяЗапросаИзКомментария = "", выхИмяЧастиОбъединенияИзКомментария = "") Экспорт 
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено И Токен1.Name = "Comment" Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено И Токен2.Name = "Comment" Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария, выхИмяЧастиОбъединенияИзКомментария);
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

Процедура РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария = Неопределено, выхИмяЧастиОбъединенияИзКомментария = Неопределено, выхПорядокОтладки = Неопределено) Экспорт 
	
	ЧистыйКомментарий = "";
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстКомментария);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
		Если ПустаяСтрока(СтрокаТекста) Тогда
			Продолжить;
		КонецЕсли; 
		//Если Счетчик = 1 Тогда 
			Если Найти(СтрокаТекста, мПараметрыДиалектаSQL.СтрочныйКомментарий) = 1 Тогда 
				СтрокаТекста = Сред(СтрокаТекста, СтрДлина(мПараметрыДиалектаSQL.СтрочныйКомментарий) + 1);
			КонецЕсли; 
			Если Найти(СтрокаТекста, мМаркерСлужебногоКомментария) = 1 Тогда 
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета) = 1 Тогда 
				ИмяЗапросаИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЗапросаПакета, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЗапросаИзКомментария) Тогда
					выхИмяЗапросаИзКомментария = ИмяЗапросаИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			Если Найти(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения) = 1 Тогда 
				ИмяЧастиОбъединенияИзКомментария = ирОбщий.ТекстМеждуМаркерамиЛкс(СтрокаТекста, мПлатформа.мМаркерИмениЧастиОбъединения, " ");
				Если ирОбщий.ЛиИмяПеременнойЛкс(ИмяЧастиОбъединенияИзКомментария) Тогда
					выхИмяЧастиОбъединенияИзКомментария = ИмяЧастиОбъединенияИзКомментария;
				КонецЕсли; 
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
			СтрокаТекста = СокрЛ(СтрокаТекста);
			Если ирОбщий.СтрНачинаетсяСЛкс(СтрокаТекста, мМаркерПорядкаОтладки) = 1 Тогда 
				выхПорядокОтладки = Сред(СтрокаТекста, СтрДлина(мМаркерПорядкаОтладки) + 1);
				// Пропускаем служебные комментарии
				Продолжить;
			КонецЕсли; 
		//КонецЕсли; 
		Если ЧистыйКомментарий <> "" Тогда
			ЧистыйКомментарий = ЧистыйКомментарий + Символы.ПС;
		КонецЕсли; 
		ЧистыйКомментарий = ЧистыйКомментарий + СтрокаТекста;
	КонецЦикла;
	ТекстКомментария = ЧистыйКомментарий;

КонецПроцедуры

// Разбирает текущий контекст по составляющим.
//
// Параметры:
//  ЛиСправаОтРавенства	 - 	 - 
//  выхЕстьТочкаСправа	 - 	 - 
//  КакВызовМетода		 - Булево, Неопределено - если равен Неопределено, то трактуется как Истина в случае если внутри строкового литерала
//  НомерСтроки			 - 	 - 
//  НомерКолонки		 - 	 - 
//
Процедура РазобратьТекущийКонтекст(Знач ЛиСправаОтРавенства = Ложь, выхЕстьТочкаСправа = Ложь, Знач КакВызовМетода = Неопределено, Знач НомерСтроки = 0, Знач НомерКолонки = 0,
	Знач ПереходитьВоВложенныйКонтекст = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		СлужебноеПолеТекстаДолгое = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	мОригинальныйТекст = ПолеТекста.ПолучитьТекст();
	ОригинальныйТекстИзменен = мСтарыйОригинальныйТекст <> мОригинальныйТекст;
	Если Не мРазбиратьКонтекст И Не ОригинальныйТекстИзменен Тогда 
		Возврат;
	КонецЕсли;
	мПлатформа.ИнициацияОписанияМетодовИСвойств();
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		ПолеТекста.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка);
	Иначе
		мНачальнаяСтрока = НомерСтроки;
		мКонечнаяСтрока = НомерСтроки;
	    мНачальнаяКолонка = НомерКолонки;
		мКонечнаяКолонка = НомерКолонки;
	КонецЕсли; 
	ПрочитатьНачалоИКонецТекущейСтроки();
	мПозицияТекстаДляПоискаОпределения = 0;
	мПредшествующийТекст = "";
	мТекстДляПоискаОпределения = "";  
	мТекстБлока = "";
	мТекстБезТекстовыхЛитералов = "";
	мМетодМодуля = Неопределено;
	мНомерПервойСтрокиОпределенияМетода = 1;
	мНомерПервойСтрокиТелаМетода = 1;
	мНомерПоследнейСтрокиТелаМетода = Неопределено;
	мПозицияВТексте = 1;
	ТекстПакетаЗапросов = мОригинальныйТекст;
	мЯзыкПрограммы = ЯзыкПрограммы;
	НачальнаяПозицияВложенногоТекста = 0;
	НомерПервойСтрокиБлока = 1;
	Если ОригинальныйТекстИзменен Тогда
		СлужебноеПолеТекстаДолгое.УстановитьТекст(мОригинальныйТекст);
	КонецЕсли;
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(1, 1, мКонечнаяСтрока, мКонечнаяКолонка);
	мПозицияВТексте = СтрДлина(СлужебноеПолеТекстаДолгое.ВыделенныйТекст) + 1; // Долго 2мс TODO написать свой расчет позиции
	Если Истина
		И ПереходитьВоВложенныйКонтекст 
		И ирОбщий.ЛиВнутриНепервойСтрокиТекстовогоЛитералаЛкс(мТекущаяСтрокаНачало) // Первые строки литералов игнорируем для ускорения
	Тогда
		ТекстЛитерала = ВыделитьТекстовыйЛитерал(СлужебноеПолеТекстаДолгое, НачальнаяПозицияВложенногоТекста,, Ложь);
		Если ирОбщий.ЛиТекстЯзыкаЗапросовЛкс(ТекстЛитерала) Тогда
			ТекстПакетаЗапросов = ТекстЛитерала;
			мЯзыкПрограммы = 1;
			мЭтоСтроковыйЛитерал = Ложь;
			СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(НомерПервойСтрокиБлока, 0, 0, 0);
		КонецЕсли;
	КонецЕсли;
	РазобратьКонтекстСтроки(ЛиСправаОтРавенства, выхЕстьТочкаСправа, КакВызовМетода);
	ЧислоСтрокВБлоке = 0; 
	Если ЯзыкПрограммы = 0 И ОригинальныйТекстИзменен Тогда 
		ОбновитьМодульМетаданных(мОригинальныйТекст); 
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		ЗагрузитьМетодМодуляПоПозиции(мПозицияВТексте); // устанавливает мМетодМодуля
		Если мМетодМодуля <> Неопределено Тогда 
			мТекстБлока = мМетодМодуля.Тело;
			мПозицияТекстаДляПоискаОпределения = мМетодМодуля.ПозицияТела;
		Иначе 
			мТекстБлока = мМодульМетаданных.Программа;
			мПозицияТекстаДляПоискаОпределения = мМодульМетаданных.ПозицияПрограммы - 1;
		КонецЕсли; 
		ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока);
		мНомерПервойСтрокиТелаМетода = СтрЧислоСтрок(Лев(мОригинальныйТекст, мПозицияТекстаДляПоискаОпределения) + "й"); 
		мНомерПоследнейСтрокиТелаМетода = мНомерПервойСтрокиТелаМетода + ЧислоСтрокВБлоке - 1;
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - мНомерПервойСтрокиТелаМетода + 1;
	Иначе
		ПозицииЗапросовПакета = Новый Массив;
		ЗапросыПакета = ирОбщий.РазбитьГрубоТекстПакетногоЗапросаНаЗапросыЛкс(ТекстПакетаЗапросов, мПозицияВТексте, ПозицииЗапросовПакета);
		#Если Сервер И Не Сервер Тогда
			ЗапросыПакета = Новый Массив;
		#КонецЕсли
		Для ИндексЗапроса = 0 По ЗапросыПакета.ВГраница() Цикл
			мТекстБлока = ЗапросыПакета[ИндексЗапроса];
			мПозицияТекстаДляПоискаОпределения = ПозицииЗапросовПакета[ИндексЗапроса];
			ЧислоСтрокВБлоке = ирОбщий.СтрЧислоСтрокЛкс(мТекстБлока) - 1;
			НомерПервойСтрокиБлока = НомерПервойСтрокиБлока + ЧислоСтрокВБлоке;
			Если НомерПервойСтрокиБлока >= мНачальнаяСтрока Тогда
				Прервать;
			КонецЕсли; 
		КонецЦикла; 
		НомерТекущейСтрокиВБлоке = мКонечнаяСтрока - (НомерПервойСтрокиБлока - ЧислоСтрокВБлоке) +  1;
		мПозицияТекстаДляПоискаОпределения = НачальнаяПозицияВложенногоТекста + мПозицияТекстаДляПоискаОпределения;
	КонецЕсли; 
	мТекстДляПоискаОпределения = мТекстБлока;
	Если НомерТекущейСтрокиВБлоке > 1 Тогда
		мПолеТекстаВременное.УстановитьТекст(мТекстБлока);                              
		мПолеТекстаВременное.УстановитьГраницыВыделения(1, 1, НомерТекущейСтрокиВБлоке - 1, 333);
		мПредшествующийТекст = мПолеТекстаВременное.ВыделенныйТекст;
	Иначе 
		мПредшествующийТекст = "";
	КонецЕсли;
	Если мЯзыкПрограммы = 0 Тогда
		мТекстДляПоискаОпределения = мПредшествующийТекст;
	КонецЕсли;

	мПредшествующийТекст = мПредшествующийТекст + Лев(мТекущаяСтрокаНачало, СтрДлина(мТекущаяСтрокаНачало) - СтрДлина(мНачалоКонтекста));
	//мПозицияВТексте = мПозицияТекстаДляПоискаОпределения + СтрДлина(мПредшествующийТекст + мНачалоКонтекста);
	мПредшествующийТекст = Прав(мПредшествующийТекст, 500); // Обрезка для ускорения
	мСтарыйОригинальныйТекст = мОригинальныйТекст;
	ПродолжитьОбработкуКоманды();

КонецПроцедуры

Процедура ЗагрузитьМетодМодуляПоПозиции(Знач ПозицияВТексте) Экспорт 
	
	мМетодМодуля = Неопределено; 
	Если мМодульМетаданных <> Неопределено Тогда
		Для Каждого СтрокаМетода Из мМодульМетаданных.Методы Цикл
			Если Истина
				И СтрокаМетода.ПозицияСОписанием <> Неопределено
				И СтрокаМетода.ПозицияСОписанием <= ПозицияВТексте 
				И СтрокаМетода.ПозицияСОписанием + СтрокаМетода.ДлинаСОписанием >= ПозицияВТексте
			Тогда
				мМетодМодуля = СтрокаМетода;
				Прервать;
			КонецЕсли; 
		КонецЦикла;         
	КонецЕсли;
	ЕстьСервер = Ложь;
	ЕстьКлиент = Ложь;
	Если мМетодМодуля <> Неопределено Тогда
		ЕстьСервер = ирОбщий.СтрНайтиЛкс(СтрокаМетода.Аннотация, "НаСервере",,,, Ложь) > 0;
		ЕстьКлиент = ирОбщий.СтрНайтиЛкс(СтрокаМетода.Аннотация, "НаКлиенте",,,, Ложь) > 0;
		ЕстьБезКонтекста = ирОбщий.СтрНайтиЛкс(СтрокаМетода.Аннотация, "БезКонтекста",,,, Ложь) > 0;
	КонецЕсли;
	Если ЕстьСервер Или ЕстьКлиент Тогда
		мФлагиКомпиляции.Вставить("Сервер", ЕстьСервер);  
		мФлагиКомпиляции.Вставить("КлиентУправляемоеПриложение", ЕстьКлиент);  
		мФлагиКомпиляции.Вставить("КлиентОбычноеПриложение", ЕстьКлиент);  
		мФлагиКомпиляции.Вставить("БезКонтекста", ЕстьБезКонтекста);  
	Иначе
		мФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мМодульМетаданных.ФлагиКомпиляции);  
	КонецЕсли;

КонецПроцедуры 

// Сначала нужно разобрать контекст
Функция ТелоАктивногоМетода(выхНомераПервойСтрокиТела = 1) Экспорт 
	выхНомераПервойСтрокиТела = мНомерПервойСтрокиТелаМетода;
	Если мМетодМодуля <> Неопределено Тогда
		Возврат мМетодМодуля.Тело;
	ИначеЕсли мМодульМетаданных <> Неопределено Тогда 
		Возврат мМодульМетаданных.Программа;
	Иначе
		Возврат мОригинальныйТекст;
	КонецЕсли; 
КонецФункции  

// Сначала нужно разобрать контекст
Функция ОпределениеАктивногоМетодаСОписанием(СмещениеНомераМетода = 0) Экспорт 
	Если мМетодМодуля <> Неопределено Тогда
		Если СмещениеНомераМетода = 0 Тогда
			Результат = ТекстМетодаСОписанием(мМетодМодуля);
		Иначе
			СледующийМетодМодуля = мМодульМетаданных.Методы[мМодульМетаданных.Методы.Индекс(мМетодМодуля) + СмещениеНомераМетода];
			Результат = ТекстМетодаСОписанием(СледующийМетодМодуля);
		КонецЕсли;
	Иначе
		Результат = мОригинальныйТекст;
	КонецЕсли; 
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    МетодМодуля - ?, ? - 
// Возвращаемое значение:
//    Строка - 
Функция ТекстМетодаСОписанием(МетодМодуля) Экспорт
	Результат = Сред(мОригинальныйТекст, МетодМодуля.ПозицияСОписанием, МетодМодуля.ДлинаСОписанием);
	Возврат Результат;
КонецФункции   

// Сначала нужно разобрать контекст
Функция ОпределениеАктивногоМетодаБезОписания() Экспорт 
	Если мМетодМодуля <> Неопределено Тогда
		Результат = Сред(мОригинальныйТекст, мМетодМодуля.ПозицияОпределения, мМетодМодуля.ДлинаОпределения);
		Результат = ирОбщий.ЗаменитьРегВыражениеЛкс(Результат, "^\n*", "", Ложь);
		Возврат Результат;
	Иначе
		Возврат мОригинальныйТекст;
	КонецЕсли; 
КонецФункции

// Выполняет программу на внутреннем языке.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Булево - безошибочность выполнения кода.
//
Функция ВыполнитьПрограммныйКод(Знач ЛиСинтаксическийКонтроль = Ложь, выхИнформацияОбОшибке = Неопределено, Знач ТекстДляВыполнения = "") Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Не ЗначениеЗаполнено(ТекстДляВыполнения) Тогда
		ТекстДляВыполнения = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Попытка
		мПлатформа.ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения, ТекстДляВыполнения, ЛиСинтаксическийКонтроль);
		Возврат Истина;
	Исключение
		выхИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Не ЛиСинтаксическийКонтроль Тогда
			// Баг платформы. Зависает приложение, если пытаемся установить выделение на невидимой странице.
			ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста,,,,, выхИнформацияОбОшибке); 
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыWQL() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////ЭтотОбъект.мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Конфигурация = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	wbemFlagUseAmendedQualifiers = 131072; //&H20000
	КоллекцияКлассов = Конфигурация.SubclassesOf(, wbemFlagUseAmendedQualifiers);
	ВидимостьКолонкиСхема = Ложь;
	ВидимостьКолонкиОписание = Ложь;
	Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(КоллекцияКлассов.Count, "Получаем метаданные");
	Для Каждого ЭлементКоллекции Из КоллекцияКлассов Цикл
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Имя = ЭлементКоллекции.Path_.Class;
		//СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
		//СтрокаТаблицы.Тип = СтрокаТЗ.TABLE_TYPE;
		СтрокаТаблицы.Описание = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(ЭлементКоллекции);
		ПолноИмя = СтрокаТаблицы.Имя;
		Если ЗначениеЗаполнено(СтрокаТаблицы.Схема) Тогда
			ПолноИмя = СтрокаТаблицы.Схема + "." + ПолноИмя;
		КонецЕсли;
		СтрокаТаблицы.ПолноеИмя = ПолноИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		ВидимостьКолонкиСхема = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Схема);
		ВидимостьКолонкиОписание = ВидимостьКолонкиСхема Или ЗначениеЗаполнено(СтрокаТаблицы.Описание);
	КонецЦикла;
	ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	Возврат Неопределено;

КонецФункции

Функция ЗаполнитьДоступныеТаблицыADO() Экспорт

	////Если мДоступныеТаблицыПолучены Тогда
	////	Возврат Неопределено;
	////КонецЕсли; 
	////мДоступныеТаблицыПолучены = Истина;
	//ДоступныеТаблицы.Очистить();
	ОчиститьДоступныеНеВременныеТаблицы();
	Если Ложь
		Или Конфигурация = Неопределено 
		Или Конфигурация.State = 0
	Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Состояние("Подготовка метаданных...");
	Если Не мРасширенноеПолучениеМетаданныхADO Тогда
		Фильтры = Новый Массив();
		Фильтры.Добавить(); // TABLE_CATALOG
		Фильтры.Добавить(); // TABLE_SCHEMA
		Фильтры.Добавить(); // TABLE_NAME
		Если Не мРасширенноеПолучениеМетаданныхADO Тогда
			Фильтры.Добавить("TABLE"); // TABLE_TYPE
		КонецЕсли; 
		Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20, Фильтры); //adSchemaTables // Может выполняться долго (oracle)
	Иначе
		ОписаниеТаблицRecordSet = Конфигурация.OpenSchema(20); //adSchemaTables // Может выполняться долго (oracle)
	КонецЕсли; 
	ОписаниеТаблицТЗ = ирОбщий.РезультатЗапросаADOВТаблицуЗначенийОбщийЛкс(ОписаниеТаблицRecordSet);
	Если ирКэш.РежимОтладкиЛкс() Тогда 
		// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл
			ТипТаблицы = СтрокаТЗ.TABLE_TYPE;
			Если Истина
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")
				И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")
			Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТаблицы = ДоступныеТаблицы.Добавить();
			СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;
			СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;
			СтрокаТаблицы.Тип = ТипТаблицы;
			СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;
			ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);
			СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;
			СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);
		КонецЦикла;
	Иначе
		// Однострочный код использован для ускорения. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		Для Каждого СтрокаТЗ Из ОписаниеТаблицТЗ Цикл  		ТипТаблицы = СтрокаТЗ.TABLE_TYPE;  		Если Истина  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "table")  			И Не ирОбщий.СтрокиРавныЛкс(ТипТаблицы, "view")  		Тогда  			Продолжить;  		КонецЕсли;  		СтрокаТаблицы = ДоступныеТаблицы.Добавить();  		СтрокаТаблицы.Имя = СтрокаТЗ.TABLE_NAME;  		СтрокаТаблицы.Схема = СтрокаТЗ.TABLE_SCHEMA;  		СтрокаТаблицы.Тип = ТипТаблицы;  		СтрокаТаблицы.Описание = СтрокаТЗ.DESCRIPTION;  		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаТаблицы.Имя, СтрокаТаблицы.Схема);  		СтрокаТаблицы.ПолноеИмя = ПолноеИмяДоступнойТаблицы;  		СтрокаТаблицы.НПолноеИмя = НРег(ПолноеИмяДоступнойТаблицы);  	КонецЦикла;  
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьИмяТаблицыADO(Знач ИмяИсходное)  
	
	Если Лев(ИмяИсходное, 1) <> "[" Тогда
		ИмяИсходное = "[" + ИмяИсходное + "]";  
	КонецЕсли;  
	Возврат ИмяИсходное;
	
 КонецФункции
 
Функция НайтиДобавитьДоступнуюВременнуюТаблицу(Знач ЛюбоеИмяТаблицы, ПородившийЗапрос = Неопределено, выхБылиДобавления = Ложь, ИсточникДанных1С = Неопределено) Экспорт
	
	КраткоеИмяТаблицы = КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы);
	ПолноеИмяТаблицы = ПолноеИмяДоступнойТаблицы(ЛюбоеИмяТаблицы);
	ПолноеИмяТаблицы = ПолноеИмяВременнойТаблицы(ПолноеИмяТаблицы, ИсточникДанных1С);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
	Если СтрокаДоступнойТаблицы = Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаДоступнойТаблицы.Имя = КраткоеИмяТаблицы;
		СтрокаДоступнойТаблицы.ПолноеИмя = ПолноеИмяТаблицы;
		СтрокаДоступнойТаблицы.Схема = ИсточникДанных1С;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступнойТаблицы, "ПолноеИмя");
		СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица";
		СтрокаДоступнойТаблицы.ЕстьДоступ = Истина;
		выхБылиДобавления = Истина;
	КонецЕсли;
	Если ПородившийЗапрос <> Неопределено Тогда
		Для Каждого СтараяСтрока Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("ПородившийЗапрос", ПородившийЗапрос)) Цикл
			Если СтараяСтрока = СтрокаДоступнойТаблицы Тогда
				Продолжить;
			КонецЕсли; 
			ДоступныеТаблицы.Удалить(СтараяСтрока);
		КонецЦикла;
		СтрокаДоступнойТаблицы.ПородившийЗапрос = ПородившийЗапрос;
	КонецЕсли; 
	Возврат СтрокаДоступнойТаблицы;
	
КонецФункции

Функция ПолноеИмяДоступнойТаблицы(Знач ИмяДоступнойТаблицы, ИмяСхемы = Неопределено) Экспорт 
	
	Если Истина
		И Найти(ИмяДоступнойТаблицы, ".") = 0 
		И мПараметрыДиалектаSQL.Диалект <> "1С" 
		И мПараметрыДиалектаSQL.Диалект <> "WQL"
	Тогда
		ИмяДоступнойТаблицы = ПолучитьИмяТаблицыADO(ИмяДоступнойТаблицы); 
		Если ИмяСхемы = Неопределено И ДоступныеТаблицы.Количество() > 0 Тогда
			ИмяСхемы = ДоступныеТаблицы[0].Схема;
		КонецЕсли;
		Если ЗначениеЗаполнено(ИмяСхемы) Тогда
			ИмяДоступнойТаблицы = ИмяСхемы + "." + ИмяДоступнойТаблицы;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ИмяДоступнойТаблицы;

КонецФункции

Функция ДоступнаяТаблицаПоИмениВыбранной(Знач ПолноеИмя) Экспорт 
	
	ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ПолноеИмя);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	Возврат СтрокаДоступнойТаблицы;

КонецФункции

Функция ЭтоПараметрПериодичность1С(Знач СтрокаПараметраТаблицы, Знач ДиалектSQL = "") Экспорт 

	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "периодичность") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;

КонецФункции

Функция ПоляДоступнойТаблицы(Знач СтрокаДоступнойТаблицы, Знач ПараметрыТаблицы = Неопределено, Знач ДиалектSQL = "", Знач ПородившийЗапрос = Неопределено) Экспорт 
	
	Если ДиалектSQL = "" Тогда
		ДиалектSQL = мДиалектSQL;
	КонецЕсли;
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ИспользоватьКэширование = Истина
		И СтрокаДоступнойТаблицы.Тип <> "ВременнаяТаблица"
		И СтрокаДоступнойТаблицы.Тип <> "Параметр"
		И ТипЗнч(Конфигурация) <> Тип("ОбъектМетаданныхКонфигурация");
	Если ИспользоватьКэширование Тогда 
		ТаблицаПолей = мДоступныеПоляТаблиц[ПолноеИмяТаблицы];
		Если ТаблицаПолей <> Неопределено Тогда
			Возврат ТаблицаПолей;
		КонецЕсли; 
	КонецЕсли; 
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	ТаблицаПолей.Колонки.Добавить("Метаданные");
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			//КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
			КолонкиРезультата = ПородившийЗапрос.ПоляОбъединения;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE 1=0";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Выгрузить();
					КолонкиРезультата = ирОбщий.ТаблицаСКолонкамиБезТипаNullЛкс(КолонкиРезультата, Ложь);
					КолонкиРезультата = КолонкиРезультата.Колонки;
				КонецЕсли;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение  
					ОписаниеОшибки = ОписаниеОшибки();
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирОбщий.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			Если ВыбранноеПоле.Имя = "" Тогда
				ВызватьИсключение "Не определены имена полей таблицы """ + ПолноеИмяТаблицы + """";
			КонецЕсли; 
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли СтрокаДоступнойТаблицы.Тип = "Параметр" Тогда
		КолонкиРезультата = Новый Массив();
		ТаблицаПараметр = Неопределено;
		Если КонтекстВыполнения.Параметры.Свойство(СтрокаДоступнойТаблицы.Имя, ТаблицаПараметр) Тогда 
			КолонкиРезультата = ТаблицаПараметр.Колонки;
		КонецЕсли;
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		ИндексПараметраПериодичность = Неопределено;
		ОпределениеПараметраПериодичность = "";
		Если ПараметрыТаблицы <> Неопределено Тогда
			Для ИндексПараметра = 0 По ПараметрыТаблицы.Количество() - 1 Цикл
				СтрокаПараметраТаблицы = ПараметрыТаблицы[ИндексПараметра];
				Если ЭтоПараметрПериодичность1С(СтрокаПараметраТаблицы) Тогда
					ИндексПараметраПериодичность = ИндексПараметра;
					ОпределениеПараметраПериодичность = СтрокаПараметраТаблицы.Определение;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		ПоляТаблицыБД = ирОбщий.ПоляТаблицыМДЛкс(ПолноеИмяТаблицы,, ИндексПараметраПериодичность, ОпределениеПараметраПериодичность, Ложь);
		#Если Сервер И Не Сервер Тогда
		    ПоляТаблицыБД = НайтиПоСсылкам().Колонки;
		#КонецЕсли
		Если ПоляТаблицыБД <> Неопределено Тогда
			_РежимОтладки = Ложь;
			Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.ПрЛкс(_РежимОтладки, 1, 1)
				// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл
					//Если ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
					//	Продолжить;
					//КонецЕсли;
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ПолеТаблицыБД.Имя;
					СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;
					СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;
				КонецЦикла;
			Иначе
				// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
				Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл        				СтрокаПоля = ТаблицаПолей.Добавить();  				СтрокаПоля.Имя = ПолеТаблицыБД.Имя;  				СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;  				СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;  			КонецЦикла;  
			КонецЕсли;
			ирОбщий.ДополнитьТаблицуПолейТаблицыБДВиртуальнымиПолямиЛкс(ТаблицаПолей, СтрокаДоступнойТаблицы, Истина);
		КонецЕсли;
	Иначе
		СтрокаДоступнойТаблицы = ДоступнаяТаблицаПоИмениВыбранной(ПолноеИмяТаблицы);
		Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers);
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирОбщий.ИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet);
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value;
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Если ИспользоватьКэширование Тогда
		мДоступныеПоляТаблиц[ПолноеИмяТаблицы] = ТаблицаПолей;
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Функция ПолноеИмяВременнойТаблицы(Знач КраткоеИмяТаблицы, Знач ИсточникДанных1С = Неопределено) Экспорт 
	
	Результат = КраткоеИмяТаблицы;
	Если Истина
		И Найти(КраткоеИмяТаблицы, ".") = 0
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И ЗначениеЗаполнено(ИсточникДанных1С) 
		И ИсточникДанных1С <> "<Локальный>"
	Тогда
		Результат = "ВнешнийИсточникДанных." + ИсточникДанных1С + ".ВременнаяТаблица." + Результат;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция КраткоеИмяВременнойТаблицы(ЛюбоеИмяТаблицы) Экспорт 
	Результат = ЛюбоеИмяТаблицы;
	Если Истина
		И мПараметрыДиалектаSQL.Диалект = "1С"
		И Найти(Результат, ".") > 0
	Тогда
		Результат = ирОбщий.ПоследнийФрагментЛкс(Результат);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОчиститьДоступныеВременныеТаблицы(ТаблицаДоступныхТаблиц = Неопределено) Экспорт

	Если ТаблицаДоступныхТаблиц = Неопределено Тогда
		ТаблицаДоступныхТаблиц = ДоступныеТаблицы;
	КонецЕсли;
	ирОбщий.УдалитьСтрокиТаблицыИлиДереваПоЗначениюВКолонкеЛкс(ТаблицаДоступныхТаблиц, "Тип", "ВременнаяТаблица");
	
КонецПроцедуры

Процедура ОчиститьДоступныеНеВременныеТаблицы() Экспорт

	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	
КонецПроцедуры

Функция ПрефиксПараметра() Экспорт
	
	Возврат мПараметрыДиалектаSQL.ПрефиксПараметра;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
//
// Параметры:
//  Нет.
//
Функция ВызватьКонструкторЗапросов(Знач ИспользуемСобственныйКонструктор = Неопределено) Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть конструктор без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Не ирКэш.ЛиПлатформаWindowsЛкс() Тогда
		ИспользуемСобственныйКонструктор = Ложь
	КонецЕсли; 
	ПредпочитаюСобственныйКонструкторЗапроса = Ложь;
	Если ИспользуемСобственныйКонструктор = Неопределено Тогда
		ПредпочитаюСобственныйКонструкторЗапроса = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса");
		Если ПредпочитаюСобственныйКонструкторЗапроса = Неопределено Тогда
			Ответ = Вопрос("Подсистема имеет собственный конструктор запроса. Приоритет его использования задается в настройках компоненты ""Контекстная подсказка"".
			|Хотите установить приоритет его использования?", РежимДиалогаВопрос.ДаНет);
			ПредпочитаюСобственныйКонструкторЗапроса = Ответ = КодВозвратаДиалога.Да;
			ирОбщий.СохранитьЗначениеЛкс(ИмяКласса + ".ПредпочитаюСобственныйКонструкторЗапроса", ПредпочитаюСобственныйКонструкторЗапроса);
		КонецЕсли; 
	КонецЕсли; 
	ИспользуемСобственныйКонструктор = Ложь
		Или ИспользуемСобственныйКонструктор = Истина
		Или мДиалектSQL <> "1С"
		Или ПредпочитаюСобственныйКонструкторЗапроса;
	Если ИспользуемСобственныйКонструктор Тогда
		КонструкторЗапроса = ПолучитьФорму("КонструкторЗапроса");
		КонструкторЗапроса.Конфигурация = Конфигурация;
	Иначе
		КонструкторЗапроса = Новый КонструкторЗапроса;
	КонецЕсли; 
	//ОбрамитьСобранныйТекстСкобками = Ложь;
	Если ЯзыкПрограммы = 1 Тогда
		Если СтрДлина(СокрЛП(ВыделенныйТекст())) < 6 И Не ЭтоЧастичныйЗапрос Тогда 
			ТекстЗапроса = ПолеТекста.ПолучитьТекст();
			НачальнаяСтрокаЗапроса = 0; 
			НачальнаяКолонкаЗапроса = 0;
		Иначе
			ТекстЗапроса = ВыделенныйТекст();
			//Если Не ЗначениеЗаполнено(ТекстЗапроса) И ЭтоЧастичныйЗапрос Тогда
			//	ТекстЗапроса = "ВЫБРАТЬ 1";
			//	ОбрамитьСобранныйТекстСкобками = Истина;
			//КонецЕсли; 
			НачальнаяСтрокаЗапроса = мНачальнаяСтрока - 1; 
			НачальнаяКолонкаЗапроса = мНачальнаяКолонка - 1;
		КонецЕсли;
		КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
		//КонструкторЗапроса.АвтодобавлениеПредставлений = Истина;
		МассивВременныхТаблиц = Новый Массив;
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			Если Истина
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
				И Не ИспользуемСобственныйКонструктор
			Тогда
				СтарыйТекстЗапроса = ТекстЗапроса;
				ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Попытка
					ТекстЗапроса = мПлатформа.ЗамаскироватьВременныеТаблицы(КонтекстВыполнения, ТекстЗапроса, МассивВременныхТаблиц);
				Исключение
					ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
					ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, , , Истина,, ИнформацияОбОшибке());
					Возврат Ложь;
				КонецПопытки;
				НоваяИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстЗапроса);
				Если Истина
					И НоваяИнформацияОбОшибке <> Неопределено
					И ИнформацияОбОшибке = Неопределено
					И Найти(ирОбщий.ПодробноеПредставлениеОшибкиЛкс(НоваяИнформацияОбОшибке), "Ожидается псевдоним запроса") > 0 
				Тогда
					// Сюда попадаем, когда у временной таблицы нет псевдонима
					ирОбщий.СообщитьСУчетомМодальностиЛкс("В запросе присутствуют временные таблицы без псевдонимов. "
						+ "Для максимальной функциональности рекомендуется задать каждой временной таблице псевдоним",, СтатусСообщения.Внимание);
					МассивВременныхТаблиц = Новый Массив;
					ТекстЗапроса = СтарыйТекстЗапроса;
                КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	Иначе
		// Мультиметка77248851
		РазобратьТекущийКонтекст();
		ТекстПоля = ПолеТекста.ПолучитьТекст();
		мРегВыражение.Global = Истина;
		мРегВыражение.MultiLine = Ложь;
		мРегВыражение.Pattern = шСтрокаПрограммы;
		Результат = мРегВыражение.НайтиВхождения(ТекстПоля);
		Успех = Ложь;
		Для Каждого Вхождение Из Результат Цикл
			ПозицияВхождения = Вхождение.FirstIndex;
			Если Истина
				И (ПозицияВхождения + 1) <= мПозицияВТексте 
				И (ПозицияВхождения + Вхождение.Length) >= мПозицияВТексте 
			Тогда
				ПолеТекста.УстановитьГраницыВыделения(ПозицияВхождения + 1, ПозицияВхождения + 1 + Вхождение.Length);
				Успех = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		ПолеТекста.ПолучитьГраницыВыделения(НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, , );
		НачальнаяСтрокаЗапроса = НачальнаяСтрокаЗапроса - 1; 
		НачальнаяКолонкаЗапроса = НачальнаяСтрокаЗапроса - 1;
		Если Успех Тогда
			ТекстЗапроса = ВыделенныйТекст();
			Если Прав(ТекстЗапроса, 1) <> """" Тогда
				ТекстЗапроса = ТекстЗапроса + """";
			КонецЕсли; 
			ТекстЗапроса = Вычислить(ТекстЗапроса);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "|", "");
		Иначе
			ТекстЗапроса = "";
		КонецЕсли;
	КонецЕсли;
	Если ИспользуемСобственныйКонструктор Тогда
		Парсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
		Если Парсер = Неопределено Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Компонента анализа текста запроса не подключена");
			Возврат Ложь;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Если ИспользуемСобственныйКонструктор Тогда
			РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса, КонструкторЗапроса,, мДиалектSQL,, НачальнаяСтрокаЗапроса);
			Если Не РезультатРазбора Тогда
				Возврат Ложь;
			КонецЕсли; 
		Иначе
			СтруктуруРезультатаПакетногоЗапроса = мПлатформа.СтруктураРезультатаПакетногоЗапроса(ТекстЗапроса);
			Если СтруктуруРезультатаПакетногоЗапроса.Количество() > 0 Тогда
				Ответ = Вопрос("В комментариях обнаружены имена запросов. Стандартный конструктор запросов их удалит. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
				Если Ответ <> КодВозвратаДиалога.ОК Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли; 
			Попытка
				КонструкторЗапроса.Текст = ТекстЗапроса;
			Исключение
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
				ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, НачальнаяСтрокаЗапроса, НачальнаяКолонкаЗапроса, Истина,, ИнформацияОбОшибке());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли; 
	Иначе
		Если ИспользуемСобственныйКонструктор Тогда
			//КонструкторЗапроса.УстановитьДиалектSQL(мДиалектSQL);
			КонструкторЗапроса.УстановитьДанные();
		КонецЕсли; 
	КонецЕсли;
	РезультатФормы = КонструкторЗапроса.ОткрытьМодально();
	Если РезультатФормы = Истина Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = КонструкторЗапроса.Текст;
			Если Истина
				И ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация")
				И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
			Тогда
				//RegExp.Global = Истина;
				//RegExp.MultiLine = Ложь;
				//RegExp.IgnoreCase = Истина;
				//// Допустим 1 уровень скобок.
				//шОдинарныеСкобки = "\([^\)\(]*?\)";
				//шИмяВременнойТаблицы = "";
				//Для Каждого ПодмененнаяВременнаяТаблица Из МассивВременныхТаблиц Цикл
				//	шИмяВременнойТаблицы = шИмяВременнойТаблицы + "|" + ПодмененнаяВременнаяТаблица;
				//КонецЦикла;
				//шИмяВременнойТаблицы = Сред(шИмяВременнойТаблицы, 2);
				//RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шОдинарныеСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(" + шИмяВременнойТаблицы + ")""\)";
				//НовыйТекстЗапроса = RegExp.Заменить(НовыйТекстЗапроса, "$1");
				НовыйТекстЗапроса = мПлатформа.РазмаскироватьВременныеТаблицы(НовыйТекстЗапроса, МассивВременныхТаблиц);
			КонецЕсли;
			Если ЯзыкПрограммы = 1 Тогда
				Если Не ЭтоЧастичныйЗапрос И НачальнаяСтрокаЗапроса = 0 Тогда 
					ВыделитьВесьТекст();
				КонецЕсли; 
				//Если ОбрамитьСобранныйТекстСкобками Тогда
				//	НовыйТекстЗапроса = "(" + НовыйТекстЗапроса + ")";
				//КонецЕсли; 
				Если ИспользуемСобственныйКонструктор Тогда
					ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(НовыйТекстЗапроса, КонструкторЗапроса.мНомерТекущейСтрокиВСобранномТексте);
				Иначе
					ВыделенныйТекст(НовыйТекстЗапроса);
				КонецЕсли; 
				ПослеУстановкиВыделенногоМногострочногоТекста();
			Иначе
				НовыйТекстЗапроса = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекстЗапроса);
				ЧислоСтрокЗамены = СтрЧислоСтрок(НовыйТекстЗапроса);
				ТекстовыйДокумент = Новый ТекстовыйДокумент;
				ТекстовыйДокумент.УстановитьТекст(НовыйТекстЗапроса);
				СдвинутыйТекст = ТекстовыйДокумент.ПолучитьСтроку(1);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				Для Счетчик = 2 По ЧислоСтрокЗамены Цикл
					ТекущаяСтрокаВставки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
					СдвинутыйТекст = СдвинутыйТекст + Символы.ПС + НачалоНовойСтроки + ТекущаяСтрокаВставки;
				КонецЦикла;
				ВыделенныйТекст(СдвинутыйТекст);
				ПослеУстановкиВыделенногоМногострочногоТекста();
			КонецЕсли;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция РедактироватьВКонсолиЗапросов() Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	Если Истина
		И мПлатформа.РедактироватьЗапрос(Текст,,,,, ПолеТекста.ВыделениеДвумерное()) <> Неопределено 
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(Текст);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Функция РедактироватьВКонсолиКода() Экспорт

	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст запроса не может быть изменен. Открыть консоль без возможности применения изменений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	ФормаКонсоли = ирКлиент.ПолучитьФормуЛкс("Обработка.ирКонсольКода.Форма", , , Новый УникальныйИдентификатор);
	ФормаКонсоли.мРежимРедактора = Истина;
	ФормаКонсоли.ПараметрТекст = ПолеТекста.ПолучитьТекст();
	Если Истина
		И ФормаКонсоли.ОткрытьМодально() <> Неопределено 
		И Не РежимТолькоПросмотр 
	Тогда
		ВыделитьВесьТекст();
		ВыделенныйТекст(ФормаКонсоли.РезультатФормы.Текст);
		ПослеУстановкиВыделенногоМногострочногоТекста();
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции

Процедура ЗаменитьВыделенныйТекстЗапросаСоСнятиемВыделения(Знач НовыйТекстЗапроса, Знач НомерТекущейСтрокиВСобранномТексте = 0)
	
	ПолучитьНомерТекущейСтроки();
	ВыделенныйТекст(НовыйТекстЗапроса);
	мНачальнаяСтрока = мНачальнаяСтрока + НомерТекущейСтрокиВСобранномТексте; 
	мНачальнаяКолонка = 1;
	мКонечнаяСтрока = мНачальнаяСтрока;
	мКонечнаяКолонка = мНачальнаяКолонка;

КонецПроцедуры

Процедура ПоказатьТекущиеКоординаты(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	// Антибаг платформы 8.1 . Терялся фокус
	ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
	ПолеТекста.ПоказатьОшибку(мПарсер.CurrentLineNumber() + СтартоваяСтрокаДляОтображенияОшибок, мПарсер.CurrentColumnNumber(), ФормаВладелец);

КонецПроцедуры

Функция ПолучитьКоординатыВТекстеЗапроса(ПолеТекста, СтартоваяСтрокаДляОтображенияОшибок = 0)
	
	НомерСтроки = СтартоваяСтрокаДляОтображенияОшибок + мПарсер.CurrentLineNumber();
	Результат = "";
	Если ПолеТекста <> Неопределено Тогда
		Результат = Результат + ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) + ": ";
	КонецЕсли; 
	Результат = Результат + "Строка " + НомерСтроки + ": {(" + НомерСтроки + "," + мПарсер.CurrentColumnNumber() + ")}: ";
	Возврат Результат;
		
КонецФункции

Функция ПолучитьСтрокуОжидаемыхТокенов()

	СтрокаОжидаемыхТокенов = "";
	Для й = 0 по мПарсер.TokenCount() - 1 Цикл
		Токен = мПарсер.Tokens(й);
		СтрокаОжидаемыхТокенов = СтрокаОжидаемыхТокенов + ", " + Токен.Text;
	КонецЦикла;
	Возврат Сред(СтрокаОжидаемыхТокенов, 3);

КонецФункции // ПолучитьСтрокуОжидаемыхТокенов()

Функция _ПолучитьГраничныйТерминалПравила(Данные, ИндексГраницы = 0, ЗахватыватьКрайниеКомментарии = Ложь) Экспорт

	КоличествоТокенов = Данные.TokenCount;
	Для Сч1 = 1 По КоличествоТокенов Цикл
		Если ИндексГраницы = 1 Тогда
			УзелКандидат = Данные.Tokens(КоличествоТокенов - Сч1);
		Иначе
			УзелКандидат = Данные.Tokens(Сч1 - 1);
		КонецЕсли; 
		Если ТипЗнч(УзелКандидат.Data) = Тип("Строка") Тогда
			Если ЗахватыватьКрайниеКомментарии И ИндексГраницы = 1 И УзелКандидат.EndNoise <> Неопределено Тогда
				Возврат УзелКандидат.EndNoise;
			ИначеЕсли ЗахватыватьКрайниеКомментарии И ИндексГраницы = 0 И УзелКандидат.BeginNoise <> Неопределено Тогда
				Возврат УзелКандидат.BeginNoise;
			Иначе
				Возврат УзелКандидат;
			КонецЕсли; 
		ИначеЕсли ТипЗнч(УзелКандидат.Data) = Тип("COMОбъект") Тогда
			Если УзелКандидат.Data.TokenCount > 0 Тогда
				УзелСнизу = _ПолучитьГраничныйТерминалПравила(УзелКандидат.Data, ИндексГраницы, ЗахватыватьКрайниеКомментарии);
				Если УзелСнизу <> Неопределено Тогда
					Возврат УзелСнизу;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Функция ПолучитьТекстИзТокена(Токен, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0, Знач СлужебноеПолеТекста = Неопределено) Экспорт

	Если Токен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	НачальныйТокен = Токен.GetBorderToken(0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = Токен.GetBorderToken(1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1; 
	Если СлужебноеПолеТекста = Неопределено Тогда
		СлужебноеПолеТекста = СлужебноеПолеТекстаДолгое;
	КонецЕсли;
	СлужебноеПолеТекста.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекста.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция _ПолучитьТекстИзДанныхТокена(ДанныеТокена, выхНачальнаяСтрока = 0, выхНачальнаяКолонка = 0, выхКонечнаяСтрока = 0, выхКонечнаяКолонка = 0) Экспорт

	НачальныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 0);
	Если НачальныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхНачальнаяКолонка = НачальныйТокен.ColumnNumber;
	выхНачальнаяСтрока = НачальныйТокен.LineNumber;
	КонечныйТокен = _ПолучитьГраничныйТерминалПравила(ДанныеТокена, 1);
	Если КонечныйТокен = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	выхКонечнаяКолонка = КонечныйТокен.ColumnNumber + СтрДлина(КонечныйТокен.Data);
	выхКонечнаяСтрока = КонечныйТокен.LineNumber + СтрЧислоСтрок(КонечныйТокен.Data) - 1;
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(выхНачальнаяСтрока, выхНачальнаяКолонка, выхКонечнаяСтрока, выхКонечнаяКолонка);
	ТекстОпределения = СлужебноеПолеТекстаДолгое.ВыделенныйТекст;
	ТекстОпределения = СокрЛП(ТекстОпределения);
	Возврат ТекстОпределения;

КонецФункции

Функция ЗагрузитьТекстВКонструктор(ТекстЗапроса = Неопределено, Знач КонструкторЗапроса = Неопределено, Знач СокращенноеДерево = Ложь, ДиалектSQL = Неопределено,
	ИменованныеПараметры = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0) Экспорт
	
	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ПолеТекста.ПолучитьТекст();
	КонецЕсли;
	Если КонструкторЗапроса <> Неопределено Тогда
		КонструкторЗапроса.УстановитьДиалектSQL(ДиалектSQL, ИменованныеПараметры);
	КонецЕсли; 
	ТаблицаКомментариев = Неопределено;
	БылиПотери = Неопределено;
	НачальныйТокен = РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево,,, Истина, ТаблицаКомментариев, БылиПотери, СтартоваяСтрокаДляОтображенияОшибок);
	Если Истина
		И НачальныйТокен <> Неопределено
		И КонструкторЗапроса <> Неопределено 
	Тогда
		КонструкторЗапроса.СлужебноеПолеТекстаДолгое.УстановитьТекст(ТекстЗапроса);
		Если ДиалектSQL = Неопределено Тогда
			ДиалектSQL = мДиалектSQL;
		КонецЕсли; 
		КонструкторЗапроса.ЗапросыПакета.Очистить();
		КонструкторЗапроса.УстановитьДанные(НачальныйТокен, ТаблицаКомментариев, БылиПотери,, ПолучитьНомерТекущейСтроки());
	КонецЕсли;
	Возврат НачальныйТокен <> Неопределено;
	
КонецФункции

// Возвращает начальный токен (Структура) построенной структуры запроса.
//
// Параметры:
//  ТекстЗапроса						 - 	 - 
//  СокращенноеДерево					 - 	 - 
//  ОбновлятьСостояние					 - 	 - 
//  пПолеТекста							 - ОбработкаОбъект.ирПолеТекста, Неопределено, Null - при Неопределено будет использоваться связанное поле, при Null поле не будет использоваться
//  СообщатьОПропущенныхТерминалах		 - 	 - 
//  выхТаблицаКомментариев				 - 	 - 
//  выхБылиПотери						 - 	 - 
//  СтартоваяСтрокаДляОтображенияОшибок	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция РазобратьТекстЗапроса(ТекстЗапроса, СокращенноеДерево = Ложь, ОбновлятьСостояние = Истина, Знач пПолеТекста = Неопределено, СообщатьОПропущенныхТерминалах = Ложь, выхТаблицаКомментариев = Неопределено,
	выхБылиПотери = Неопределено, СтартоваяСтрокаДляОтображенияОшибок = 0, Знач ПоказыватьОшибки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
	    мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	мПарсер = мПлатформа.мПолучитьПарсер("ГрамматикаЯзыкаЗапросов");
	Если мПарсер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если пПолеТекста = Null Тогда
		пПолеТекста = Неопределено;
	ИначеЕсли пПолеТекста = Неопределено Тогда
		пПолеТекста = ПолеТекста;
	Иначе
		пПолеТекста = ирКлиент.ОболочкаПоляТекстаЛкс(пПолеТекста);
	КонецЕсли; 
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("Синтаксический разбор...");
	КонецЕсли; 
	выхТаблицаКомментариев = Новый ТаблицаЗначений;
	выхТаблицаКомментариев.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	выхТаблицаКомментариев.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	выхТаблицаКомментариев.Колонки.Добавить("ЭтоРасширение", Новый ОписаниеТипов("Булево"));
	gpMsgTokenRead			= 1;
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgCommentError		= 7;
	gpMsgInternalError		= 8;
	gpMsgCommentBlockRead	= 9;
	gpMsgCommentLineRead	= 10;
	мПарсер.OpenTextString(ТекстЗапроса + Символы.ПС);
	Закончили = Ложь;
	//ПоследниеТокены = Новый Массив();
	ПоследнееПравилоНеКомментарий = Неопределено;
	TrimReductions = СокращенноеДерево;
	мПарсер.TrimReductions = СокращенноеДерево; // Была Истина
	Пока Не Закончили Цикл 
		ОбработкаПрерыванияПользователя();
		Ответ = мПарсер.Parse();
		Если Истина
			И СокращенноеДерево
			И TrimReductions <> Истина 
		Тогда
			мПарсер.TrimReductions = Истина;
			TrimReductions = Истина;
		КонецЕсли; 
		Если Ложь
			Или Ответ = gpMsgLexicalError 
			Или (Истина // Хотя Builder в этом случае диагностирует лексическую ошибку, этот парсер почему то бесконечно выдает статус 7
				И Ответ = 7 
				И мПарсер.CurrentReduction = Неопределено)
		Тогда
			мПарсер.PopInputToken();
			Закончили = Истина;
			Если ПоказыватьОшибки Тогда
				КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Лексическая ошибка!",, СтатусСообщения.Важное);
				Если пПолеТекста <> Неопределено Тогда
					ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Ответ = gpMsgSyntaxError Тогда
			ТекущийТокен = мПарсер.CurrentToken();
			Если Истина
				И ТекущийТокен.Kind = 1 
				И (Ложь
					Или ТекущийТокен.Name = "MultiCommentLine"
					//Или ТекущийТокен.Name = "ExtensionBlock"
					Или ТекущийТокен.Name = "CommentBlock")
			Тогда
				Если СообщатьОПропущенныхТерминалах Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
						+ СокрЛП(ТекущийТокен.Data) + """"
						//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
						, , СтатусСообщения.Внимание);
				КонецЕсли; 
				мПарсер.PopInputToken();
			Иначе
				Закончили = Истина;
				Если ПоказыватьОшибки Тогда
					КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					ТекстОшибки = КоординатыВТекстеЗапроса + "Синтаксическая ошибка """ 
						+ ТекущийТокен.Data + """"
						+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов();
					ирОбщий.СообщитьСУчетомМодальностиЛкс(ТекстОшибки,, СтатусСообщения.Важное);
					Если пПолеТекста <> Неопределено Тогда
						ПоказатьТекущиеКоординаты(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgReduction Тогда
			Если СокращенноеДерево Тогда
				//ИмяПравила = мПарсер.CurrentReduction.ParentRule.RuleNonterminal.Name;
				ИмяПравила = мПарсер.CurrentRuleName();
				Если Ложь // Есть сомнения, что это работает как задумано
					Или ИмяПравила = "Table" 
					Или ИмяПравила = "TableName"
				Тогда
					мПарсер.TrimReductions = Ложь;
					TrimReductions = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgAccept Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgCommentError Тогда
		ИначеЕсли Ответ = gpMsgTokenRead Тогда
			Если мПарсер.IsCurrentTokenComment() Тогда
				// Храним 2 последних токена
				ТекущийТокен = мПарсер.CurrentToken();
				ПрочитатьКомментарий(выхТаблицаКомментариев, ТекущийТокен, пПолеТекста, СообщатьОПропущенныхТерминалах, СтартоваяСтрокаДляОтображенияОшибок);
			КонецЕсли; 
		ИначеЕсли Ответ = gpMsgInternalError Тогда
			Закончили = Истина;
		ИначеЕсли Ответ = gpMsgNotLoadedError Тогда
			Закончили = Истина;
		КонецЕсли;
	КонецЦикла;
	Если ОбновлятьСостояние Тогда
		ирОбщий.СостояниеЛкс("");
	КонецЕсли; 
	Если Ответ = gpMsgAccept Тогда
		НачальныйТокен = Новый Структура("Data, LineNumber, ColumnNumber, Name, Kind", мПарсер.CurrentReduction, 0, 0, "", 0);
		Возврат НачальныйТокен;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции

Процедура ПрочитатьКомментарий(Знач выхТаблицаКомментариев, Знач ТекущийТокен, Знач пПолеТекста, Знач СообщатьОПропущенныхТерминалах, Знач СтартоваяСтрокаДляОтображенияОшибок)
	
	ТекстКомментария = СокрЛП(ТекущийТокен.Data);
	МаркерХАРАКТЕРИСТИКИ = "ХАРАКТЕРИСТИКИ";
	ЭтоРасширение = Ложь;
	Если Лев(ТекстКомментария, 1) = "{" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 2, СтрДлина(ТекстКомментария) - 2);
		ЭтоРасширение = мПараметрыДиалектаSQL.Это1С;
	ИначеЕсли Лев(ТекстКомментария, 2) = "//" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3);
	ИначеЕсли Лев(ТекстКомментария, 2) = "/*" Тогда
		ТекстКомментария = Сред(ТекстКомментария, 3, СтрДлина(ТекстКомментария) - 4);
	КонецЕсли; 
	Если ЭтоРасширение И Лев(ТекстКомментария, СтрДлина(МаркерХАРАКТЕРИСТИКИ)) = МаркерХАРАКТЕРИСТИКИ Тогда
		выхБылиПотери = Истина;
		Если СообщатьОПропущенныхТерминалах Тогда
			КоординатыВТекстеЗапроса = ПолучитьКоординатыВТекстеЗапроса(пПолеТекста, СтартоваяСтрокаДляОтображенияОшибок);
			ирОбщий.СообщитьСУчетомМодальностиЛкс(КоординатыВТекстеЗапроса + "Проигнорирован комментарий """ 
			+ СокрЛП(ТекущийТокен.Data) + """"
			//+ ", ожидается: " + ПолучитьСтрокуОжидаемыхТокенов()
			, , СтатусСообщения.Внимание);
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(ТекстКомментария) Тогда 
		СтрокаРасширения = выхТаблицаКомментариев.Добавить();
		СтрокаРасширения.ЭтоРасширение = ЭтоРасширение;
		СтрокаРасширения.Позиция = ПолучитьОтносительнуюПозициюТокена(ТекущийТокен);
		СтрокаРасширения.Текст = ТекстКомментария; // Убираем крайние фигурные скобки
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьОтносительнуюПозициюТокена(Токен) Экспорт 
	
	Результат = Токен.LineNumber * 1000 + Токен.ColumnNumber;
	Возврат Результат;
	
КонецФункции

// Вызывает конструктор запросов и передает ему текст из текстового поля.
// 
// Возвращаемое значение:
//   Булево - признак изменения текста
//
Функция ОткрытьРедакторСтроковогоЛитерала() Экспорт

	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Ложь;
	КонецЕсли; 
	РежимТолькоПросмотр = Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр;
	Если РежимТолькоПросмотр Тогда
		Ответ = Вопрос("Текст не может быть изменен. Открыть редактор без возможности сохранения измений?",
			РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.Отмена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ФормаРедактора = мПлатформа.ПолучитьФорму("Текст", , Новый УникальныйИдентификатор);
	ПараметрГраницыВыделения = ПолеТекста.ВыделениеДвумерное();
	ФормаРедактора.ПараметрГраницыВыделения = ПараметрГраницыВыделения;
	ТекстСтроковогоЛитерала = ВыделитьТекстовыйЛитерал();
	ГраницыЛитерала = ПолеТекста.ВыделениеДвумерное();
	ПараметрГраницыВыделения.НачальнаяСтрока = ПараметрГраницыВыделения.НачальнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ПараметрГраницыВыделения.КонечнаяСтрока = ПараметрГраницыВыделения.КонечнаяСтрока - ГраницыЛитерала.НачальнаяСтрока + 1;
	ФормаРедактора.НачальноеЗначениеВыбора = ТекстСтроковогоЛитерала;
	ТекстИзменен = Ложь;
	Если ФормаРедактора.ОткрытьМодально() <> Неопределено Тогда
		Если Не РежимТолькоПросмотр Тогда
			НовыйТекстЗапроса = ФормаРедактора.Текст; 
			Если НовыйТекстЗапроса = ТекстСтроковогоЛитерала Тогда
				// Для TuboConf
			Иначе
				НовыйТекстЗапроса = ирОбщий.ТекстВВыражениеВстроенногоЯзыкаЛкс(НовыйТекстЗапроса);
				ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				ТекстНачальнойСтроки = ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока);
				ДлинаНачалаСтроки = СтрДлина(ТекстНачальнойСтроки) - СтрДлина(СокрЛ(ТекстНачальнойСтроки));
				НачалоСтроки = Лев(ТекстНачальнойСтроки, ДлинаНачалаСтроки);
				ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
				ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
				ЧислоПробелов  = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
				НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
				НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
				ВыделенныйТекст(СтрЗаменить(НовыйТекстЗапроса, Символы.ПС, Символы.ПС + НачалоНовойСтроки));
				ГраницыВыделенияНовые = ФормаРедактора.ПолеТекста().ВыделениеДвумерное();
				мНачальнаяСтрока = ГраницыВыделенияНовые.НачальнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мКонечнаяСтрока = ГраницыВыделенияНовые.КонечнаяСтрока + ГраницыЛитерала.НачальнаяСтрока - 1;
				мНачальнаяКолонка = ГраницыВыделенияНовые.НачальнаяКолонка;
				мКонечнаяКолонка = ГраницыВыделенияНовые.КонечнаяКолонка;
				ТекстИзменен = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	УстановитьГраницыВыделения();
	Возврат ТекстИзменен;

КонецФункции

Функция ВыделитьТекстовыйЛитерал(Знач ПолеТекстаЛ = Неопределено, выхНачальнаяПозиция = 0, выхКонечнаяПозиция = 0, Знач РазбиратьКонтекст = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если РазбиратьКонтекст Тогда
		РазобратьТекущийКонтекст();
	КонецЕсли;
	Если ПолеТекстаЛ = Неопределено Тогда
		ПолеТекстаЛ = ПолеТекста;
	Иначе
		ПолеТекстаЛ = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеТекстаЛ);
	КонецЕсли;
	// Мультиметка77248851
	ТекстПоля = ПолеТекстаЛ.ПолучитьТекст();
	мРегВыражение.Global = Истина;
	мРегВыражение.MultiLine = Ложь;
	мРегВыражение.Pattern = шСтрокаПрограммы;
	Результат = мРегВыражение.НайтиВхождения(ТекстПоля);
	Успех = Ложь;
	Для Каждого Вхождение Из Результат Цикл
		ПозицияВхождения = Вхождение.FirstIndex;
		Если Истина
			И (ПозицияВхождения + 1) <= мПозицияВТексте 
			И (ПозицияВхождения + Вхождение.Length) >= мПозицияВТексте 
		Тогда
			ПолеТекстаЛ.УстановитьГраницыВыделения(ПозицияВхождения + 1, ПозицияВхождения + 1 + Вхождение.Length,, ФормаВладелец);
			Успех = Истина;
			выхНачальнаяПозиция = ПозицияВхождения + 1;
			выхКонечнаяПозиция = ПозицияВхождения + Вхождение.Length;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Успех Тогда
		ТекстСтроковогоЛитерала = ПолеТекстаЛ.ВыделенныйТекст();
		Если Ложь
			Или Прав(ТекстСтроковогоЛитерала, 1) <> """" 
			Или СтрДлина(ТекстСтроковогоЛитерала) = 1
		Тогда
			ТекстСтроковогоЛитерала = ТекстСтроковогоЛитерала + """";
		КонецЕсли; 
		ТекстСтроковогоЛитерала = Вычислить(ТекстСтроковогоЛитерала);
		////ТекстСтроковогоЛитерала = СтрЗаменить(ТекстСтроковогоЛитерала, "|", "");
		//RegExp.Pattern = "(\s*)\|((.|"""")*(\n|\r|""))";
		//ТекстСтроковогоЛитерала = RegExp.Заменить(ТекстСтроковогоЛитерала, "$1 $2");
	Иначе
		ТекстСтроковогоЛитерала = Неопределено;
	КонецЕсли;
	Возврат ТекстСтроковогоЛитерала;

КонецФункции

// Осуществляет переход к определению контекста.
//
// Параметры:
//  Нет.
//
Функция ПерейтиКОпределению(НомерСтроки = 0, НомерКолонки = 0, РазрешитьДиалоги = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	РазобратьТекущийКонтекст(,,, НомерСтроки, НомерКолонки, Истина);
	Если ПустаяСтрока(мКонтекст) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПоследнееВхождение = Неопределено;
	ПоследнееОпределение = Неопределено;
	НайтиОпределениеСлова(мКонтекст, ПоследнееОпределение, ПоследнееВхождение);
	Если ПоследнееВхождение <> Неопределено Тогда
		ЗапомнитьИсточникПерехода();
		Если ирОбщий.СтрКончаетсяНаЛкс(мКонтекст, "(") И мЯзыкПрограммы = 0 Тогда
			НачальнаяПозицияОпределения = 0;
		Иначе
			НачальнаяПозицияОпределения = мПозицияТекстаДляПоискаОпределения;
		КонецЕсли;
		НачальнаяПозицияОпределения = НачальнаяПозицияОпределения + ПоследнееВхождение.FirstIndex + Найти(ПоследнееВхождение.Value, ПоследнееОпределение);
		КонечнаяПозицияОпределения = НачальнаяПозицияОпределения + СтрДлина(ПоследнееОпределение);
		ВыделитьДиапазонОдномерныйДляПользователя(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
		Результат = Истина;
	ИначеЕсли мЯзыкПрограммы = 0 Тогда 
		ТаблицаСтруктурТипов = Неопределено;
		Если мЭтоСтроковыйЛитерал Тогда 
			Если РазрешитьДиалоги Тогда
				Если Ложь
					Или Найти(мКонтекст, ".Форма.") > 0
					Или ирОбщий.СтрНачинаетсяСЛкс(мКонтекст, "ОбщаяФорма.") > 0
				Тогда
					Форма = ирКэш.ПассивнаяФормаПоИмениЛкс(НРег(мКонтекст));
					Если Форма <> Неопределено Тогда
						Форма.Открыть();
						ирКлиент.НачатьОтслеживаниеФормыЛкс(Форма);
						Возврат Истина;
					КонецЕсли;
				КонецЕсли;
				Если Ложь
					Или Найти(мКонтекст, ".Реквизит.") > 0
					Или Найти(мКонтекст, ".Измерение.") > 0
					Или Найти(мКонтекст, ".Ресурс.") > 0
				Тогда
					ОписаниеТаблицы = ирОбщий.ОписаниеТаблицыБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст));
					Если ОписаниеТаблицы <> Неопределено Тогда
						Форма = ирКлиент.ОткрытьКолонкуБДЛкс(ирОбщий.ПервыеФрагментыЛкс(мКонтекст), ирОбщий.ПоследнийФрагментЛкс(мКонтекст));
						Если Форма <> Неопределено Тогда
							Форма.Открыть();
							Возврат Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ирОбщий.ЛиИмяПеременнойЛкс(мКонтекст) Тогда
				МетодМодуля = мМодульМетаданных.Методы.Найти(НРег(мКонтекст), "НИмя");
				Если МетодМодуля <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(МетодМодуля);
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			//ТаблицаСтруктурТипов = Новый Массив;
			//СтруктураТипа = ТаблицаСтруктурТиповТекущегоВыражения()[0]; 
			//СтрокаОписанияМетода = СтруктураТипа.СтрокаОписания; 
			//Если Истина
			//	И СтруктураТипа.ТипЯзыка = "" 
			//	И СтрокаОписанияМетода <> Неопределено
			//Тогда
			//	ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
			//	Если Ложь
			//		Или Найти(ИмяПараметра, "ИмяМетода")
			//		Или Найти(ИмяПараметра, "ИмяПроцедуры")
			//		Или Найти(ИмяПараметра, "Действие")
			//		Или Найти(ИмяПараметра, "Обработчик")
			//		Или Не ЗначениеЗаполнено(ИмяПараметра)
			//	Тогда
					Если СтрЧислоВхождений(мКонтекст, ".") = 1 Тогда 
						Фрагменты = ирОбщий.СтрРазделитьЛкс(мКонтекст);
						ИмяМодуля = "ОбщийМодуль." + Фрагменты[0];
						Если Истина
							И мМодульМетаданных <> Неопределено 
							И ирОбщий.СтрНачинаетсяСЛкс(мИмяМодуля, "ОбщийМодуль." + Фрагменты[0]) 
						Тогда 
							МетодМодуля = мМодульМетаданных.Методы.Найти(НРег(Фрагменты[1]), "НИмя");
							Если МетодМодуля <> Неопределено Тогда
								ПерейтиКОпределениюЛокальногоМетода(МетодМодуля);
								Возврат Истина;
							КонецЕсли;
						КонецЕсли;
						АнализаторКода = ирОбщий.НовыйАнализаторКодаЛкс();
						АнализаторКода.ИнициироватьНеинтерактивно();
						АнализаторКода.УстановитьКлиентСерверКонтекст(Истина);
						ТаблицаСтруктурТипов = АнализаторКода.ВычислитьТипЗначенияВыражения(мКонтекст + "(");
					КонецЕсли;
			//	КонецЕсли;
			//КонецЕсли;
		Иначе
			ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
			Если ПараметрыМетода <> Неопределено Тогда
				СтрокаПараметра = ПараметрыМетода.Найти(НРег(мКонтекст), "НИмя");
				Если СтрокаПараметра <> Неопределено Тогда
					ПерейтиКОпределениюЛокальногоМетода(мМетодМодуля);
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;
			СтрокаПеременной = мМодульМетаданных.Переменные.Найти(НРег(мКонтекст), "НИмя");
			Если СтрокаПеременной <> Неопределено Тогда
				ПолеТекста.УстановитьГраницыВыделения(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием,,,, ФормаВладелец);
				ВыделитьДиапазонОдномерныйДляПользователя(СтрокаПеременной.ПозицияСОписанием, СтрокаПеременной.ПозицияСОписанием + СтрДлина("Перем " + СтрокаПеременной.Имя));
				Возврат Истина;
			КонецЕсли;
			ТаблицаСтруктурТипов = ВычислитьТипЗначенияВыражения(мКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
		КонецЕсли;
		Результат = Новый Массив;
		Если ТаблицаСтруктурТипов <> Неопределено Тогда
			Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
				Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
					Результат.Добавить(СтруктураТипа.Метаданные.ПолноеИмя());
				КонецЕсли;
				РезультатОткрытия = ОткрытьОпределениеСтруктурыТипа(СтруктураТипа,, РазрешитьДиалоги);
				Если РезультатОткрытия = Истина Тогда 
					Возврат Истина;
				КонецЕсли; 
				Если ТипЗнч(РезультатОткрытия) = Тип("Строка") Тогда
					Результат.Добавить(РезультатОткрытия);
				КонецЕсли;
			КонецЦикла;
			Результат = ирОбщий.СвернутьМассивЛкс(Результат);
		КонецЕсли;
		Если Результат.Количество() = 0 Тогда
			// Если стоим на имени типа
			Результат = ирОбщий.ИменаМетаданныхИзОписанияТиповЛкс(мКонтекст);
		КонецЕсли;
		Если Результат.Количество() = 1 Тогда
			Результат = Результат[0];
		ИначеЕсли Результат.Количество() > 1 Тогда 
			Если РазрешитьДиалоги Тогда 
				Результат = ирКлиент.ВыбратьОбъектМетаданныхЛкс(Результат);
			КонецЕсли;
		Иначе
			Результат = мКонтекст;
		КонецЕсли;
		Если РазрешитьДиалоги Тогда
			ОбъектМД = ирКлиент.ОткрытьОбъектМетаданныхЛкс(Результат);
		КонецЕсли;
	ИначеЕсли мЯзыкПрограммы = 1 Тогда 
		ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(мКонтекст);
		Если ОписаниеТаблицыБД <> Неопределено Тогда
			ирКлиент.ОткрытьОбъектМетаданныхЛкс(ОписаниеТаблицыБД.ПолноеИмяМД);
			Результат = ОписаниеТаблицыБД.ПолноеИмяМД;
		Иначе
			ТаблицаСтруктурТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			СтруктураТипаКонтекста = ТаблицаСтруктурТиповКонтекста[0];
			ИмяТаблицы = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
			ОписаниеТаблицыБД = ирОбщий.ОписаниеТаблицыБДЛкс(ИмяТаблицы);
			Если ОписаниеТаблицыБД <> Неопределено Тогда
				Если ОписаниеТаблицыБД.Тип = "ВиртуальнаяТаблица" Тогда
					ИмяТаблицы = ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(ИмяТаблицы);
				КонецЕсли;
				ФормаКолонки = ирКлиент.ОткрытьКолонкуБДЛкс(ИмяТаблицы, мТекущееСлово);
				Результат = ИмяТаблицы + "." + ФормаКолонки.РолиПоля + "." + мТекущееСлово;
				Если Не РазрешитьДиалоги Тогда
					ФормаКолонки.Закрыть();
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции

//.
// Параметры:
//    МетодМодуля - ? - 
Процедура ПерейтиКОпределениюЛокальногоМетода(МетодМодуля) Экспорт
	РазобратьТекущийКонтекст(,,,,, Истина);
	мКонтекст = МетодМодуля.Имя + "(";
	ПерейтиКОпределению();
КонецПроцедуры

Процедура ВыделитьДиапазонОдномерныйДляПользователя(Знач НачальнаяПозицияОпределения, Знач КонечнаяПозицияОпределения)
	
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(НачальнаяПозицияОпределения, КонечнаяПозицияОпределения);
	СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка); // Там текст без комментариев и опасных строковых литералов
	ПолеТекста.УстановитьГраницыВыделения(мНачальнаяСтрока, мНачальнаяКолонка, мКонечнаяСтрока, мКонечнаяКолонка,, ФормаВладелец); // Для ТуброКонфа

КонецПроцедуры

Функция ОткрытьОпределениеСтруктурыТипа(Знач СтруктураТипа, Знач ЭтоОбщийТип = Ложь, РазрешитьДиалоги = Истина)  Экспорт 
	
	Если СтруктураТипа.СтрокаОписания <> Неопределено Тогда 
		ТаблицаВладелец = СтруктураТипа.СтрокаОписания.Владелец();
		#Если Сервер И Не Сервер Тогда
			ТаблицаВладелец = Новый ТаблицаЗначений;
		#КонецЕсли
		Если ТаблицаВладелец.Колонки.Найти("ЛиЭкспорт") <> Неопределено Тогда
			СтрокаМетода = СтруктураТипа.СтрокаОписания;
			Если СтрокаМетода.Имя = "<>" Тогда
				ВиртуальныйМетод = СтрокаМетода.Владелец().Добавить();
				ЗаполнитьЗначенияСвойств(ВиртуальныйМетод, СтрокаМетода);
				ВиртуальныйМетод.Имя = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "(");
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВиртуальныйМетод);
				СтрокаМетода = ВиртуальныйМетод;
			КонецЕсли;
			Возврат ирКлиент.ОткрытьМетодМодуляПоОпределениюЛкс(СтрокаМетода, РазрешитьДиалоги);
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("Значение") <> Неопределено 
			И ирОбщий.ЛиСсылкаНаОбъектБДЛкс(СтруктураТипа.СтрокаОписания.Значение)
			И ЗначениеЗаполнено(СтруктураТипа.СтрокаОписания.Значение) 
		Тогда
			//ирКлиент.ОткрытьСсылкуВРедактореОбъектаБДЛкс(СтруктураТипа.СтрокаОписания.Значение);
			ирКлиент.ОткрытьЗначениеЛкс(СтруктураТипа.СтрокаОписания.Значение);
			Возврат Истина;
		ИначеЕсли Истина
			И ТаблицаВладелец.Колонки.Найти("ТипЗначения") <> Неопределено 
			И СтруктураТипа.СтрокаОписания.ТипЗначения = "Картинка"
			И ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда    
			Если РазрешитьДиалоги Тогда
				ирКлиент.ОткрытьЗначениеЛкс(БиблиотекаКартинок[СтруктураТипа.Метаданные.Имя]);
				Возврат Истина;
			КонецЕсли;
			Возврат СтруктураТипа.Метаданные.ПолноеИмя();
		КонецЕсли;                                                        
	КонецЕсли; 
	Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда
		ПолноеИмяМД = СтруктураТипа.Метаданные.ПолноеИмя();
		Если РазрешитьДиалоги Тогда
			ирКлиент.ОткрытьОбъектМетаданныхЛкс(СтруктураТипа.Метаданные);
			Возврат Истина;
		КонецЕсли;
		Возврат ПолноеИмяМД;
	КонецЕсли;
	Если ЭтоОбщийТип Тогда
		ПутьКСлову = СтруктураТипа.ИмяОбщегоТипа;
	Иначе
		ПутьКСлову = мКонтекст;
	КонецЕсли;  
	//Если РазрешитьДиалоги Тогда
		НайтиПоказатьСправкуПоСтруктуреТипа(ПутьКСлову, СтруктураТипа);
	//КонецЕсли; 
	Если СтруктураТипа.СтрокаОписания <> Неопределено Тогда
		Результат = "Справка";
	Иначе
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;

КонецФункции

// Перед вызовом можно установить свойство мНачальнаяСтрока например через ПолучитьГраницыВыделения()
Функция СсылкаСтрокиМодуля(Знач НомерСтроки = 0) Экспорт 
	ИмяМетода = "";
	Если Не ЗначениеЗаполнено(НомерСтроки) Тогда
		НомерСтроки = мНачальнаяСтрока;
	КонецЕсли;
	Если мМетодМодуля <> Неопределено Тогда
		ИмяМетода = мМетодМодуля.Имя;
		СмещениеСтрокиМетода = мНачальнаяСтрока - НомерСтрокиИзПозиции(мМетодМодуля.ПозицияОпределения);
	КонецЕсли;
	Результат = ирОбщий.СсылкаСтрокиМодуляЛкс(мИмяМодуля, мНачальнаяСтрока, ИмяМетода, СмещениеСтрокиМетода, ПолеТекста.ПолучитьСтроку(мНачальнаяСтрока));
	Возврат Результат;
КонецФункции

//.
// Параметры:
//    Позиция - Число - начиная с 1
// Возвращаемое значение:
//    Число - 
Функция НомерСтрокиИзПозиции(Позиция) Экспорт
	СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(Позиция, Позиция);
	НомерСтроки = ирКлиент.ОболочкаПоляТекстаЛкс(СлужебноеПолеТекстаДолгое).ВыделениеДвумерное().КонечнаяСтрока;
	Возврат НомерСтроки;
КонецФункции

// Ищем в мТекстДляПоискаОпределения
Функция НайтиОпределениеСлова(Слово, ПоследнееОпределение = Неопределено, ПоследнееВхождение = Неопределено) Экспорт 
	
	ПоследнееОпределение = Неопределено;
	Если мЯзыкПрограммы = 1 Тогда
		мРегВыражение.Global = Ложь;
		мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Слово));
		РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[0];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(3);
			лНачальнаяСтрока = 0;
			лНачальнаяКолонка = 0;
			лКонечнаяСтрока = 0;
			лКонечнаяКолонка = 0;
			СлужебноеПолеТекстаДолгое.УстановитьГраницыВыделения(мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1, 
				мПозицияТекстаДляПоискаОпределения + ПоследнееВхождение.FirstIndex + 1 + СтрДлина(ПоследнееОпределение));
			СлужебноеПолеТекстаДолгое.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Если Истина
				И лНачальнаяСтрока = мНачальнаяСтрока И лНачальнаяКолонка <= мНачальнаяКолонка 
				И лКонечнаяСтрока = мКонечнаяСтрока И лКонечнаяКолонка >= мКонечнаяКолонка
			Тогда
				мРегВыражение.Global = Ложь;
				ШаблонСозданияТаблицы = "(?:" + шРазделитель + ")+" + "(?:ПОМЕСТИТЬ|INTO(?:" + шРазделитель + "+TABLE)?)" + шРазделитель + "+(#Идентификатор#)" + шРазделитель;
				мРегВыражение.Pattern = СтрЗаменить(ШаблонСозданияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Слово));
				ТекстБезКомментариевИОпасныхСтрок = ЗалитьКомментарииИСтроковыеЛитералы(мТекстДляПоискаОпределения);
				РезультатТекста = мРегВыражение.НайтиВхождения(ТекстБезКомментариевИОпасныхСтрок);
				Если РезультатТекста.Количество() > 0 Тогда
					ПоследнееОпределение = РезультатТекста[0].SubMatches(0);
					ПоследнееВхождение = ирОбщий.СоздатьОбъектПоИмениМетаданныхЛкс("Обработка.ирОболочкаРегВхождение");
					ЗаполнитьЗначенияСвойств(ПоследнееВхождение, РезультатТекста[0],, "SubMatches"); // Создаем неполноценный объект ради изменения свойства FirstIndex
					ПоследнееВхождение.FirstIndex = ПоследнееВхождение.FirstIndex - мПозицияТекстаДляПоискаОпределения;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			МаркерЗначение = "ЗНАЧЕНИЕ(";
			Если Прав(мПредшествующийТекст, СтрДлина(МаркерЗначение)) = МаркерЗначение Тогда
				мРегВыражение.Global = Ложь;
				мРегВыражение.Pattern = шИмя;
				Если мРегВыражение.Проверить(Слово) Тогда 
					Попытка
						ПредопределенноеЗначение = ПредопределенноеЗначение(Слово);
					Исключение
						ПредопределенноеЗначение = Неопределено;
					КонецПопытки; 
					Если ПредопределенноеЗначение <> Неопределено Тогда
						ОткрытьЗначение(ПредопределенноеЗначение);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
	Иначе
		мРегВыражение.Global = Истина;
		ЭкранированноеСлово = ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(ирОбщий.ПервыйФрагментЛкс(Слово, "("));
		Если ирОбщий.СтрКончаетсяНаЛкс(Слово, "(") Тогда
			// Ищем определение метода в тексте модуля
			мРегВыражение.Pattern = ирОбщий.СтрЗаменитьЛкс(мПлатформа.ШаблоныДляАнализаВстроенногоЯзыка().ОписаниеМетодаЧистое, шИмя, ЭкранированноеСлово);
			РезультатТекста = мРегВыражение.НайтиВхождения(мОригинальныйТекст);
		ИначеЕсли Лев(Слово, 1) = "~" Тогда 
			мРегВыражение.Pattern = мПлатформа.шПустоеНачалоСтроки + "(" + Слово + ":)";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстБлока);
		Иначе
			//шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((Новый|New)" + шРазделитель + "+(" + шИмя + ")|(" + шИмяСкобки + "?" + шИндекс 
			//	+ "?(\." + шИмяСкобки + "?" + шИндекс + "?)*)" + "|(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";
			ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "?" + "(\." + шИмяСкобки + "?" + шИндекс + "?)*))";
			мРегВыражение.Pattern = шПредИмя + ЭкранированноеСлово + "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
			РезультатТекста = мРегВыражение.НайтиВхождения(мТекстДляПоискаОпределения);
		КонецЕсли;
		Если РезультатТекста.Количество() > 0 Тогда
			ПоследнееВхождение = РезультатТекста[РезультатТекста.Количество() - 1];
			ПоследнееОпределение = ПоследнееВхождение.SubMatches(0);
			//Если ПоследнееВхождение.SubMatches(1) <> Неопределено Тогда
			//	// Это присвоение
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(1);
			//Иначе
			//	// Это обход коллекции
			//	ПоследнееОпределение = ПоследнееВхождение.SubMatches(20);
			//КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ПоследнееОпределение;

КонецФункции

// Вычисляет массив структур типа дочернего контекста.
//
// Параметры:
//  МассивРодительскихСтрутурТипа - Массив - родительских структур типа;
//  ТекущееСлово - Строка - дочернеее слово;
//  ТипСлова     - Строка - тип слова;
//  *ТекущийИндекс - Строка, *Неопределено - выражение в квадратных скобках;
//  *ТекущиеАргументы - Строка, *"" - аргументы метода;
//  *ПредшествующийТекст - Строка, *"" - текст для поиска определения таблицы в режиме языка запросов.
//
// Возвращаемое значение:
//  МассивСтрутурТипа - Массив - дочерних структур типа.
//
Функция ВычислитьТипДочернегоЭлемента(МассивРодительскихСтрутурТипа, ТекущееСлово, ТипСлова, ТекущийИндекс = Неопределено, ТекущиеАргументы = "", ПредшествующийТекст = "",
	ПолныйАнализ = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать(); 
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТаблицаСвойствТипа = мПлатформа.НоваяТаблицаСвойствТипа(); // Ускорение
	ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	СчетчикТипов = 0;
	Для Каждого РодительскаяСтруктураТипа Из МассивРодительскихСтрутурТипа Цикл
		СчетчикТипов = СчетчикТипов + 1;
		Если Истина
			И Не ПолныйАнализ
			И СчетчикТипов > 50
		Тогда 
			Прервать;
		КонецЕсли; 
		Если РодительскаяСтруктураТипа.ИмяОбщегоТипа <> "Неизвестный контекст" Тогда
			МетаданныеРодителя = РодительскаяСтруктураТипа.Метаданные;
			ЭтоЛокальныйКонтекст = РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Локальный";
			Если Не ЗначениеЗаполнено(ТекущийИндекс) Тогда
				
				// Ищем правило вычисления
				Если ТипСлова = "Метод" Тогда
					КлючСтроки = Новый Структура;
					КлючСтроки.Вставить("ТипКонтекста", РодительскаяСтруктураТипа.ИмяОбщегоТипа);
					КлючСтроки.Вставить("НСлово", НРег(ТекущееСлово));
					НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
					Если НайденныеСтроки.Количество() = 0 Тогда
						КлючСтроки.ТипКонтекста = "*";
						НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
					КонецЕсли;
					Если НайденныеСтроки.Количество() > 0 Тогда
						мРегВыражение.Global = Истина;
						Если мЯзыкПрограммы = 0 Тогда
							мРегВыражение.Pattern = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*,";
						Иначе
							мРегВыражение.Pattern = "(" + шВыражениеЗапроса   + ")?" + шРазделитель + "*,";
						КонецЕсли;
						Результат = мРегВыражение.НайтиВхождения(Нрег(Сред(ТекущиеАргументы, 2, СтрДлина(ТекущиеАргументы) - 2) + ","));
						МассивПараметров = Новый Массив;
						Для Каждого Вхождение Из Результат Цикл
							МассивПараметров.Добавить(СокрЛП(Вхождение.SubMatches(0)));
						КонецЦикла; 
						//Попытка
							ТаблицаСтруктурТиповВычисленная = Вычислить(НайденныеСтроки[0].Правило + "(РодительскаяСтруктураТипа, МассивПараметров, ТекущееСлово, ПредшествующийТекст)");
							Если ТаблицаСтруктурТиповВычисленная <> Неопределено Тогда 
								мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ТаблицаСтруктурТиповВычисленная);
								Продолжить;
							КонецЕсли;
						//Исключение КонецПопытки;
					КонецЕсли;
				КонецЕсли;
				
				// Ищем предопределенное слово
				Если Истина
					И ЭтоЛокальныйКонтекст
					//И (Ложь
					//	Или ЯзыкПрограммыТекста = 0
					//	Или ЯзыкПрограммыТекста = 2)
				Тогда
					ПройденныеВызовы = мРекурсивныйПуть.ВходящиеВызовы;
					ПараметрыМетода = мПлатформа.ПараметрыМетодаМодуля(мМетодМодуля);
					Если ПараметрыМетода <> Неопределено И ТипСлова = "Свойство" Тогда
						СтрокаПараметраМетода = ПараметрыМетода.Найти(НРег(ТекущееСлово), "НИмя");
						Если СтрокаПараметраМетода <> Неопределено Тогда
							
							// События формы
							ФормаМодуля = мМодульМетаданных.СтруктураТипа.Метаданные;
							Если Истина
								И ирОбщий.СтрКончаетсяНаЛкс(мМодульМетаданных.Имя, ".Форма.Модуль")
								И (Ложь
									Или ТипЗнч(ФормаМодуля) = Тип("Форма")
									Или ТипЗнч(ФормаМодуля) = ирОбщий.ТипУправляемаяФормаЛкс()) 
							Тогда
								ВсеОбработчикиСобытий = ирОбщий.ВсеОбработчикиСобытийФормаЛкс(ФормаМодуля);
								СтрокаОбработчика = ВсеОбработчикиСобытий.Найти(НРег(мМетодМодуля.Имя), "НОбработчик");
								Если СтрокаОбработчика <> Неопределено Тогда 
									ЭлементФормы = Неопределено;
									ПараметрыСобытия = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОбработчика.СтрокаОписания);
									Если ЗначениеЗаполнено(СтрокаОбработчика.Имя) Тогда
										СтрокаПараметра = ПараметрыСобытия.Вставить(0);
										СтрокаПараметра.Слово = "Элемент";
										Если ТипЗнч(ФормаМодуля) = Тип("Форма") Тогда
											Попытка
												ЭлементФормы = Вычислить("ФормаМодуля.ЭлементыФормы." + СтрокаОбработчика.Имя);
											Исключение
											КонецПопытки;
										Иначе
											ЭлементФормы = ФормаМодуля.Элементы.Найти(СтрокаОбработчика.Имя);
										КонецЕсли;
									КонецЕсли;
									Если Истина
										И мМетодМодуля.Параметры.Количество() > 0 
										и Не ЗначениеЗаполнено(мМетодМодуля.Параметры[0].ТипЗначения)
									Тогда
										мМетодМодуля.Описание = СтрокаОбработчика.СтрокаОписания.Описание;
										// TODO перенести в мПлатформа.ПараметрыМетодаМодуля()
										ИндексПараметра = 0;
										Для Каждого СтрокаПараметра Из ПараметрыСобытия Цикл
											СтрокаПараметраЦикл = мМетодМодуля.Параметры[ИндексПараметра];
											СтрокаПараметраЦикл.ТипЗначения = СтрокаПараметра.ТипЗначения;
											СтрокаПараметраЦикл.Описание = СтрокаПараметра.Описание;
											ИндексПараметра = ИндексПараметра + 1;
										КонецЦикла;
									КонецЕсли;
									Если ЭлементФормы <> Неопределено Тогда
										Если ирОбщий.СтрокиРавныЛкс(СтрокаПараметраМетода.Имя, "Элемент") Тогда 
											мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы));
											Прервать;
										ИначеЕсли Истина                         
											И ПараметрыМетода[0].Имя = "Элемент"
											И (Ложь
												Или СтрокаПараметраМетода.Имя = "ВыбраннаяСтрока"
												Или СтрокаПараметраМетода.Имя = "ДанныеСтроки")
											И ТипЗнч(ФормаМодуля) = Тип("Форма")
										Тогда 
											ТаблицаДочернихСлов = мПлатформа.СвойстваТипаПредопределенные(мПлатформа.СтруктураТипаИзЗначения(ЭлементФормы), "ТекущиеДанные", "Свойство");
											мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ТаблицаДочернихСлов[0].ТаблицаСтруктурТипов);
											Прервать;
										ИначеЕсли Истина                         
											И ПараметрыМетода[0].Имя = "Элемент"
											И СтрокаПараметраМетода.Имя = "ОформлениеСтроки"
											И ТипЗнч(ФормаМодуля) = Тип("Форма")
										Тогда 
											мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип("ОформлениеСтроки"),, Новый Структура("Метаданные", ЭлементФормы)));
											Прервать;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли; 
							КонецЕсли;
							
							// Подсказка по параметру "Источник" обработчиков подписок на события
							Если Истина
								И СтрокаПараметраМетода.Имя = "Источник"
								И ирОбщий.СтрНачинаетсяСЛкс(мМодульМетаданных.Имя, "ОбщийМодуль.")
							Тогда 
								ИмяМодуля = мМодульМетаданных.СтруктураТипа.Метаданные.Имя;
								Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
									Если ирОбщий.СтрокиРавныЛкс(ПодпискаНаСобытие.Обработчик, ИмяМодуля + "." + мМетодМодуля.Имя) Тогда 
										мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ПодпискаНаСобытие.Источник);
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
							
							// TODO Ограничить анализируемое число вызовов
							ТипЗначения = ирОбщий.ОписаниеТиповИзТекстаЛкс(СтрокаПараметраМетода.ТипЗначения);
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ТипЗначения);
							ШаблонПараметра = "(" + шВыражениеПрограммы + ")?" + шРазделитель + "*(?:$|,|\))";
							ИндексПараметра = ПараметрыМетода.Индекс(СтрокаПараметраМетода);
							ВхожденияВызова = ирОбщий.НайтиРегВыражениеЛкс(мОригинальныйТекст, ШаблонВызоваМетода(мМетодМодуля.Имя),,,,,, Истина, мРегВыражение); // Передаем РегВыражение для ускорения
							#Если Сервер И Не Сервер Тогда
								ВхожденияВызова = Обработки.ирПлатформа.Создать().ВхожденияРегВыражения;
							#КонецЕсли
							Для Каждого ВхождениеВызова Из ВхожденияВызова Цикл
								Если Истина
									И ВхождениеВызова.ПозицияВхождения > мМетодМодуля.ПозицияОпределения 
									И ВхождениеВызова.ПозицияВхождения < мМетодМодуля.ПозицияТела
								Тогда
									// Собственное определение метода
									Продолжить;
								КонецЕсли;
								ТекстВызова = Сред(ВхождениеВызова.ТекстВхождения, Найти(ВхождениеВызова.ТекстВхождения, "(") + 1);
								ВхожденияПараметров = ирОбщий.НайтиРегВыражениеЛкс(ТекстВызова, ШаблонПараметра,,,,,, Истина, мРегВыражение,, ВхожденияПараметров); // Передаем РегВыражение для ускорения
								#Если Сервер И Не Сервер Тогда
									ВхожденияПараметров = Обработки.ирПлатформа.Создать().ВхожденияРегВыражения;
								#КонецЕсли
								Если ВхожденияПараметров.Количество() > ИндексПараметра Тогда
									ВхождениеПараметра = ВхожденияПараметров[ИндексПараметра];
									ФактическийПараметр = СокрЛП(ирОбщий.СтрокаБезКонцаЛкс(ВхождениеПараметра.ТекстВхождения));
									ПолеТекстаПрограммыВызова = КопияКомпоненты();
									#Если Сервер И Не Сервер Тогда
										ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
									#КонецЕсли
									ЧислоСтрок = СтрЧислоСтрок(Лев(мОригинальныйТекст, ВхождениеВызова.ПозицияВхождения) + "й");
									ПолеТекстаПрограммыВызова.РазобратьТекущийКонтекст(,,, ЧислоСтрок, 1);
									Если ПолеТекстаПрограммыВызова.мМетодМодуля = Неопределено Тогда
										ИмяВызывающегоМетода = "<Инициация>";
									Иначе
										ИмяВызывающегоМетода = ПолеТекстаПрограммыВызова.мМетодМодуля.Имя;
									КонецЕсли;
									КлючВызова = ИмяВызывающегоМетода + "-" + мМетодМодуля.Имя;
									Если ПройденныеВызовы[КлючВызова] = Неопределено Тогда
										ПройденныеВызовы[КлючВызова] = 1; // Таким образом мы не более одного вызова из каждого метода проверяем
										ИмяВиртуальнойПеременной = "Зщшмеухя";
										ТаблицаСтруктурТиповИсточник = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ИмяВиртуальнойПеременной, 
											" " + ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения + ";" + Символы.ПС + ИмяВиртуальнойПеременной + "=" + ФактическийПараметр + ";",
											ПолеТекстаПрограммыВызова.мПредшествующийТекст,,,, Ложь);
										Если ТаблицаСтруктурТиповИсточник[0].ИмяОбщегоТипа <> "Неизвестный контекст" Тогда
											мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ТаблицаСтруктурТиповИсточник);
											// Прерываем для ускорения
											Прервать;
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					Если мМодульМетаданных <> Неопределено Тогда
						СтруктураКлюча = Новый Структура("НИмя", Нрег(ТекущееСлово));
						НайденныеСтроки = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(СтруктураКлюча);
						Если НайденныеСтроки.Количество() > 0 Тогда
							СтрокаСлова = НайденныеСтроки[0]; 
							ПолеТекстаПрограммыВызова = КопияКомпоненты();
							Если ТипСлова = "Метод" Тогда
								мПлатформа.ПодготовитьТипРезультатаМетода(СтрокаСлова, мМодульМетаданных,, ПолеТекстаПрограммыВызова); 
							Иначе
								мПлатформа.ПодготовитьТипЗначенияПеременнойМодуля(СтрокаСлова, мМодульМетаданных, ПолеТекстаПрограммыВызова); 
							КонецЕсли;  
							ТаблицаСтруктурТиповСловаМодуля = мПлатформа.ТаблицаСтруктурТиповСловаМодуля(СтрокаСлова, мМодульМетаданных);
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, ТаблицаСтруктурТиповСловаМодуля);
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если мЯзыкПрограммы = 1 Тогда
					ВиртуальнаяТаблица = Новый Структура("Выражение, НомерСтроки");
					ВиртуальнаяТаблица.Выражение = "." + ТекущееСлово;
					Если ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						//ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + "." + ТекущиеАргументы;  // Кажется это было сделано умышленно
						ВиртуальнаяТаблица.Выражение = ВиртуальнаяТаблица.Выражение + ТекущиеАргументы; // https://www.hostedredmine.com/issues/958394
					КонецЕсли;
					ВиртуальнаяТаблица.НомерСтроки = СтрЧислоСтрок(ПредшествующийТекст);
				Иначе
					ВиртуальнаяТаблица = Неопределено;
				КонецЕсли;
				ТаблицаСвойствТипа.Очистить();
				мПлатформа.СвойстваТипаПредопределенные(РодительскаяСтруктураТипа, ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, мЯзыкПрограммы, Конфигурация,, мФлагиКомпиляции, ТаблицаСвойствТипа, ЭтоЛокальныйКонтекст);
				Если ТаблицаСвойствТипа.Количество() > 0 Тогда
					МаксКоличествоВариантов = 5;
					КоличествоВариантов = 0;
					Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
						мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтрокаСлова.ТаблицаСтруктурТипов);
						КоличествоВариантов = КоличествоВариантов + 1;
						Если КоличествоВариантов >= МаксКоличествоВариантов Тогда
							Прервать;
						КонецЕсли; 
					КонецЦикла;
					Если Истина
						И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "БлокировкаДанных" 
						И ТипСлова = "Метод" 
						И ТекущееСлово = "Добавить" 
					Тогда
						ТаблицаСтруктурТипов.ЗаполнитьЗначения(ирОбщий.ТекстМеждуМаркерамиЛкс(ТекущиеАргументы, """", """"), "Метаданные");
					КонецЕсли; 
					Продолжить;
				ИначеЕсли Истина
					И ЗначениеЗаполнено(РодительскаяСтруктураТипа.ТипЯзыка) 
					И РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Строка" 
				Тогда 
					ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), РодительскаяСтруктураТипа); 
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			ТаблицаСвойствТипа.Очистить();
			мПлатформа.СвойстваТипаМетаданные(РодительскаяСтруктураТипа,
				ТекущееСлово, ТипСлова, ВиртуальнаяТаблица, мЯзыкПрограммы, ТекущийИндекс,,, мФлагиКомпиляции, МодульМетаданныхКонтекста(РодительскаяСтруктураТипа), ТаблицаСвойствТипа,, ЭтоЛокальныйКонтекст);
			Если ТаблицаСвойствТипа.Количество() > 0 Тогда
				Для Каждого СтрокаСлова Из ТаблицаСвойствТипа Цикл
					Если Истина
						И СтрокаСлова.ТаблицаСтруктурТипов <> Неопределено 
						И (Ложь 
							Или Найти(СтрокаСлова.Слово, "<") = 0
							Или ТаблицаСтруктурТипов.Количество() = 0
							Или Найти(ТаблицаСтруктурТипов[0].ИмяОбщегоТипа, "<") > 0)
					Тогда
						мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтрокаСлова.ТаблицаСтруктурТипов);
					КонецЕсли; 
				КонецЦикла;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции

Функция ШаблонВызоваМетода(Знач ИмяВызова) Экспорт 
	
	Если Лев(ИмяВызова, 1) = "." Тогда
		Начало = "";
	Иначе
		// Начало = "(?:[^" + мПлатформа.шБуква + "\d\.\s]|^|[^\.\s]\s+)" // Более строгий, но медленный
		Начало = "(?:[^" + шБуква + "\d\.]|^)";
	КонецЕсли;
	ШаблонВызова = Начало + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(ИмяВызова) + "\s*\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*" + шВыражениеПрограммы + "?" + шРазделитель + "*)\)";
	Возврат ШаблонВызова;

КонецФункции

Функция МодульМетаданныхКонтекста(Знач РодительскаяСтрутураТипа)
	
	Если РодительскаяСтрутураТипа.ИмяОбщегоТипа = "Локальный" Тогда
		МодульМетаданных = мМодульМетаданных;
	Иначе
		МодульМетаданных = Неопределено;
	КонецЕсли;
	Возврат МодульМетаданных;

КонецФункции

// Определяет тип значения слова в режиме внутреннего языка.
//
// Параметры:
//  Контекст     - Строка - последовательность идентификаторов через "." без круглых и квадратных скобок.
//  ТекстДляПоискаОпределения - Строка - где ищем определение;
//
// Возвращаемое значение:
//  ТаблицаЗначений.
//
Функция ВычислитьТипЗначенияВыражения(Знач Выражение = "", Знач ТекстДляПоискаОпределения = "", Знач ПредшествующийТекст = "", Знач РазрешитьАнализИмениТипа = Ложь,
	Знач ЭтоВызовКонструктора = Ложь, ПолныйАнализ = Истина, Знач КорневойВызов = Истина) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли  
	Если КорневойВызов Тогда
		мРекурсивныйПуть = Новый Структура;
		мРекурсивныйПуть.Вставить("ВходящиеВызовы", Новый Соответствие);
		мРекурсивныйПуть.Вставить("Позиции", Новый Массив);
	КонецЕсли;
	ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
	//Если ЗначениеЗаполнено(Конфигурация) Тогда
		СтруктураТипа.Метаданные = Конфигурация;
	//Иначе
	//	СтруктураТипа.Метаданные = мПлатформа.мМетаданные;
	//КонецЕсли; 
	Если РазрешитьАнализИмениТипа Тогда
		Если мЯзыкПрограммы = 1 Тогда
			мТолькоСсылочныеИменаТипов = Истина;
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмя + "(?:ССЫЛКА|REFS)" + шРазделитель + "+$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			//RegExp.Pattern = шПредИмя + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+$"; // Привязка к концу вызывала катастрофическое шагание назад
			мРегВыражение.Pattern = шПредИмя + "(?:ВЫРАЗИТЬ|CAST)" + шРазделитель + "*\(" + шВыражениеЗапроса + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+"; // 08.02.2023
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст, Истина);
			Если Истина
				И Результат.Количество() > 0 
				И ПустаяСтрока(Сред(ПредшествующийТекст, Результат[0].FirstIndex + Результат[0].Length)) // 08.02.2023
			Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмя + "(?:ТИП|TYPE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
				мТолькоСсылочныеИменаТипов = Ложь;
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмя + "(?:ЗНАЧЕНИЕ|VALUE)" + шРазделитель + "*\(" + шРазделитель + "*$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе";
			КонецЕсли;
		Иначе
			мРегВыражение.Global = Истина;
			мРегВыражение.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "+$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				// Активная следующая строка блокирует недокументированные возможности.
				//СтруктураТипа.Вставить("Конструктор", Истина);
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмя + "Тип" + шРазделитель + "*\(" + шРазделитель + "*""$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
			мРегВыражение.Pattern = шПредИмя + "(?:Новый|New)" + шРазделитель + "*ОписаниеТипов\(" + шРазделитель + "*""[^""]*$";
			Результат = мРегВыражение.НайтиВхождения(ПредшествующийТекст);
			Если Результат.Количество() > 0 Тогда
				СтруктураТипа.ТипЯзыка = "ИмяТипа";
			КонецЕсли;
		КонецЕсли;
		Если Ложь
			Или СтруктураТипа.ТипЯзыка = "ИмяТипа"
			Или СтруктураТипа.ТипЯзыка = "ЗначениеВЗапросе"
		Тогда
			СтруктураТипа.ИмяОбщегоТипа = "";
		Иначе
			Если мЭтоСтроковыйЛитерал Тогда
				Результат = ВычислитьТипЗначенияВыражения(мВызовМетода, ТекстДляПоискаОпределения, ПредшествующийТекст,, мЭтоКонструктор, ПолныйАнализ, Ложь);
				Возврат Результат;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	Если Ложь
		Или Выражение = Неопределено
		Или Выражение = ""
	Тогда
		Если СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст" Тогда
			СтруктураТипа.ИмяОбщегоТипа = "Локальный"; // Приватные свойства + глобальный контекст
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
			Если мМодульМетаданных <> Неопределено И мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
				мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, мМодульМетаданных.СтруктураТипа);
			КонецЕсли;
		КонецЕсли;
	Иначе
		мРегВыражение.Global = Ложь;
		мРегВыражение.Pattern = "(((\.(" + шИмя + "|\?|)" + шСкобки + "?)|" + шИндекс + ")*)" +
			              "((\.(" + шИмя + "|\?|)" + шНачалоСкобок + "?)|" + шИндекс + ")$";
		Результат = мРегВыражение.НайтиВхождения("." + Выражение);
		Если Результат.Количество() > 0 Тогда 
			ТаблицаСтруктурРодителей = Новый Массив;
			РодительскийКонтекст = Сред(Результат[0].SubMatches(0), 2);
			ТекущееСлово = Результат[0].SubMatches(8);
			ТекущийИндекс = Результат[0].SubMatches(10);
			ТекущиеАргументы = Результат[0].SubMatches(9);
			ТипСлова = "Свойство";
			Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущийИндекс) Тогда
				ТекущееСлово = Сред(ТекущийИндекс, 2, СтрДлина(ТекущийИндекс) - 2);
			КонецЕсли;
			Если мЯзыкПрограммы = 1 Тогда
				ТипСлова = Неопределено;
				Если РодительскийКонтекст = "" Тогда
					Если ЗначениеЗаполнено(ТекущееСлово) Тогда
						мРегВыражение.Global = Ложь;
						мРегВыражение.Pattern = СтрЗаменить(шПоискОписанияТаблицы, "#Идентификатор#", ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(ТекущееСлово));
						РезультатТекста = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения);
						Если РезультатТекста.Количество() > 0 Тогда
							ПоследнееВхождение = РезультатТекста[0];
							СледРекурсии = мРекурсивныйПуть.Позиции.Найти(ПоследнееВхождение.FirstIndex);
							Если СледРекурсии = Неопределено Тогда
								мРекурсивныйПуть.Позиции.Добавить(ПоследнееВхождение.FirstIndex);
								ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(3);
								Если ПрисвоенныйКонтекст <> Выражение Тогда
									МассивСтруктурПрисвоенныхТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст, ТекстДляПоискаОпределения,
										Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1), РазрешитьАнализИмениТипа,, ПолныйАнализ, Ложь);
									мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, МассивСтруктурПрисвоенныхТипов);
								КонецЕсли; 
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли ЗначениеЗаполнено(ТекущиеАргументы) Тогда
						ТекущееСлово = ирОбщий.УдалитьВнешниеСкобкиВыраженияЛкс(ТекущиеАргументы);
						Если ирОбщий.СтрНачинаетсяСЛкс(ТекущееСлово, "Выразить(") Тогда
							ТекущиеАргументы = ирОбщий.ТекстМеждуМаркерамиЛкс(ТекущееСлово, "(", ")", Ложь, Истина);
							ТекущееСлово = "ВЫРАЗИТЬ";
							мРегВыражение.Pattern = шРазделитель + "(?:КАК|AS)" + шРазделитель + "+(" + шИмя + "(?:\." + шИмя + ")*)";
							Результат = мРегВыражение.НайтиВхождения(ТекущиеАргументы);
							Если Результат.Количество() > 0 Тогда
								ИмяТипаВыражения = Результат[Результат.Количество() - 1].Submatches(0);
								Если Найти(ИмяТипаВыражения, ".") > 0 Тогда
									ИмяТипаВыражения = ирОбщий.ИмяТипаИзПолногоИмениМДЛкс(ИмяТипаВыражения);
								КонецЕсли; 
								СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип(ИмяТипаВыражения));
								СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(СтруктураТипа.ИмяОбщегоТипа, ирОбщий.ПеревестиСтроку("Ссылка") + ".", ".");
								ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа); 
							КонецЕсли; 
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли;
			ИначеЕсли ЗначениеЗаполнено(ТекущееСлово) Тогда 
				ТипСлова = "Свойство";
				Если Истина
					И Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущиеАргументы) 
					И Не СтруктураТипа.ТипЯзыка = "ИмяТипа"
				Тогда
					// Это метод или функция
					Если ЭтоВызовКонструктора Тогда
						ТипСлова = "Конструктор";
					Иначе
						ТипСлова = "Метод";
					КонецЕсли; 
				КонецЕсли;
				мРегВыражение.Global = Истина;
				ШаблонКоллекции = "(" + шРазделитель + "+Из" + шРазделитель + "+(" + шИмяСкобки + "?" + шИндекс + "?" + "(\." + шИмяСкобки + "?" + шИндекс + "?)*))";
				мРегВыражение.Pattern = шПредИмя + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(Выражение) 
					+ "(" + шПрисваивание + "|" + ШаблонКоллекции + ")";
				РезультатТекста = мРегВыражение.НайтиВхождения(ТекстДляПоискаОпределения);
				Если РезультатТекста.Количество() > 0 Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					ИндексВхождения = РезультатТекста.Количество() - 1;
					ПоследнееВхождение = РезультатТекста[ИндексВхождения];
					// Пропускаем возможно присвоения и возможно сравнения на равенство литералам-именам
					Пока ИндексВхождения > 0 Цикл 
						Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(1)) Тогда 
							ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(2);
							Если Ложь
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "Неопределено")
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "Undefined") 
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "Null") 
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "Истина") 
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "True") 
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "Ложь") 
								Или ирОбщий.СтрокиРавныЛкс(ПрисвоенныйКонтекст, "False") 
								Или Не ЗначениеЗаполнено(ПрисвоенныйКонтекст) // пустое присвоение https://www.hostedredmine.com/issues/947747
							Тогда 
								ИндексВхождения = ИндексВхождения - 1;
								ПоследнееВхождение = РезультатТекста[ИндексВхождения];
								Продолжить;
							КонецЕсли;
						КонецЕсли;  
						Прервать;
					КонецЦикла;
					Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(1)) Тогда
						// Это присвоение
						ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(2);
						СловоНовый = НРег(ПоследнееВхождение.SubMatches(3));
						Если СловоНовый = Нрег("Новый") Или СловоНовый = Нрег("New") Тогда
							Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(4)) Тогда 
								ИмяТипа = ПоследнееВхождение.SubMatches(4);
							ИначеЕсли Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(5)) Тогда 
								ИмяТипа = ПоследнееВхождение.SubMatches(5);
							Иначе
								ИмяТипа = Неопределено;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяТипа) Тогда
								Попытка
									ТипНового = Тип(ИмяТипа);
								Исключение
									ТипНового = Неопределено;
									СтруктураТипа.ИмяОбщегоТипа = ИмяТипа;
								КонецПопытки;
								Если Истина
									И ТипНового = Тип("COMОбъект")
									И Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(5)) 
								Тогда
									ПолноеИмяОсновногоКлассаCOM = ПоследнееВхождение.SubMatches(5);
									СтруктураКОМТипа = мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM];
									Если СтруктураКОМТипа = Неопределено Тогда
										СтруктураКОМТипа = Новый Структура;
										МетаданныеСлова = мПлатформа.ПолучитьОбразецCOMОбъекта(ПолноеИмяОсновногоКлассаCOM); // При этом может открыться форма Automation-сервера например RegexBuddy так делает
										Если МетаданныеСлова = Неопределено Тогда
											ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
											ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
										Иначе
											ИмяОбщегоТипа = мПлатформа.ПолноеИмяТипаCOMОбъекта(МетаданныеСлова);
											Если ирОбщий.СтрокиРавныЛкс(ИмяОбщегоТипа, "COMОбъект") Тогда
												ИмяОсновногоКлассаCOM = ирОбщий.ПоследнийФрагментЛкс(ПолноеИмяОсновногоКлассаCOM);
												ИмяОбщегоТипа = ИмяОсновногоКлассаCOM + " {" + ПолноеИмяОсновногоКлассаCOM + "}";
											КонецЕсли; 
											СтруктураКОМТипа.Вставить("Метаданные", МетаданныеСлова);
										КонецЕсли; 
										СтруктураКОМТипа.Вставить("ИмяОбщегоТипа", ИмяОбщегоТипа); 
										мИменаОбщихТиповПоИменамКлассовCOM[ПолноеИмяОсновногоКлассаCOM] = СтруктураКОМТипа;
									КонецЕсли; 
									ЗаполнитьЗначенияСвойств(СтруктураТипа, СтруктураКОМТипа); 
								ИначеЕсли ТипНового <> Неопределено Тогда
									СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипНового, мЯзыкПрограммы);
								КонецЕсли;
							КонецЕсли; 
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						ИначеЕсли Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ПоследнееВхождение.SubMatches(6)) Тогда 
							ТаблицаСтруктурТипов = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),
								Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1), РазрешитьАнализИмениТипа,, ПолныйАнализ, Ложь);
							//Для Каждого СтруктураТипаЦикл Из ТаблицаСтруктурТипов Цикл
							//	СтруктураТипаЦикл.СтрокаОписания = Неопределено; // Зачем очищаем?
							//КонецЦикла;
						Иначе
							// **** TODO Сделать определение примитивного типа, но вычисляться будет долго и малополезно
							СтруктураТипа.ИмяОбщегоТипа = "Примитивный";
							мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						КонецЕсли;
					Иначе
						// Это обход коллекции
						ПрисвоенныйКонтекст = ПоследнееВхождение.SubMatches(15);
						// **** Раньше текст для поиска определения передавался неизменным. Тестовый режим
						ТаблицаСтруктурТиповКоллекции = ВычислитьТипЗначенияВыражения(ПрисвоенныйКонтекст, Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),
							Лев(ТекстДляПоискаОпределения, ПоследнееВхождение.FirstIndex - 1),,, ПолныйАнализ, Ложь);
						ТаблицаСтруктурТипов = мПлатформа.СвойстваТипаМетаданные(ТаблицаСтруктурТиповКоллекции[0], "[0]",,, мЯзыкПрограммы, "0",,, мФлагиКомпиляции)[0].ТаблицаСтруктурТипов;
					КонецЕсли;
					Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ТекущийИндекс) Тогда
						ТаблицаСтруктурРодителей = ТаблицаСтруктурТипов;
						ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
					КонецЕсли;
				КонецЕсли;
			Иначе
				Возврат ТаблицаСтруктурТипов;
			КонецЕсли;
			Если ТаблицаСтруктурРодителей.Количество() = 0 Тогда
				ТаблицаСтруктурРодителей = ВычислитьТипЗначенияВыражения(РодительскийКонтекст, ТекстДляПоискаОпределения, ПредшествующийТекст, РазрешитьАнализИмениТипа,, ПолныйАнализ, Ложь);
			КонецЕсли;
			МассивДочернихСтруктурТипа = ВычислитьТипДочернегоЭлемента(ТаблицаСтруктурРодителей, ТекущееСлово, ТипСлова, ТекущийИндекс, ТекущиеАргументы, ПредшествующийТекст, ПолныйАнализ);
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, МассивДочернихСтруктурТипа);
			Если ТипСлова = "Свойство" И Не СтруктураТипа.Конструктор Тогда
				ТекстДляЗаполненияМетаданных = ТекстДляПоискаОпределения;
				Для Каждого СтруктураТипаЦикл Из ТаблицаСтруктурТипов Цикл
					Если Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Структура"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ФиксированнаяСтруктура"
					Тогда
						мРегВыражение.Global = Ложь;
						ШаблонКонструкторСоСвойствами = Выражение + "\s*=\s*Новый\s+Структура\s*\(\s*""((?:" + шИмя + "\s*,\s*)*" + шИмя + ")""";
						мРегВыражение.Pattern = ШаблонКонструкторСоСвойствами;
						РезультатСвойств = мРегВыражение.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Если РезультатСвойств.Количество() > 0 Тогда
							СтруктураТипаЦикл.Метаданные = Новый Структура(РезультатСвойств[0].SubMatches(0));
						ИначеЕсли Истина
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("Структура") 
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ФиксированнаяСтруктура") 
						Тогда
							Если ТипЗнч(СтруктураТипаЦикл.Метаданные) = Тип("ПостроительЗапроса") Тогда
								СтруктураТипаЦикл.Метаданные = ПараметрыИзТекстаЗапроса(СтруктураТипаЦикл.Метаданные.Текст, Истина);
							Иначе
								СтруктураТипаЦикл.Метаданные = Новый Структура;
							КонецЕсли;
						КонецЕсли;
						ШаблонУстановкаТекста = Выражение + "\s*\.\s*Вставить\s*\(\s*""(" + шИмя + ")""";
						мРегВыражение.Pattern = ШаблонУстановкаТекста;
						мРегВыражение.Global = Истина;
						РезультатСвойств = мРегВыражение.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							СтруктураТипаЦикл.Метаданные.Вставить(ВхождениеСвойства.SubMatches(0));
						КонецЦикла;
						мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
					ИначеЕсли Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Массив"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ФиксированныйМассив"
					Тогда
						ШаблонУстановкаТекста = Выражение + "\s*\.\s*Добавить\s*\(\s*(.*?)\s*\)";
						мРегВыражение.Pattern = ШаблонУстановкаТекста;
						мРегВыражение.Global = Истина;
						РезультатСвойств = мРегВыражение.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						ИменаТиповЭлементов = Новый СписокЗначений;
						МаксЭлементов = 5;
						Счетчик = 1;
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							Если Счетчик > МаксЭлементов Тогда
								Прервать;
							КонецЕсли;
							Счетчик = Счетчик + 1;
							ТаблицаСтруктурТиповЭлементов = ВычислитьТипЗначенияВыражения(ВхождениеСвойства.SubMatches(0), ТекстДляПоискаОпределения, ПредшествующийТекст, РазрешитьАнализИмениТипа,
								ЭтоВызовКонструктора, ПолныйАнализ, Ложь);
							Для Каждого СтруктураТипаЭлемента Из ТаблицаСтруктурТиповЭлементов Цикл
								ИмяТипаЭлемента = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаЭлемента);
								Если ИмяТипаЭлемента <> "?" И ИменаТиповЭлементов.НайтиПоЗначению(ИмяТипаЭлемента) = Неопределено Тогда
									ИменаТиповЭлементов.Добавить(ИмяТипаЭлемента);
								КонецЕсли;
							КонецЦикла;
						КонецЦикла;
						Если ИменаТиповЭлементов.Количество() > 0 Тогда
							ИменаТиповЭлементов.СортироватьПоЗначению();
							СтруктураТипаЦикл.ИмяОбщегоТипа = СтруктураТипаЦикл.ИмяОбщегоТипа + "[" + ирОбщий.СтрСоединитьЛкс(ИменаТиповЭлементов.ВыгрузитьЗначения()) + "]";
						КонецЕсли;
						мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
					ИначеЕсли Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ТаблицаЗначений"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ДеревоЗначений"
					Тогда
						мРегВыражение.Global = Ложь;
						Если Истина
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ДеревоЗначений") 
							И ТипЗнч(СтруктураТипаЦикл.Метаданные) <> Тип("ТаблицаЗначений")
						Тогда
							СтруктураТипаЦикл.Метаданные = Новый ТаблицаЗначений;
						КонецЕсли;
						ШаблонУстановкаТекста = Выражение + "\s*\.\s*Колонки\s*.\s*Добавить\s*\(\s*""(" + шИмя + ")""";
						мРегВыражение.Pattern = ШаблонУстановкаТекста;
						мРегВыражение.Global = Истина;
						РезультатСвойств = мРегВыражение.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Колонки = СтруктураТипаЦикл.Метаданные.Колонки;
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							ИмяКолонки = ВхождениеСвойства.SubMatches(0);
							Попытка
								Колонки.Добавить(ИмяКолонки);
							Исключение
								Пустышка = 0;
							КонецПопытки; 
						КонецЦикла;
						мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
					ИначеЕсли Ложь
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "Запрос"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительЗапроса"
						Или СтруктураТипаЦикл.ИмяОбщегоТипа = "ПостроительОтчета"
					Тогда
						мРегВыражение.Global = Ложь;
						ШаблонУстановкаТекста = Выражение + "\s*\.\s*Текст\s*=\s*(" + шСтрокаПрограммы + ")";
						мРегВыражение.Pattern = ШаблонУстановкаТекста;
						мРегВыражение.Global = Истина;
						РезультатСвойств = мРегВыражение.НайтиВхождения(ТекстДляЗаполненияМетаданных);
						Для Каждого ВхождениеСвойства Из РезультатСвойств Цикл
							ПрисвоенноеЗначение = ВхождениеСвойства.SubMatches(0);
							Если Лев(ПрисвоенноеЗначение, 1) = """" Тогда
								Попытка
									ТекстЗапроса = Вычислить(ПрисвоенноеЗначение);
									Прервать;
								Исключение
									ТекстЗапроса = "";
								КонецПопытки;
							КонецЕсли;
						КонецЦикла;
						Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
							ПостроительЗапроса = Новый ПостроительЗапроса;
							Попытка
								ПостроительЗапроса.Текст = ТекстЗапроса;
								ПостроительЗапроса.ЗаполнитьНастройки();
							Исключение
								ПостроительЗапроса = Неопределено;
							КонецПопытки; 
							Если ПостроительЗапроса <> Неопределено Тогда
								СтруктураТипаЦикл.Метаданные = ПостроительЗапроса;
							КонецЕсли; 
						КонецЕсли; 
						мПлатформа.ОбновитьДетальностьСтруктурыТипа(СтруктураТипаЦикл);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
			Если Истина 
				И мЯзыкПрограммы = 1
				И РодительскийКонтекст = ""
				И СтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст"
				И МассивСтруктурПрисвоенныхТипов = Неопределено
			Тогда 
				Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда 
					ВременныйЗапрос = Новый Запрос;
					ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
					ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ТекущееСлово + " ГДЕ ЛОЖЬ";
					Попытка
						// Активное вычисление!
						СтруктураТипа.Метаданные = ВременныйЗапрос.Выполнить();
						СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
						СтруктураТипа.ВиртуальнаяТаблица.Выражение = ТекущееСлово; // Используем не по назначению
					Исключение
					КонецПопытки;
				Иначе
					СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ТекущееСлово);
					ТаблицаДоступныхПолей = ПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
					Если ТаблицаДоступныхПолей.Колонки.Найти("Заголовок") = Неопределено Тогда
						ТаблицаДоступныхПолей.Колонки.Добавить("Заголовок");
					КонецЕсли;
					СтруктураТипа.ИмяОбщегоТипа = "ВременнаяТаблица";
					СтруктураТипа.Метаданные = ирОбщий.УстановитьМетаданныеКоллекцииЛкс(ТаблицаДоступныхПолей);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	Если ТаблицаСтруктурТипов.Количество() = 0 Тогда
		мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЕсли;
	Возврат ТаблицаСтруктурТипов;

КонецФункции

Функция ПараметрыИзТекстаЗапроса(Знач ТекстЗапроса, Знач ВВидеСтруктуры = Ложь) Экспорт
	Запрос = Новый Запрос(ТекстЗапроса);
	Попытка
		ПараметрыЗапроса = Запрос.НайтиПараметры();
	Исключение
		ПараметрыЗапроса = Новый Массив;
	КонецПопытки;            
	Если ВВидеСтруктуры Тогда
		Результат = Новый Структура;
		Если ПараметрыЗапроса <> Неопределено Тогда
			Для Каждого ОписаниеПараметра Из ПараметрыЗапроса Цикл
				Результат.Вставить(ОписаниеПараметра.Имя);
			КонецЦикла;
		КонецЕсли;
	Иначе
		Результат = ПараметрыЗапроса;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура ОбновитьКонтекстВыраженияЗапросаПоНастройкеКомпоновкиЛкс(НастройкаКомпоновки) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		НастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	#КонецЕсли
	ОчиститьТаблицуСловЛокальногоКонтекста();
	Для Каждого ДоступноеПоле Из НастройкаКомпоновки.ДоступныеПоляОтбора.Элементы Цикл
		НрегПервыйФрагмент = ирОбщий.ПервыйФрагментЛкс(НРег(ДоступноеПоле.Поле));
		Если НрегПервыйФрагмент = НРег("ПараметрыДанных") Тогда
			Для Каждого ДоступныйПараметр Из ДоступноеПоле.Элементы Цикл
				ИмяСвойства = мПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПоследнийФрагментЛкс(ДоступныйПараметр.Поле);
				ДобавитьСловоЛокальногоКонтекста(ИмяСвойства, "Свойство", , ДоступныйПараметр,,,, "СтрокаТаблицы"); // Виртуальный тип
			КонецЦикла; 
		Иначе
			ДобавитьСловоЛокальногоКонтекста("" + ДоступноеПоле.Поле, "Свойство",, ДоступноеПоле,,,, "СтрокаТаблицы"); // Виртуальный тип
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура УстановитьПризнакМодифицированностиФормы()

	Если ПолеТекста.ЭлементФормы.ИзменяетДанные Тогда
		ФормаВладелец.Модифицированность = Истина;
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСтруктуруТипаСправаОтРавно() Экспорт 
	
	КончитьОбработкуКоманды();
	ТаблицаСтруктурТипов = ТаблицаСтруктурТиповТекущегоВыражения(Истина);
	КончитьОбработкуКоманды();
	СписокТиповКонтекста = Новый СписокЗначений;
	МассивДляПроверкиДублей = Новый Массив;
	Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТипов Цикл
		ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
		Если Ложь
			Или Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы) 
			Или ТипЗнч(СтруктураТипаКонтекста.Метаданные) <> Тип("ОбъектМетаданных")
			Или (Истина
				И ЯзыкПрограммы = 0
				И Найти(ИмяОбщегоТипа, "Ссылка.") = 0)
		Тогда 
			Продолжить;
		КонецЕсли;
		ПредставлениеКонкретногоТипа = "";
		ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
			СписокТиповКонтекста.Добавить(СтруктураТипаКонтекста, ПредставлениеКонкретногоТипа);
			МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
		КонецЕсли;
	КонецЦикла;
	Если СписокТиповКонтекста.Количество() > 0 Тогда
		Ответ = Вопрос("Хотите использовать предсказанные равенством метаданные?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли; 
	Если СписокТиповКонтекста.Количество() = 1 Тогда 
		ВыбраннаяСтруктураТипа = СписокТиповКонтекста[0].Значение;
		КонкретныйТип = СписокТиповКонтекста[0].Представление;
	ИначеЕсли СписокТиповКонтекста.Количество() > 1 Тогда
		СписокТиповКонтекста.СортироватьПоПредставлению();
		ВыбранныйТип = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста");
		Если ВыбранныйТип <> Неопределено Тогда
			ВыбраннаяСтруктураТипа = ВыбранныйТип.Значение;
			КонкретныйТип = ВыбранныйТип.Представление;
		КонецЕсли;
	КонецЕсли;
	//Если ВыбраннаяСтруктураТипа <> Неопределено Тогда
	//	СтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	//	ЗаполнитьЗначенияСвойств(СтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	//КонецЕсли;
	Возврат ВыбраннаяСтруктураТипа;

КонецФункции//ПолучитьСтруктуруТипаСправоОтРавно

Функция ТаблицаСтруктурТиповТекущегоВыражения(ЛиСправаОтРавенства = Ложь, БезКонструкторов = Ложь, ПолныйАнализ = Истина, Знач НомерСтроки = 0, Знач НомерКолонки = 0) Экспорт

	РазобратьТекущийКонтекст(ЛиСправаОтРавенства,,, НомерСтроки, НомерКолонки, Истина);
	лКонтекст = ?(ЛиСправаОтРавенства, мКонтекст, мРодительскийКонтекст);
	Если Истина
		И Не ЛиСправаОтРавенства 
		И Прав(мТекущаяСтрокаНачало, 1) = "." 
		И ПустаяСтрока(мРодительскийКонтекст) 
	Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	Попытка
		ТаблицаСтруктурТиповКонтекста = ВычислитьТипЗначенияВыражения(лКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина,, ПолныйАнализ);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат Новый ТаблицаЗначений;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	Если БезКонструкторов Тогда
		Для Каждого СтрокаТаблицы Из ТаблицаСтруктурТиповКонтекста.НайтиСтроки(Новый Структура("Конструктор", Истина)) Цикл
			ТаблицаСтруктурТиповКонтекста.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли; 
    Возврат ТаблицаСтруктурТиповКонтекста;
	
КонецФункции

Функция ПодготовитьИмяПараметраМетода(ИмяПараметра) Экспорт 
	
	//ирОбщий.ДекодироватьТекстИзXMLЛкс(СтрокаПараметра.Параметр);
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&gt;", "");
	ИмяПараметра = СтрЗаменить(ИмяПараметра, "&lt;", "");
	Возврат ИмяПараметра;

КонецФункции

// Вызывает контекстную подсказку в текстовом поле.
//
// Параметры:
//  Нет.
//
Процедура ОткрытьАвтодополнение(Знач КодКлавиши = "", Знач Модально = Ложь) Экспорт 
	
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(,, Истина) Тогда 
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	// Мультиметка00452941 Удаляем лишние точки истории из-за запоминания по нажатию CTRL
	УдалитьПоследнийПереходИзИстории();
	ФормаАвтодополнение = ФормаАвтодополнение();
	КодыКлавиш = ирКэш.КодыКлавишЛкс();
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец <> Неопределено И ФормаВладелец.ТолькоПросмотр     
		Или ФормаАвтодополнение.Открыта() И Не ЗначениеЗаполнено(КодКлавиши)
	Тогда
		Возврат;
	КонецЕсли;
	Если Истина
		//И Найти(КодКлавиши, "04128") = 1 // CTRL+SPACE
		И КодКлавиши = "" // Вызов из обработчика нажатия кнопки
		И ТипЗнч(ПолеТекста.ЭлементФормы) = Тип("ПолеHTMLДокумента")
		И ирКэш.НомерВерсииПлатформыЛкс() <= 803016
	Тогда
		// https://github.com/salexdv/bsl_console/issues/124
		ПолеТекста.РедакторHTML().triggerSuggestions();
		Возврат;
	КонецЕсли; 
	
	//Если Истина
	//	И ЯзыкПрограммы = 1
	//	И Не мДоступныеТаблицыПолучены 
	//Тогда
	//	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	Иначе
	//		ЗаполнитьДоступныеТаблицыADO(); // Может быть очень долго
	//		Для Каждого СтрокаДоступнойТаблицы Из ДоступныеТаблицы Цикл
	//			ДобавитьСловоЛокальногоКонтекста(СтрокаДоступнойТаблицы.Имя,,,, Истина,,, "ВременнаяТаблица");
	//		КонецЦикла; 
	//	КонецЕсли; 
	//КонецЕсли; 
	СтруктураТипаКонтекста = Неопределено;
	ТаблицаСтруктурТиповКонтекста = Неопределено;  
	Модально = Модально Или Не ЛиДоступноОткрытиеСвободнойФормы();
	Пока Истина Цикл
		Успешно = ЗаполнитьТаблицуСлов(ТаблицаСтруктурТиповКонтекста, мКонкретныйТипКонтекста, мСтруктураТипаКонтекста, Модально,,, Не ЗначениеЗаполнено(КодКлавиши));
		Если Не Успешно Тогда
			Возврат;
		КонецЕсли;
		Если Истина
			И ТаблицаСлов.Количество() = 0
			И Не ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ЛиОткрыватьПустойСписок") = Истина
		Тогда
			Возврат;
		КонецЕсли;
		КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", ЯзыкПрограммы, мКонкретныйТипКонтекста);
		НайденныеСтроки = мПлатформа.ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
		ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, Рейтинг");
		ТаблицаСловТЗ.Индексы.Добавить("НСлово");
		Для Каждого СтрокаРейтинга Из НайденныеСтроки Цикл
			СтрокаСлова = ТаблицаСловТЗ.Найти(НРег(СтрокаРейтинга.Слово), "НСлово");
			Если СтрокаСлова <> Неопределено Тогда
				СтрокаСлова.Рейтинг = СтрокаРейтинга.Рейтинг;
			КонецЕсли;
		КонецЦикла;
		ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Рейтинг"), "Рейтинг");
		Попытка
			ФормаАвтодополнение.СтруктураТипаКонтекста = мСтруктураТипаКонтекста;
		Исключение
			ВызватьИсключение "Экземпляр формы автодополнения контекстной подсказки сломан ошибкой платформы. Переоткройте форму чтобы восстановить ее работу";
		КонецПопытки;
		Если ЗначениеЗаполнено(мСтруктураТипаКонтекста.ТипЯзыка) Тогда
			ФормаАвтодополнение.Контекст = мСтруктураТипаКонтекста.ТипЯзыка;
		Иначе
			ФормаАвтодополнение.Контекст = мРодительскийКонтекст;
		КонецЕсли; 
		Если ФормаАвтодополнение.Открыта() Тогда
			// Иначе будет считана некорректная позиция окна 
			ФормаАвтодополнение.Закрыть();
		КонецЕсли;
		ФормаАвтодополнение.ЗапомнитьПозициюКаретки();
		Если ФормаВладелец <> Неопределено Тогда
			ФормаВладелец.Активизировать(); 
		КонецЕсли;
		//ирКлиент.Форма_АктивироватьОткрытьЛкс(ФормаВладелец); // https://www.hostedredmine.com/issues/911214
		Если Модально Тогда
			ФормаАвтодополнение.ТекущееСлово = мНачалоСлова;
			ПараметрЗакрытияПодсказки = ФормаАвтодополнение.ОткрытьМодально();
		Иначе
			ПараметрЗакрытияПодсказки = Неопределено;
			ФормаАвтодополнение.Открыть();
		КонецЕсли;
		Если ПараметрЗакрытияПодсказки = Неопределено Тогда
			Возврат;
		КонецЕсли; 
		СтрокаРезультата = ФормаАвтодополнение.СтрокаСловаРезультата;
		Если СтрокаРезультата = Неопределено Тогда
			Возврат;
		КонецЕсли;
		ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаСтруктурТиповКонтекста, ПараметрЗакрытияПодсказки);
	КонецЦикла;

КонецПроцедуры

// Возвращаемое значение:
//    Форма - 
Функция ФормаАвтодополнение() Экспорт
	Если мФормаАвтодополнение = Неопределено Тогда
		Если Ложь
			Или Не ирКэш.ЛиПлатформаWindowsЛкс()
			Или ирКлиент.ЛиПерехватКлавиатурногоВводаЛкс() 
		Тогда
			ИмяФормы = "Автодополнение";
		Иначе
			ИмяФормы = "АвтодополнениеCOM";
		КонецЕсли; 
		мФормаАвтодополнение = ПолучитьФорму(ИмяФормы, ФормаВладелец);
		мФормаАвтодополнение.КлючСохраненияПоложенияОкна = ЯзыкПрограммы;
	КонецЕсли;
	Возврат мФормаАвтодополнение;
КонецФункции

Процедура УдалитьПоследнийПереходИзИстории()
	
	Если мИсторияПереходов <> Неопределено И мИсторияПереходов.Количество() > 0 Тогда
		мИсторияПереходов.Удалить(0); 
	КонецЕсли;

КонецПроцедуры

Функция ЗаполнитьТаблицуСлов(ТаблицаСтруктурТиповКонтекста = Неопределено, выхКонкретныйТип = Неопределено, выхСтруктураТипаКонтекста = Неопределено, РазрешитьОткрытиеОкон = Истина,
	Знач УдалитьФункциюНовый = Ложь, Знач Сортировать = Истина, Знач ДобавлятьНизкоВероятные = Ложь) Экспорт
	
	ВычислятьТипы = ПоказыватьВсеТипыВСпискеАвтодополненияHTML();
	мРегВыражение.Global = Истина;
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	#Если Сервер И Не Сервер Тогда
		ТаблицаСтатистикиВыбора = Новый ТаблицаЗначений;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ТаблицаСтруктурТиповКонтекста = Неопределено Тогда
		ТаблицаСтруктурТиповКонтекста = ТаблицаСтруктурТиповТекущегоВыражения();
	КонецЕсли; 
	Если ТаблицаСтруктурТиповКонтекста.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли; 
	ТаблицаСлов.Очистить();
	мЭтоЛокальныйКонтекстТаблицыСлов = Ложь;
	Если мЭтоСтроковыйЛитерал Тогда
		ВыбраннаяСтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
		Если ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "Локальный" Тогда
			мЭтоЛокальныйКонтекстТаблицыСлов = Истина;
		КонецЕсли;
	Иначе
		СписокТиповКонтекста = Новый СписокЗначений;
		СоответствиеСтруктурТипов = Новый Соответствие;
		МассивДляПроверкиДублей = Новый Массив;
		ТаблицаСтруктурТиповКонтекста.Сортировать("Детальность Убыв");
		Для Каждого СтруктураТипаКонтекста Из ТаблицаСтруктурТиповКонтекста Цикл
			ИмяОбщегоТипа = СтруктураТипаКонтекста.ИмяОбщегоТипа;
			Если ИмяОбщегоТипа = "Локальный" Тогда
				мЭтоЛокальныйКонтекстТаблицыСлов = Истина;
			КонецЕсли;
			Если Истина
				И Не ЗначениеЗаполнено(СтруктураТипаКонтекста.ТипЯзыка) 
				И Не мПлатформа.ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, мЯзыкПрограммы) 
			Тогда 
				Продолжить;
			КонецЕсли;
			ПредставлениеКонкретногоТипа = "";
			//Если СтруктураТипаКонтекста.СтрокаОписания <> Неопределено Тогда
			//	// Наверное логичнее было бы из ВычислитьТипЗначенияВыражения ее получать
			//	РодительскаяСтруктураТипа = мПлатформа.НоваяСтруктураТипа();
			//	Если СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено Тогда
			//		ЗаполнитьЗначенияСвойств(РодительскаяСтруктураТипа, СтруктураТипаКонтекста);
			//		РодительскаяСтруктураТипа.ИмяОбщегоТипа = СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста;
			//	КонецЕсли;
			//	ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа 
			//		+ мПлатформа.ИмяТипаИзСтруктурыТипа(РодительскаяСтруктураТипа) + " / ";
			//КонецЕсли;
			ПредставлениеКонкретногоТипа = ПредставлениеКонкретногоТипа + мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
			Если МассивДляПроверкиДублей.Найти(ПредставлениеКонкретногоТипа) = Неопределено Тогда
				СписокТиповКонтекста.Добавить(ПредставлениеКонкретногоТипа, ПредставлениеКонкретногоТипа + " [" + СтруктураТипаКонтекста.Детальность + "]");
				МассивДляПроверкиДублей.Добавить(ПредставлениеКонкретногоТипа);
			КонецЕсли;
			МассивСтруктурТипа = СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа];
			Если МассивСтруктурТипа = Неопределено Тогда
				МассивСтруктурТипа = Новый Массив;
			КонецЕсли; 
			МассивСтруктурТипа.Добавить(СтруктураТипаКонтекста);
			СоответствиеСтруктурТипов[ПредставлениеКонкретногоТипа] = МассивСтруктурТипа;
		КонецЦикла;
		Если СписокТиповКонтекста.Количество() = 0 Тогда 
			ВыбраннаяСтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
			выхКонкретныйТип = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипаКонтекста);
		Иначе
			ВыбраннаяСтруктураТипа = Неопределено;
			Если СписокТиповКонтекста.Количество() > 1 И РазрешитьОткрытиеОкон Тогда
				СписокТиповКонтекста.СортироватьПоПредставлению();
				НачальныйВыбор = Неопределено;
				КлючПоискаСтатистики = Новый Структура("ЯзыкПрограммы, ТипКонтекста", мЯзыкПрограммы, "<Выбор типа>");
				ВыбранныеРанееТипы = ТаблицаСтатистикиВыбора.Скопировать(КлючПоискаСтатистики);
				ВыбранныеРанееТипы.Сортировать("Рейтинг Убыв");
				Для Каждого СтрокаТипа Из ВыбранныеРанееТипы Цикл
					Для Каждого ЭлементСписка Из СписокТиповКонтекста Цикл
						Если СтрокаТипа.Слово = ЭлементСписка.Представление Тогда
							НачальныйВыбор = ЭлементСписка;
							Прервать;
						КонецЕсли; 
					КонецЦикла;
					Если НачальныйВыбор <> Неопределено Тогда
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				ВыбранныйЭлементСписка = СписокТиповКонтекста.ВыбратьЭлемент("Выберите тип контекста", НачальныйВыбор);
				Если ВыбранныйЭлементСписка = Неопределено Тогда
					Возврат Ложь;
				КонецЕсли;
				выхКонкретныйТип = ВыбранныйЭлементСписка.Значение;
				// Обновим статистику выбора
				КлючПоискаСтатистики.Вставить("Слово", выхКонкретныйТип);
				НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоискаСтатистики);
				Если НайденныеСтроки.Количество() > 0 Тогда
					СтрокаСтатистикиВыбора = НайденныеСтроки[0];
				Иначе
					СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоискаСтатистики);
				КонецЕсли;
				СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
			Иначе
				// TODO объединить все типы контекста
				ВыбранныйЭлементСписка = СписокТиповКонтекста[0];
				выхКонкретныйТип = ВыбранныйЭлементСписка.Значение;
			КонецЕсли;
			МассивСтруктурТипа = СоответствиеСтруктурТипов[выхКонкретныйТип];
			Для Каждого СтруктураТипа Из МассивСтруктурТипа Цикл
				Если Ложь
					Или ВыбраннаяСтруктураТипа = Неопределено 
					Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданныхКонфигурация")
				Тогда
					ВыбраннаяСтруктураТипа = СтруктураТипа;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	выхСтруктураТипаКонтекста = мПлатформа.НоваяСтруктураТипа();
	Если мЭтоСтроковыйЛитерал И ВыбраннаяСтруктураТипа.ТипЯзыка <> "ИмяТипа" Тогда
		// Находимся внутри строкового литерала на позиции параметра
		СтрокаОписанияМетода = ВыбраннаяСтруктураТипа.СтрокаОписания;
		КоллекцияЭлементовМД = Новый Массив;
		Если Истина
			И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
			И СтрокаОписанияМетода.Владелец().Колонки.Найти("ЛиЭкспорт") = Неопределено
		Тогда 
			ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
			
			// Имена свойств
			Если Ложь
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ТаблицаЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ДеревоЗначений")
				Или ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("РезультатЗапроса") 
			Тогда
				КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Колонки;
			ИначеЕсли Истина
				И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("Структура") 
				И ИмяПараметра = "Ключ" 
			Тогда 
				КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ВыбраннаяСтруктураТипа.Метаданные);
			ИначеЕсли ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ОбъектМетаданных") Тогда 
				Если ИмяПараметра = "Макет" Тогда
					КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Макеты;
				ИначеЕсли ИмяПараметра = "Форма" Тогда
					КоллекцияЭлементовМД = ВыбраннаяСтруктураТипа.Метаданные.Формы;
				Иначе
					ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(ВыбраннаяСтруктураТипа.Метаданные.ПолноеИмя());
					Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
						КоллекцияЭлементовМД = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
					КонецЕсли; 
				КонецЕсли; 
			ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
				ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
				Для Каждого Пользователь Из ПользователиИБ Цикл
					КоллекцияЭлементовМД.Добавить(Пользователь.Имя);
				КонецЦикла;
			ИначеЕсли ИмяПараметра = "Роль" Тогда 
				КоллекцияЭлементовМД = Метаданные.Роли;
			ИначеЕсли ИмяПараметра = "ИмяПользователяИБ" Тогда 
				ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
				Для Каждого Пользователь Из ПользователиИБ Цикл
					КоллекцияЭлементовМД.Добавить(Пользователь.Имя);
				КонецЦикла;
			ИначеЕсли ИмяПараметра = "ОбщийМакет" Тогда 
				КоллекцияЭлементовМД = Метаданные.ОбщиеМакеты;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.Слово = "ПолучитьОбщуюФорму" 
				И ИмяПараметра = "Форма"
			Тогда
				КоллекцияЭлементовМД = Метаданные.ОбщиеФормы;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.Слово = "УстановитьПараметр" 
				И ИмяПараметра = "Имя"
				И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
			Тогда
				КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ПараметрыИзТекстаЗапроса(ВыбраннаяСтруктураТипа.Метаданные.Текст));
			ИначеЕсли Истина
				И СтрокаОписанияМетода.Слово = "НайтиПредопределенное" 
				И СтрокаОписанияМетода.ТипКонтекста = "МенеджерРегламентныхЗаданий" 
				И ИмяПараметра = "Метаданные"
			Тогда
				КоллекцияЭлементовМД = Метаданные.РегламентныеЗадания;
			ИначеЕсли Истина
				И СтрокаОписанияМетода.Слово = "ПравоДоступа" 
				И  ИмяПараметра = "Право"
			Тогда
				КоллекцияЭлементовМД = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ВидыПравДоступа"));
			ИначеЕсли Истина
				И СтрокаОписанияМетода.Слово = "ЗаполнитьЗначенияСвойств" 
				И (Ложь
					Или ИмяПараметра = "СписокСвойств"
					Или ИмяПараметра = "ИсключаяСвойства")
			Тогда
				СтруктураТипаПараметра = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения);
				КоллекцияЭлементовМД = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаПараметра[0]).Скопировать(Новый Структура("ТипСлова", "Свойство")).ВыгрузитьКолонку("Слово");
			ИначеЕсли Истина
				И (Ложь
					Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпцию" 
					Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюИнтерфейса"
					Или СтрокаОписанияМетода.Слово = "ПолучитьФункциональнуюОпциюФормы")
				И ИмяПараметра = "Имя"
			Тогда
				КоллекцияЭлементовМД = Метаданные.ФункциональныеОпции;
			ИначеЕсли Ложь
				Или ИмяПараметра = "ИмяПроцедуры"
				Или ИмяПараметра = "Действие"
			Тогда
				ОтобранныеМетоды = мМодульМетаданных.Методы;
				Если СтрокаОписанияМетода.ТипКонтекста = "ОписаниеОповещения" Тогда 
					ОтобранныеМетоды = ОтобранныеМетоды.НайтиСтроки(Новый Структура("ЛиЭкспорт", Истина));
				КонецЕсли;
				КоллекцияЭлементовМД = ирОбщий.ВыгрузитьСвойствоКоллекцииЛкс(ОтобранныеМетоды);
			ИначеЕсли Истина
				И ТипЗнч(ВыбраннаяСтруктураТипа.Метаданные) = Тип("ПостроительЗапроса")
				И (Ложь
					Или ИмяПараметра = "ПутьКДанным"
					Или ИмяПараметра = "Описание")
			Тогда
				ИмяПараметра = "ПутьКДанным";
				ПостроительЗапроса = ВыбраннаяСтруктураТипа.Метаданные;
				#Если Сервер И Не Сервер Тогда
					ПостроительЗапроса = Новый ПостроительЗапроса;
				#КонецЕсли
				КоллекцияЭлементовМД = ПостроительЗапроса.ДоступныеПоля;
			КонецЕсли; 
			ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
		ИначеЕсли Истина
			И ТипЗнч(СтрокаОписанияМетода) = Тип("СтрокаТаблицыЗначений")
			И СтрокаОписанияМетода.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено
		Тогда 
			ИмяПараметра = ИмяПараметраВызоваМетода(СтрокаОписанияМетода);
			Если ЗначениеЗаполнено(ИмяПараметра) Тогда 
				Если Истина
					И Найти(ИмяПараметра, "Реквизит") > 0
					И Найти(СтрокаОписанияМетода.Имя, "Значен") > 0
					И Найти(СтрокаОписанияМетода.Имя, "Реквизит") > 0
				Тогда
					// БСП https://www.hostedredmine.com/issues/966675
					СтруктураТипаСсылки = ВычислитьТипЗначенияВыражения(мПервыйФактическийПараметр, мТекстДляПоискаОпределения)[0];
					Если ТипЗнч(СтруктураТипаСсылки.Метаданные) = Тип("ОбъектМетаданных") Тогда
						ИмяТаблицыБД = ирКэш.ИмяТаблицыИзМетаданныхЛкс(СтруктураТипаСсылки.Метаданные.ПолноеИмя());
						Если ЗначениеЗаполнено(ИмяТаблицыБД) Тогда
							КоллекцияЭлементовМД = ирОбщий.ПоляТаблицыБДЛкс(ИмяТаблицыБД);
							ИмяПараметра = "ИмяРеквизита";
						КонецЕсли; 
					КонецЕсли;
				ИначеЕсли Ложь
					Или ИмяПараметра = "ПолноеИмяМД"
				Тогда
					// TODO 
				КонецЕсли;
				ВыбраннаяСтруктураТипа.ТипЯзыка = ИмяПараметра;
			КонецЕсли;
		КонецЕсли; 
		выхСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
		Если Ложь
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетода"
			Или Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст) <> Неопределено
		Тогда
			// Полное имя метода
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				выхСтруктураТипаКонтекста.ТипЯзыка = "ИмяМетода";
				выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ОбщийМодуль";
				выхСтруктураТипаКонтекста.Метаданные = Метаданные.ОбщиеМодули.Найти(мРодительскийКонтекст);
				ВнутренняяТаблицаСлов = мПлатформа.СвойстваТипаМетаданные(выхСтруктураТипаКонтекста,, "Метод",,,,,, Новый Структура("Сервер", Истина));
				ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(ВнутренняяТаблицаСлов, ТаблицаСлов);
			Иначе
				КоллекцияЭлементовМД = Новый Массив; 
				Для Каждого КлючИЗначение Из ирКэш.ДоступныеОбщиеМодулиЛкс(Истина, Ложь, Ложь) Цикл
					КоллекцияЭлементовМД.Добавить(КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли; 
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяПредопределенногоЗначения" Тогда
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				ТаблицаТиповМетаОбъектов = ирКэш.ТипыМетаОбъектов(Ложь);
				КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
				КоллекцияЭлементовМД.Добавить("ПустаяСсылка");
				Если Найти(мРодительскийКонтекст, ".") > 0 Тогда
					ОбъектМД = Метаданные.НайтиПоПолномуИмени(мРодительскийКонтекст);
					Если ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Перечисления.ABCКлассификация;
						#КонецЕсли
						Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
							КоллекцияЭлементовМД.Добавить(ЗначениеПеречисления.Имя);
						КонецЦикла;
					Иначе
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
						#КонецЕсли
						Если Истина
							И ирКэш.НомерВерсииПлатформыЛкс() > 803004 
							И ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) 
						Тогда
							Для Каждого ИмяЭлемента Из ОбъектМД.ПолучитьИменаПредопределенных() Цикл
								КоллекцияЭлементовМД.Добавить(ИмяЭлемента);
							КонецЦикла;
						КонецЕсли; 
					КонецЕсли; 
				Иначе
					МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
					Если МножественноеИмяМД <> Неопределено Тогда
						Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
							КоллекцияЭлементовМД.Добавить(МетаОбъект);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
					Если Ложь
						Или ирОбщий.ЛиКорневойТипПеречисленияЛкс(СтрокаТипаМетаОбъекта.Единственное)
						Или ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(СтрокаТипаМетаОбъекта.Единственное) 
					Тогда
						КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли Ложь
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" 
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0
			Или Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ПолноеИмя") > 0  
			Или ЗначениеЗаполнено(ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст)))
			Или ВыбраннаяСтруктураТипа.ТипЯзыка = "" И ДобавлятьНизкоВероятные
		Тогда
			Если ВыбраннаяСтруктураТипа.ТипЯзыка = "Местоположение" Тогда
				ИмяДочернегоТипаМД = "Макет";
				ИмяКорневогоТипаМД = "ОбщийМакет";
			ИначеЕсли Найти(ВыбраннаяСтруктураТипа.ТипЯзыка, "ИмяФормы") > 0 Тогда 
				ИмяДочернегоТипаМД = "Форма";
				ИмяКорневогоТипаМД = "ОбщаяФорма";
			Иначе
				Если ЗначениеЗаполнено(ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст))) Тогда 
					ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяМетаданных";
					выхСтруктураТипаКонтекста.ТипЯзыка = ВыбраннаяСтруктураТипа.ТипЯзыка;
				КонецЕсли;
				ИмяКорневогоТипаМД = "";
				ИмяДочернегоТипаМД = "";
			КонецЕсли; 
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				Если ирОбщий.СтрокиРавныЛкс(ИмяКорневогоТипаМД, ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст)) Тогда
					Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
						Для Каждого МетаМакет Из Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяКорневогоТипаМД)] Цикл
							КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
						КонецЦикла;
					КонецЕсли; 
				Иначе
					Если СтрЧислоВхождений(мРодительскийКонтекст, ".") = 0 Тогда
						КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
						МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
						Если МножественноеИмяМД <> Неопределено Тогда
							Попытка
								КоллекцияМД = Метаданные[МножественноеИмяМД];
							Исключение
								КоллекцияМД = Новый Массив;
							КонецПопытки;
							Для Каждого МетаОбъект Из КоллекцияМД Цикл
								КоллекцияЭлементовМД.Добавить(МетаОбъект);
							КонецЦикла;
						КонецЕсли; 
					ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 Тогда
						Если ЗначениеЗаполнено(ИмяДочернегоТипаМД) Тогда
							КоллекцияЭлементовМД.Добавить(ИмяДочернегоТипаМД);
						Иначе
							ТипыДочерние = ирКэш.ТипыМетаОбъектов().НайтиСтроки(Новый Структура("Категория", 2));
							Для Каждого СтрокаТипаМетаОбъекта Из ТипыДочерние Цикл
								ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
									"ОбъектМетаданных: " + ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст), 0, "", НРег(СтрокаТипаМетаОбъекта.Множественное), "Свойство");
								Если мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() = 0 Тогда 
									Продолжить;
								КонецЕсли;
								КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
							КонецЦикла;
						КонецЕсли;
					ИначеЕсли СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 Тогда
						ОбъектМД = Метаданные.НайтиПоПолномуИмени(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст, "."));
						#Если Сервер И Не Сервер Тогда
							ОбъектМД = Метаданные.Справочники.Валюты;
						#КонецЕсли
						Если ОбъектМД <> Неопределено Тогда
							Для Каждого МетаМакет Из ОбъектМД[ирОбщий.МножественноеИмяМДЛкс(ирОбщий.ПоследнийФрагментЛкс(мРодительскийКонтекст))] Цикл
								КоллекцияЭлементовМД.Добавить(МетаМакет.Имя);
							КонецЦикла;
						КонецЕсли;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Истина, Ложь) Цикл
					НадоДобавить = Не ЗначениеЗаполнено(ИмяКорневогоТипаМД);
					Если Не НадоДобавить Тогда
						НадоДобавить = ирОбщий.СтрокиРавныЛкс(ИмяКорневогоТипаМД, СтрокаТипаМетаОбъекта.Единственное);
					КонецЕсли;
					Если Не НадоДобавить Тогда
						ОтборСвойств = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова", 
							"ОбъектМетаданных: " + СтрокаТипаМетаОбъекта.Единственное, 0, "", НРег(ирОбщий.МножественноеИмяМДЛкс(ИмяДочернегоТипаМД)), "Свойство");
						НадоДобавить = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(ОтборСвойств).Количество() > 0;
					КонецЕсли; 
					Если НадоДобавить Тогда 
						КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПространствоБлокировки" Тогда
			КоллекцияЭлементовМД = Новый Массив;
			Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
				КорневойТип = ирОбщий.ПервыйФрагментЛкс(мРодительскийКонтекст);
				ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
				Если Истина
					И ЭтоТаблицаВнешнейБД
					И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 1 
				Тогда
					КоллекцияЭлементовМД.Добавить("Таблица");
				ИначеЕсли Истина
					И ЭтоТаблицаВнешнейБД
					И СтрЧислоВхождений(мРодительскийКонтекст, ".") = 2 
				Тогда
					Для Каждого МетаОбъект Из ирКэш.ОбъектМДПоПолномуИмениЛкс(ирОбщий.СтрокаБезПоследнегоФрагментаЛкс(мРодительскийКонтекст)).Таблицы Цикл
						КоллекцияЭлементовМД.Добавить(МетаОбъект.Имя);
					КонецЦикла; 
				ИначеЕсли Найти(мРодительскийКонтекст, ".") > 0 Тогда
					Если ирОбщий.ЛиКорневойТипРегистраБДЛкс(КорневойТип) Тогда
						КоллекцияЭлементовМД.Добавить("НаборЗаписей");
					КонецЕсли; 
					Если ирОбщий.ЛиКорневойТипПоследовательностиЛкс(КорневойТип) Тогда
						КоллекцияЭлементовМД.Добавить("Записи");
					КонецЕсли; 
				Иначе
					МножественноеИмяМД = ирОбщий.МножественноеИмяМДЛкс(КорневойТип);
					Если МножественноеИмяМД <> Неопределено Тогда
						Для Каждого МетаОбъект Из Метаданные[МножественноеИмяМД] Цикл
							КоллекцияЭлементовМД.Добавить(МетаОбъект);
						КонецЦикла;
					КонецЕсли; 
				КонецЕсли; 
			Иначе
				Для Каждого СтрокаТипаМетаОбъекта Из ирКэш.ТипыМетаОбъектов(Ложь, Ложь, Ложь) Цикл
					КоллекцияЭлементовМД.Добавить(СтрокаТипаМетаОбъекта.Единственное);
				КонецЦикла;
			КонецЕсли;  
		ИначеЕсли ВыбраннаяСтруктураТипа.ТипЯзыка = "ПолеПространстваБлокировок" Тогда
			ПространствоБлокировки = ВыбраннаяСтруктураТипа.Метаданные;
			КорневойТип = ирОбщий.ПервыйФрагментЛкс(ПространствоБлокировки);
			ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ПространствоБлокировки);
			ЭтоТаблицаВнешнейБД = ирОбщий.ЛиКорневойТипВнешнегоИсточникаДанныхЛкс(КорневойТип);
			Если ирОбщий.ЛиМетаданныеСсылочногоОбъектаЛкс(ОбъектМД) Тогда
				КоллекцияЭлементовМД.Добавить("Ссылка");
				Если ОбъектМД <> Неопределено Тогда
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.Справочники.Пользователи;
					#КонецЕсли
					Для Каждого ПолеБлокировки Из ОбъектМД.ПоляБлокировкиДанных Цикл
						КоллекцияЭлементовМД.Добавить(ПолеБлокировки.Имя);
					КонецЦикла;
				КонецЕсли; 
			Иначе
				Если ОбъектМД <> Неопределено Тогда
					#Если Сервер И Не Сервер Тогда
						ОбъектМД = Метаданные.РегистрыСведений.КурсыВалют;
					#КонецЕсли
					Если Найти(ПространствоБлокировки, "." + "НаборЗаписей") > 0 Тогда
						СтруктураКлюча = ирОбщий.СтруктураКлючаТаблицыБДЛкс(ирКэш.ИмяТаблицыИзМетаданныхЛкс(ОбъектМД.ПолноеИмя()), Ложь);
					Иначе
						СтруктураКлюча = Новый Структура;
						Если ирОбщий.ЛиКорневойТипРегистраСведенийЛкс(КорневойТип) Тогда
							Если ОбъектМД.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
								СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Период"));
							КонецЕсли; 
							Если ОбъектМД.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
								СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("Регистратор"));
							КонецЕсли; 
						КонецЕсли; 
						Если ирОбщий.ЛиКорневойТипРегистраРасчетаЛкс(КорневойТип) Тогда
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодРегистрации"));
							СтруктураКлюча.Вставить(ирОбщий.ПеревестиСтроку("ПериодДействия"));
						КонецЕсли; 
						Если ЭтоТаблицаВнешнейБД Тогда
							Для Каждого ПолеКлюча Из ОбъектМД.ПоляКлюча Цикл
								СтруктураКлюча.Вставить(ПолеКлюча.Имя);
							КонецЦикла;
						Иначе
							Для Каждого Измерение Из ОбъектМД.Измерения Цикл
								СтруктураКлюча.Вставить(Измерение.Имя);
							КонецЦикла;
						КонецЕсли; 
					КонецЕсли; 
					Для Каждого КлючИЗначение Из СтруктураКлюча Цикл
						КоллекцияЭлементовМД.Добавить(КлючИЗначение.Ключ);
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Истина
			И ирОбщий.СтрокиРавныЛкс(мИмяМетодаВызова, "COMОбъект") 
			И мНомерПараметра = 1 
			И ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "Неизвестный контекст"
		Тогда
			Если МассивКОМКлассов = Неопределено Тогда
				Компьютер = "localhost";
				МассивКОМКлассов = Новый Массив;
				КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
				КаталогПриложений.Connect(Компьютер);
				Компоненты = КаталогПриложений.GetCollection("InprocServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
				Компоненты = КаталогПриложений.GetCollection("WOWLegacyServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
				Компоненты = КаталогПриложений.GetCollection("LegacyServers");
				Компоненты.Populate();
				ДобавитьCOMКлассыВСписокСлов(МассивКомКлассов, Компоненты);
			КонецЕсли; 
			КоллекцияЭлементовМД = МассивКОМКлассов;
		КонецЕсли; 
		выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
		Для Каждого ЭлементКоллекцииМД Из КоллекцияЭлементовМД Цикл
			СтрокаСлова = ТаблицаСлов.Добавить();
			Если ТипЗнч(ЭлементКоллекцииМД) = Тип("Строка") Тогда
				СтрокаСлова.Слово = ЭлементКоллекцииМД;
			Иначе
				СтрокаСлова.Слово = ЭлементКоллекцииМД.Имя;
			КонецЕсли; 
			СтрокаСлова.ТипСлова = "Свойство";
			СтрокаСлова.Определение = "Метаданные";
			СтрокаСлова.ТипЗначения = "Строка";
		КонецЦикла; 
	ИначеЕсли Истина
		И мЭтоСтроковыйЛитерал 
		И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа" 
		И мИмяМетодаВызова = "Тип"
	Тогда 
		ПолеТекстаПрограммыВызова = КопияКомпоненты();
		#Если Сервер И Не Сервер Тогда
			ПолеТекстаПрограммыВызова = Обработки.ирКлсПолеТекстаПрограммы.Создать();
		#КонецЕсли
		ПолеТекстаПрограммыВызова.РазобратьТекущийКонтекст(,, Истина, мНачальнаяСтрока, мНачальнаяКолонка - СтрДлина(мВызовМетода + мНачалоСлова), Истина);
		Если Истина
			И ПолеТекстаПрограммыВызова.мИмяМетодаВызова = "Добавить" 
			И ПолеТекстаПрограммыВызова.мНомерПараметра = 1
		Тогда 
			ТаблицаСтруктурТипов = ПолеТекстаПрограммыВызова.ВычислитьТипЗначенияВыражения(ПолеТекстаПрограммыВызова.мВызовМетода, ПолеТекстаПрограммыВызова.мТекстДляПоискаОпределения);
			Если ТаблицаСтруктурТипов.Количество() > 1 Тогда
				выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Строка";
				выхСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа";
				ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
				Для Каждого СтруктураТипаЭлемента Из ТаблицаСтруктурТипов Цикл
					СтрокаСлова = ТаблицаСлов.Добавить();
					СтрокаСлова.Слово = СтруктураТипаЭлемента.ИмяОбщегоТипа;
					СтрокаСлова.ТипСлова = "Свойство";
					СтрокаСлова.Определение = "Предопределенный";
				КонецЦикла; 
			КонецЕсли;
		КонецЕсли; 
		Если ТаблицаСлов.Количество() = 0 Тогда
			ЗаполнитьЗначенияСвойств(выхСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
		КонецЕсли;
	Иначе
		Если Истина
			И мЯзыкПрограммы = 1 
			И (Ложь
				Или мЭтоЛокальныйКонтекстТаблицыСлов
				Или ВыбраннаяСтруктураТипа.ИмяОбщегоТипа = "")
		Тогда 
			Если Истина
				И ВыбраннаяСтруктураТипа.ТипЯзыка = "ИмяТипа"
				И Не мТолькоСсылочныеИменаТипов
			Тогда
				ИменаФиксированныхТипов = Новый Массив;
				ИменаФиксированныхТипов.Добавить("БУЛЕВО");
				ИменаФиксированныхТипов.Добавить("ДАТА");
				ИменаФиксированныхТипов.Добавить("СТРОКА");
				ИменаФиксированныхТипов.Добавить("ЧИСЛО");
				Для Каждого ЭлементКоллекцииМД Из ИменаФиксированныхТипов Цикл
					СтрокаСлова = ТаблицаСлов.Добавить();
					СтрокаСлова.Слово = ЭлементКоллекцииМД;
					СтрокаСлова.ТипСлова = "Свойство";
					СтрокаСлова.Определение = "Предопределенный";
					СтрокаСлова.ТипЗначения = "Тип";
				КонецЦикла;
			КонецЕсли; 
			Если ВыбраннаяСтруктураТипа.ТипЯзыка = "" Тогда
				Для Каждого ОписаниеТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип, Схема", "ВременнаяТаблица", "")) Цикл
					СтрокаСлова = ТаблицаСлов.Добавить();
					СтрокаСлова.Слово = ОписаниеТаблицы.Имя;
					СтрокаСлова.ТипСлова = "Свойство";
					СтрокаСлова.Определение = "Локальный";
					СтрокаСлова.ТипЗначения = ОписаниеТаблицы.Тип;
				КонецЦикла;
				СтрокаСлова = ТаблицаСлов.Добавить();
				СтрокаСлова.Слово = СокрП(мМаркерПорядкаОтладки);
				СтрокаСлова.ТипСлова = "Конструкция";
			КонецЕсли;
		КонецЕсли; 
		ЗаполнитьЗначенияСвойств(выхСтруктураТипаКонтекста, ВыбраннаяСтруктураТипа);
	КонецЕсли; 
	//ТаблицаСтруктурТиповКонтекста.Очистить(); справочниксылка.
	Если выхСтруктураТипаКонтекста.ТипЯзыка <> "ИмяТипа" Тогда 
		Если ирОбщий.ЛиВнутриКомментарияЛкс(мТекущаяСтрокаНачало) Или мЭтоСтроковыйЛитерал Тогда  
			Если Истина
				И ЗначениеЗаполнено(мРодительскийКонтекст)
				И мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(Новый Структура("БазовыйТип, ЯзыкПрограммы", мРодительскийКонтекст, мЯзыкПрограммы)).Количество() > 0
			Тогда 
				выхСтруктураТипаКонтекста.ИмяОбщегоТипа = мРодительскийКонтекст;
				выхСтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа"; 
				Если Найти(мРодительскийКонтекст, ".") = 0 Тогда
					выхСтруктураТипаКонтекста.Метаданные = Метаданные;
				КонецЕсли;
			ИначеЕсли Не ЗначениеЗаполнено(мРодительскийКонтекст) И ДобавлятьНизкоВероятные Тогда 
				СтруктураТипаИменТипов = мПлатформа.НоваяСтруктураТипа("");
				СтруктураТипаИменТипов.ТипЯзыка = "ИмяТипа";
				СтруктураТипаИменТипов.Метаданные = Метаданные;
				ТаблицаИменТипов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаИменТипов, мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных,,,, мФлагиКомпиляции,,,,,
					мЭтоЛокальныйКонтекстТаблицыСлов);
				ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ТаблицаИменТипов, ТаблицаСлов);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ТаблицаСтруктурТиповКонтекста.Очистить(); // Нужно для прерывания циклического выбора слова автодополнения
	ДобавлятьЛокальныйКонтекст = Истина
		И мЭтоЛокальныйКонтекстТаблицыСлов
		И (Ложь
			Или Не мЭтоСтроковыйЛитерал
			Или выхСтруктураТипаКонтекста.ТипЯзыка <> "" 
			Или РазрешитьОткрытиеОкон);
	Попытка
		ВыгрузкаТаблицыСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(выхСтруктураТипаКонтекста, мЯзыкПрограммы, Конфигурация, ВнешниеФункцииКомпоновкиДанных, ВычислятьТипы,,,
			мФлагиКомпиляции,, МодульМетаданныхКонтекста(выхСтруктураТипаКонтекста),,, ДобавлятьЛокальныйКонтекст);
		СловаДляУточненияТипа = ВыгрузкаТаблицыСлов.НайтиСтроки(Новый Структура("МожноУточнитьТип", Истина));
		//Если ВычислятьТипы Или СловаДляУточненияТипа.Количество() < 100 Тогда
			Для Каждого ВнутренняяСтрокаСлова Из СловаДляУточненияТипа Цикл
				ОбновитьТипЗначенияИзТаблицыСтруктурТипов(ВнутренняяСтрокаСлова, ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов, Ложь);
			КонецЦикла;
		//КонецЕсли; 
		#Если Сервер И Не Сервер Тогда
			ВыгрузкаТаблицыСлов = Новый ТаблицаЗначений;
		#КонецЕсли
		Если Ложь
			Или мЭтоЛокальныйКонтекстТаблицыСлов
			Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица"
		Тогда
			ВыгрузкаТаблицыСлов.Индексы.Добавить("Слово, ТипСлова");
			Если выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "ВнешнийИсточникДанных.<Имя внешнего источника>.ВременнаяТаблица" Тогда
				Для Каждого СтрокаВременнойТаблицы Из ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица")) Цикл
					НоваяСтрока = мПлатформа.ДобавитьВТаблицуСлов(ВыгрузкаТаблицыСлов, СтрокаВременнойТаблицы.Имя, "Свойство",, "ВременнаяТаблица");
					НоваяСтрока.Определение = "Локальный";
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ВыгрузкаТаблицыСлов, ТаблицаСлов);
	Исключение
		Ошибка = ИнформацияОбОшибке();
		Если Ошибка.Описание = "ОшибкаВычисленияВиртуальнойТаблицы" Тогда 
			Возврат Ложь;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
		выхСтруктураТипаКонтекста.ИмяОбщегоТипа, мЯзыкПрограммы, выхСтруктураТипаКонтекста.ТипЯзыка);
	ДобавлятьСтатистическиеСлова = Ложь
		Или ЗначениеЗаполнено(мРодительскийКонтекст)
		Или выхСтруктураТипаКонтекста.ИмяОбщегоТипа = "Неизвестный контекст"
		Или ДобавлятьЛокальныйКонтекст
		Или мПлатформа.ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() > 0;
	Если РазрешитьОткрытиеОкон Или ВычислятьТипы Или ДобавлятьСтатистическиеСлова Тогда
		_РежимОтладки = Ложь;
		Если _РежимОтладки Тогда // Можно менять на Истина в точке останова, например условием ирОбщий.ПрЛкс(_РежимОтладки, 1, 1)
			// Пассивный оригинал расположенного ниже однострочного кода. Выполняйте изменения синхронно в обоих вариантах.
			Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
				СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);
			КонецЦикла;
		Иначе
			// Однострочный код использован для ускорения при разрешенной отладке. Выше расположен оригинал. Выполняйте изменения синхронно в обоих вариантах. Преобразовано консолью кода из подсистемы "Инструменты разработчика"
			Для Каждого СтрокаСлова Из ТаблицаСлов Цикл  			СтрокаСлова.НСлово = НРег(СтрокаСлова.Слово);  		КонецЦикла;  
		КонецЕсли;
		Если ДобавлятьСтатистическиеСлова Тогда
			ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(Ложь, Не мЭтоСтроковыйЛитерал И Не ЗначениеЗаполнено(мРодительскийКонтекст), Истина, Ложь);
			//Если Истина
			//	И УдалитьФункциюНовый // https://www.hostedredmine.com/issues/963017
			//	И мЭтоЛокальныйКонтекст
			//Тогда
			//	СтрокаСловаНовый = ТаблицаСлов.НайтиСтроки(Новый Структура("Слово, ТипСлова", "Новый", "Метод"));
			//	Если СтрокаСловаНовый.Количество() > 0 Тогда
			//		ТаблицаСлов.Удалить(СтрокаСловаНовый[0]);
			//	КонецЕсли;
			//КонецЕсли;
		КонецЕсли;
		Если Прав(мТекущееСлово, 1) = "(" Тогда 
			ЧистоеТекущееСлово = Лев(мТекущееСлово, СтрДлина(мТекущееСлово) - 1);
			ТипТекущегоСлова = "Метод";
		Иначе
			ЧистоеТекущееСлово = мТекущееСлово;
			ТипТекущегоСлова = "Свойство";
		КонецЕсли;
		КлючПоиска = Новый Структура("НСлово, Определение, ТипСлова", НРег(ЧистоеТекущееСлово), "Статистический", ТипТекущегоСлова);
		НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			НайденнаяСтрока = НайденныеСтроки[0];
			НайденнаяСтрока.Частота = НайденнаяСтрока.Частота - 1;
			Если НайденнаяСтрока.Частота = 0 Тогда
				ТаблицаСлов.Удалить(НайденнаяСтрока);
			КонецЕсли;
		КонецЕсли;
		ТаблицаСлов.Свернуть("НСлово, Слово, ТипСлова, Определение, ТипЗначения", "Частота");
	КонецЕсли; 
	Если Сортировать Тогда
		ТаблицаСлов.Сортировать("НСлово, ТипСлова, Определение, ТипЗначения, Частота");
	КонецЕсли;
	Возврат Истина;
КонецФункции

//.
// Параметры:
//    СтрокаОписания - ? - 
// Возвращаемое значение:
//    Строка - 
Функция ИмяПараметраВызоваМетода(СтрокаОписания) Экспорт
	ИмяПараметра = "";
	Если СтрокаОписания = Неопределено Тогда
		Возврат ИмяПараметра;
	КонецЕсли;
	Если СтрокаОписания.Владелец().Колонки.Найти("ЛиЭкспорт") <> Неопределено Тогда 
		ПараметрыМетодаМодуля = мПлатформа.ПараметрыМетодаМодуля(СтрокаОписания);
		Если ПараметрыМетодаМодуля <> Неопределено И ПараметрыМетодаМодуля.Количество() > мНомерПараметра Тогда
			ИмяПараметра = ПараметрыМетодаМодуля[мНомерПараметра].Имя;
		КонецЕсли;
	Иначе
		СтрокиПараметров = мПлатформа.ПараметрыМетодаПлатформы(СтрокаОписания);
		СтрокиПараметров = СтрокиПараметров.НайтиСтроки(Новый Структура("Номер", мНомерПараметра));
		Для Каждого СтрокаПараметра Из СтрокиПараметров Цикл
			Если Найти(СтрокаПараметра.ТипЗначения, "Строка") > 0 Тогда
				ИмяПараметра = ПодготовитьИмяПараметраМетода(СтрокаПараметра.Параметр);
				Прервать;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	Возврат ИмяПараметра;
КонецФункции

Функция КопияКомпоненты()
	
	КопияКопоненты = ирОбщий.НовыйАнализаторКодаЛкс();
	КопияКопоненты.ИнициироватьНеинтерактивно(ЯзыкПрограммы,,,,, ПолеТекста);
	КопияКопоненты.мМодульМетаданных = мМодульМетаданных;
	КопияКопоненты.СлужебноеПолеТекстаДолгое = СлужебноеПолеТекстаДолгое;
	КопияКопоненты.мСтарыйОригинальныйТекст = мСтарыйОригинальныйТекст;
	КопияКопоненты.мОригинальныйТекст = мОригинальныйТекст;
	КопияКопоненты.мТекстБезТекстовыхЛитералов = мТекстБезТекстовыхЛитералов;
	КопияКопоненты.мРегВыражение = мРегВыражение;
	КопияКопоненты.мРекурсивныйПуть = мРекурсивныйПуть;
	Возврат КопияКопоненты;

КонецФункции

Процедура ВставитьВыбранноеСловоАвтодополнения(СтрокаРезультата, ТаблицаСтруктурТиповКонтекста = Неопределено, ПараметрЗакрытияПодсказки = Истина) Экспорт 

	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТаблицаСтатистикиВыбора = мПлатформа.ТаблицаСтатистикиВыбора;
	Если Найти(НРег(СтрокаРезультата.Слово), НРег(мНачалоСлова + мКонецКонтекста)) = 1 Тогда
		НеобрабатываемыйКонецСтроки = Сред(мТекущаяСтрокаКонец, СтрДлина(мКонецКонтекста) + 1);
	Иначе
		НеобрабатываемыйКонецСтроки = мТекущаяСтрокаКонец;
		мРегВыражение.Pattern = "[" + шБуква + "\d]";
		Если мРегВыражение.Проверить(Лев(НеобрабатываемыйКонецСтроки, 1)) Тогда
			НеобрабатываемыйКонецСтроки = " " + НеобрабатываемыйКонецСтроки;
		КонецЕсли; 
	КонецЕсли;
	СтрокаНачала = "";
	Если Не мЭтоСтроковыйЛитерал И СтрокаРезультата.ТипСлова = "Метод" Тогда
		Если Лев(мКонецКонтекста, 1) = "(" Тогда 
			НеобрабатываемыйКонецСтроки = Сред(НеобрабатываемыйКонецСтроки, 2);
		КонецЕсли;
		СтрокаОкончания = "()";
		Если Истина
			И ПараметрЗакрытияПодсказки = Истина 
			И Прав(мТекущееСлово, 1) = "(" 
		Тогда 
			СтрокаОкончания = "(";
		Иначе
			Если Истина
				И ЯзыкПрограммы = 0 
				И Лев(НеобрабатываемыйКонецСтроки, 1) <> ";"
				И СтрокаРезультата.ТипЗначения = ""
				И СтрокаРезультата.Определение <> "Статистический"
			Тогда
				СтрокаОкончания = СтрокаОкончания + ";"
			КонецЕсли;
		КонецЕсли;
		СмещениеКурсораВОкончании = СтрДлина(СтрокаОкончания);
		Если ПараметрЗакрытияПодсказки = Истина Тогда
			ТаблицаМетодовМодуля = мПлатформа.СвойстваТипаМетаданные(мСтруктураТипаКонтекста, СтрокаРезультата.Слово, "Метод",,,,, Истина, мФлагиКомпиляции, МодульМетаданныхКонтекста(мСтруктураТипаКонтекста));
			Если ТаблицаМетодовМодуля.Количество() > 0 Тогда
				СтрокаОписания = ТаблицаМетодовМодуля[0].ТаблицаСтруктурТипов[0].СтрокаОписания;
				Если Ложь
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("COMОбъект") 
						И СтрокаОписания.Parameters.Count > 0)
					Или (Истина
						И ТипЗнч(СтрокаОписания) = Тип("СтрокаТаблицыЗначений")
						И СтрокаОписания.Параметры <> Неопределено)
				Тогда
					СмещениеКурсораВОкончании = 1;
				КонецЕсли; 
			Иначе
				МассивОбщихТипов = мПлатформа.ТаблицаОбщихТиповИзСтруктурыТипа(мСтруктураТипаКонтекста, мЭтоЛокальныйКонтекстТаблицыСлов);
				КлючПоискаПараметров = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка, НСлово, ТипСлова"); // Индекс 
				КлючПоискаПараметров.НСлово = НРег(СтрокаРезультата.Слово);
				КлючПоискаПараметров.ЯзыкПрограммы = ЯзыкПрограммы;
				КлючПоискаПараметров.ТипЯзыка = "";
				КлючПоискаПараметров.ТипСлова = СтрокаРезультата.ТипСлова;
				СмещениеКурсораВОкончании = 2;
				Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
					КлючПоискаПараметров.ТипКонтекста = СтрокаОбщегоТипа.ИмяОбщегоТипа;
					СтрокиКонтекста = мПлатформа.ТаблицаКонтекстов.НайтиСтроки(КлючПоискаПараметров);
					Если СтрокиКонтекста.Количество() > 0 Тогда
						НайденныеСтроки = мПлатформа.ПараметрыМетодаПлатформы(СтрокиКонтекста[0]);
						Если НайденныеСтроки.Количество() > 0 Тогда 
							СмещениеКурсораВОкончании = 1;
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли Истина
		И ПараметрЗакрытияПодсказки = "."
		И ЯзыкПрограммы <> 0
		И СтрокаРезультата.ТипСлова = "Свойство"
		И Найти(СтрокаРезультата.Слово, мПараметрыДиалектаSQL.ПрефиксПараметра) = 1
	Тогда 
		СтрокаНачала = "(";
		СтрокаОкончания = ")";
		СмещениеКурсораВОкончании = 1;
	Иначе
		СтрокаОкончания = "";
		СмещениеКурсораВОкончании = 0;
	КонецЕсли;
	
	// Обновим статистику выбора
	Если Истина
		И СтрокаРезультата.Определение <> "Локальный" 
		И СтрокаРезультата.Определение <> "Статистический" 
	Тогда
		КлючПоиска = Новый Структура("ЯзыкПрограммы, ТипКонтекста, Слово", ЯзыкПрограммы, мКонкретныйТипКонтекста, СтрокаРезультата.Слово);
		НайденныеСтроки = ТаблицаСтатистикиВыбора.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтрокаСтатистикиВыбора = НайденныеСтроки[0];
		Иначе
			СтрокаСтатистикиВыбора = ТаблицаСтатистикиВыбора.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСтатистикиВыбора, КлючПоиска);
		КонецЕсли;
		СтрокаСтатистикиВыбора.Рейтинг = СтрокаСтатистикиВыбора.Рейтинг + 1;
	КонецЕсли; 
	
	СтрокаДобавка = СтрокаНачала + СтрокаРезультата.Слово + СтрокаОкончания;
	Если мРодительскийКонтекст <> "" Тогда 
		СтрокаДобавка = мРодительскийКонтекст + "." + СтрокаДобавка;
	КонецЕсли;
	мРодительскийКонтекст = СтрокаДобавка;
	Если Истина
		И ПараметрЗакрытияПодсказки <> Истина
	Тогда
		СтрокаДобавка = СтрокаДобавка + ПараметрЗакрытияПодсказки;
		мТекущееСлово = СтрокаРезультата.Слово;
		Если ПараметрЗакрытияПодсказки = "." Тогда
			Если СтрокаРезультата.Определение = "Статистический" Тогда 
				ТаблицаСтруктурТиповКонтекста = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			Иначе
				ТаблицаСтруктурТиповКонтекста = ВычислитьТипДочернегоЭлемента(ирОбщий.ЗначенияВМассивЛкс(мСтруктураТипаКонтекста), мТекущееСлово, СтрокаРезультата.ТипСлова);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	мТекущаяСтрокаНачало = Лев(мТекущаяСтрокаНачало, мКонечнаяКолонка - 1 - СтрДлина(мНачалоКонтекста)) + СтрокаДобавка;
	ТекущаяСтрока = мТекущаяСтрокаНачало + НеобрабатываемыйКонецСтроки;
	Если мОригинальныйТекст = "" Тогда
		ВыделенныйТекст("" + ТекущаяСтрока);
	Иначе
		Если ПолеТекста.КоличествоСтрок() < мКонечнаяСтрока Тогда
			ПолеТекста.ДобавитьСтроку(ТекущаяСтрока);
		Иначе
			ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, ТекущаяСтрока); // Баг платформы. Вызывает выделение всего предшествующего текста на 8.3.18
		КонецЕсли; 
	КонецЕсли; 
	УстановитьПризнакМодифицированностиФормы();
	мОткрытьСправкуПоПараметру = АвтоматическаяПодсказкаПоВызовуМетода() И СмещениеКурсораВОкончании = 1;
	мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(СтрокаДобавка) - СтрДлина(мНачалоКонтекста) - СтрДлина(СтрокаОкончания) + СмещениеКурсораВОкончании;
	мНачальнаяКолонка = мКонечнаяКолонка;
	мНачалоКонтекста = мРодительскийКонтекст + ".";
	мНачалоСлова = "";
	ВосстановитьГраницыВыделенияПослеКоманды();
КонецПроцедуры

Функция АвтоматическаяПодсказкаПоВызовуМетода(Обновить = Ложь) Экспорт 
	Если АвтоматическаяПодсказкаПоВызовуМетода = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаПоВызовуМетода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаПоВызовуМетода") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаПоВызовуМетода;
КонецФункции

Функция АвтоматическаяПодсказкаАвтодополненияHTML(Обновить = Ложь) Экспорт
	Если АвтоматическаяПодсказкаАвтодополненияHTML = Неопределено Или Обновить Тогда
		АвтоматическаяПодсказкаАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".АвтоматическаяПодсказкаАвтодополненияHTML") <> Ложь;
	КонецЕсли; 
	Возврат АвтоматическаяПодсказкаАвтодополненияHTML;
КонецФункции

Функция ПоказыватьВсеТипыВСпискеАвтодополненияHTML(Обновить = Ложь) Экспорт 
	Если ПоказыватьВсеТипыВСпискеАвтодополненияHTML = Неопределено Или Обновить Тогда
		ПоказыватьВсеТипыВСпискеАвтодополненияHTML = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПоказыватьВсеТипыВСпискеАвтодополненияHTML") = Истина;
	КонецЕсли;
	Возврат ПоказыватьВсеТипыВСпискеАвтодополненияHTML;
КонецФункции

Функция ПредпочитатьHTMLРедакторКода(Обновить = Ложь) Экспорт 
	Если Не ирКэш.ДоступенРедакторМонакоЛкс() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ПредпочитатьHTMLРедакторКода = Неопределено Или Обновить Тогда
		ПредпочитатьHTMLРедакторКода = ирОбщий.ВосстановитьЗначениеЛкс(ИмяКласса + ".ПредпочитатьHTMLРедакторКода") = Истина;
	КонецЕсли;
	Возврат ПредпочитатьHTMLРедакторКода;
КонецФункции

Процедура ДобавитьCOMКлассыВСписокСлов(Знач КоллекцияКолонок, Знач Компоненты)
	
	Для Каждого Класс Из Компоненты Цикл
		Если Не ЗначениеЗаполнено(Класс.Name) Тогда
			Продолжить;
		КонецЕсли;
		ИмяКласса = Класс.Name;
		КоллекцияКолонок.Добавить(ИмяКласса);
	КонецЦикла;

КонецПроцедуры

Процедура ЗагрузитьВТаблицуСловИзВнутреннейТаблицыСлов(Знач ВнутренняяТаблицаСлов, Знач ВыгрузкаТаблицыСлов)
	
	Для Каждого ВнутренняяСтрокаСлова Из ВнутренняяТаблицаСлов Цикл
		НоваяСтрока = ВыгрузкаТаблицыСлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ВнутренняяСтрокаСлова);
		ТаблицаСтруктурТипов = ВнутренняяСтрокаСлова.ТаблицаСтруктурТипов;
		Если ТаблицаСтруктурТипов <> Неопределено Тогда
			ОбновитьТипЗначенияИзТаблицыСтруктурТипов(НоваяСтрока, ТаблицаСтруктурТипов);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры
                             
Функция УточнитьТипЗначенияВСтрокеТаблицыСлов(Знач СтруктураТипаКонтекста, Знач ТекущаяСтрока, Знач ВернутьСтруктуруТипа = Ложь, Знач НужноУточнитьТип = Истина) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ТекущаяСтрока = ТаблицаСлов.Добавить();
	#КонецЕсли
	ТаблицаСтруктурТипов = Неопределено;
	НужноУточнитьТип = Ложь
		Или НужноУточнитьТип
		Или Лев(ТекущаяСтрока.ТипЗначения, 2) = "??" 
		Или Найти(ТекущаяСтрока.ТипЗначения, "<") > 0;
	Если НужноУточнитьТип Или ВернутьСтруктуруТипа Тогда
		#Если Сервер И Не Сервер Тогда
			мПлатформа = Обработки.ирПлатформа.Создать();
		#КонецЕсли 
		Если ТекущаяСтрока.Определение = "Статистический" Тогда
			ТаблицаСтруктурТипов = ВычислитьТипЗначенияВыражения(ТекущаяСтрока.Слово, мТекстДляПоискаОпределения);
		Иначе                                   
			ОписанияСлов = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипаКонтекста, ЯзыкПрограммы, Конфигурация,, Истина,, ТекущаяСтрока.ТипСлова, мФлагиКомпиляции, ТекущаяСтрока.Слово,
				МодульМетаданныхКонтекста(СтруктураТипаКонтекста), НужноУточнитьТип,, мЭтоЛокальныйКонтекстТаблицыСлов);
			Если ОписанияСлов.Количество() > 0 Тогда
				ТаблицаСтруктурТипов = ОписанияСлов[0].ТаблицаСтруктурТипов;
			КонецЕсли;
		КонецЕсли;
		Если ТаблицаСтруктурТипов <> Неопределено И НужноУточнитьТип Тогда
			ОбновитьТипЗначенияИзТаблицыСтруктурТипов(ТекущаяСтрока, ТаблицаСтруктурТипов, ТекущаяСтрока.Определение <> "Метаданные");
		КонецЕсли; 
	КонецЕсли;
	Возврат ТаблицаСтруктурТипов;

КонецФункции

Процедура ОткрытьСписокОбщихМетодов(Знач СтрокаПоиска = "") Экспорт 
	
	Если Не ЗначениеЗаполнено(СтрокаПоиска) Тогда
		СтрокаПоиска = ирОбщий.ПервыйФрагментЛкс(мТекущееСлово, "(");
	КонецЕсли;
	ФормаВыбора = ПолучитьФорму("ОбщиеМетоды");
	ФормаВыбора.ПараметрСтрокаПоиска = СтрокаПоиска;
	ФормаВыбора.Открыть();
	
КонецПроцедуры 

Процедура НайтиВызовыМетода(Знач ИмяМетода = Неопределено, Знач ИскатьНепрямые = Неопределено) Экспорт 
	
	Если ИмяМетода = Неопределено Тогда
		РазобратьТекущийКонтекст();
		Если ЗначениеЗаполнено(мРодительскийКонтекст) Тогда
			ТаблицаСтруктурТиповРодителя = ВычислитьТипЗначенияВыражения(мРодительскийКонтекст, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
			СтруктураТипаРодителя = ТаблицаСтруктурТиповРодителя[0];
		КонецЕсли;
		ИмяМетода = мКонтекст;
	Иначе
		ИмяМетода = ИмяМетода + "(";
	КонецЕсли;
	ТаблицаСтруктурТиповКонтекста = ВычислитьТипЗначенияВыражения(ИмяМетода, " " + мТекстДляПоискаОпределения, мПредшествующийТекст, Истина);
	СтруктураТипаКонтекста = ТаблицаСтруктурТиповКонтекста[0];
	ПолноеИмяМетода = "";
	Если СтруктураТипаКонтекста.ТипЯзыка = "ИмяТипа" Тогда
		ПолноеИмяМетода = "Новый "; 
		Если ИскатьНепрямые = Неопределено Тогда
			ИскатьНепрямые = Ложь;
		КонецЕсли;
		Если Прав(ИмяМетода, 1) <> "(" Тогда
			ИмяМетода = ИмяМетода + "(";
		КонецЕсли;
		СтруктураТипаКонтекста = Неопределено;
	Иначе
		Если Прав(ИмяМетода, 1) <> "(" Тогда
			Возврат;
		КонецЕсли;
		Если Истина
			И СтруктураТипаРодителя <> Неопределено
			И СтруктураТипаРодителя.ИмяОбщегоТипа = "ОбщийМодуль" 
		Тогда 
			ПолноеИмяМетода = СтруктураТипаРодителя.Метаданные.Имя + ".";
			Если ИскатьНепрямые = Неопределено Тогда
				ИскатьНепрямые = Ложь;
			КонецЕсли;
			СтруктураТипаКонтекста = Неопределено;
		ИначеЕсли ИскатьНепрямые = Неопределено Тогда
			Если Истина
				И СтруктураТипаКонтекста.СтрокаОписания <> Неопределено
				И СтруктураТипаКонтекста.СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
				И СтруктураТипаКонтекста.СтрокаОписания.ТипКонтекста = "Глобальный"
			Тогда
				ИскатьНепрямые = Ложь;
			ИначеЕсли Истина
				И СтруктураТипаКонтекста <> Неопределено
				И СтруктураТипаКонтекста.СтрокаОписания <> Неопределено
				И мМодульМетаданных <> Неопределено
				И СтруктураТипаКонтекста.СтрокаОписания.Владелец() = мМодульМетаданных.Методы
			Тогда
				ИскатьНепрямые = Ложь;
			Иначе
				ИскатьНепрямые = Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ПолноеИмяМетода = ПолноеИмяМетода + ирОбщий.СтрокаБезКонцаЛкс(ирОбщий.ПоследнийФрагментЛкс(ИмяМетода), 1);
	ПоискВызововМетода = ПолучитьФорму("ПоискВызововМетода",, ПолноеИмяМетода);
	ПоискВызововМетода.ПараметрИскатьНепрямые = ИскатьНепрямые;
	ПоискВызововМетода.ПараметрСтруктураТипаКонтекста = СтруктураТипаКонтекста;
	ПоискВызововМетода.Открыть();
	ПоискВызововМетода.ОбновитьДанные();
	
КонецПроцедуры

// Заменяет все символы табуляции в строке после первого печатного символа эквивалентным количеством пробелов.
//
// Параметры:
//  Строка       - Строка;
//
// Возвращаемое значение:
//  Строка.
//
Функция ЗаменитьТабуляцииВСтроке(Знач Строка, ЛиТекущая = Ложь)
	
	Табы = "";
	А = 1; НачалоСтроки = Истина;   
	Пока А <= СтрДлина(Строка) Цикл
		Если Сред(Строка, А, 1) <> Символы.Таб И НачалоСтроки Тогда
			// Найдем начало строки без табов 
			Табы = Лев(Строка, А-1);
			Строка = Прав(Строка, СтрДлина(Строка) - А + 1);
			НачалоСтроки = Ложь;
		ИначеЕсли Сред(Строка, А, 1) = Символы.Таб И НЕ НачалоСтроки Тогда
			// Удалим табы из строки 
			Строка = Лев(Строка, А - 1) + Лев("    ", 4 - СтрДлина(Лев(Строка, А - 1)) % 4) 
				+ Прав(Строка, СтрДлина(Строка) - А);
			Если Истина
				И ЛиТекущая
				И мКонечнаяКолонка > А
			Тогда
				мКонечнаяКолонка = мКонечнаяКолонка + 3 - СтрДлина(Лев(Строка, А - 1)) % 4;
			КонецЕсли;
		КонецЕсли;
		А = А + 1;
	КонецЦикла;
	
	Возврат Табы + Строка;
    
КонецФункции

// Заменяет все символы табуляции в каждой строке текста после первого печатного символа эквивалентным
// количеством пробелов.
//
// Параметры:
//  Нет.
//
Процедура ЗаменитьТабуляции()

	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = ПолеТекста.КоличествоСтрок();
	Для А = 1 По КоличествоСтрок Цикл
	    Строка = ЗаменитьТабуляцииВСтроке(ПолеТекста.ПолучитьСтроку(А), (А = мКонечнаяСтрока));
	    ПолеТекста.ЗаменитьСтроку(А, Строка);
	КонецЦикла;
	УстановитьПризнакМодифицированностиФормы();
	мНачальнаяКолонка = мКонечнаяКолонка;

КонецПроцедуры

Процедура УстановитьАвтоКонтекстнаяПомощь(НовыйРежим)

	Кнопка = ирКлиент.КнопкаКоманднойПанелиЭкземпляраКомпонентыЛкс(ЭтотОбъект, "АвтоКонтекстнаяПомощь");
	Если Кнопка = Неопределено Тогда
		// Это сделано временно для работы в ссылочном режиме
		Возврат;
	КонецЕсли; 
	мАвтоКонтекстнаяПомощь = НовыйРежим;
	Если мАвтоКонтекстнаяПомощь Тогда
		ФормаВладелец.ПодключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку", 1);
	Иначе
		ФормаВладелец.ОтключитьОбработчикОжидания("КлсПолеТекстаПрограммыАвтоОбновитьСправку");
	КонецЕсли; 
	Кнопка.Пометка = мАвтоКонтекстнаяПомощь;

КонецПроцедуры

// Удаляет все символы переноса строки из текста.
//
// Параметры:
//  Нет.
//
Процедура УдалитьПереносы()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если Ложь
		Или ПолеТекста.ТолькоПросмотр()
		Или ФормаВладелец.ТолькоПросмотр
	Тогда
		Возврат;
	КонецЕсли;
	Текст = ПолеТекста.ПолучитьТекст();
	Текст = СокрЛП(Текст);
	Если Истина
		И Лев(Текст, 1) = """"
		И Лев(Текст, 2) <> """"""
	Тогда
		Текст = "|" + Сред(Текст, 2);
	КонецЕсли; 
	ОбработанныеСтроки = Новый Массив;
	Для Каждого СтрокаТекста Из ирОбщий.СтрРазделитьЛкс(Текст, Символы.ПС) Цикл
		Если Лев(СокрЛ(СтрокаТекста), 1) = "|" Тогда
			СтрокаТекста = СтрЗаменить(СтрокаТекста, """""", """");
			СтрокаТекста = СтрЗаменить(СтрокаТекста, "|", "");
		КонецЕсли;
		ОбработанныеСтроки.Добавить(СтрокаТекста);
	КонецЦикла;
	Текст = ирОбщий.СтрСоединитьЛкс(ОбработанныеСтроки, Символы.ПС);
	Если Истина
		И Прав(Текст, 1) = """"
		И Прав(Текст, 2) <> """"""
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 1);
	КонецЕсли; 
	Если Истина
		И Прав(Текст, 2) = """;"
		И Прав(Текст, 3) <> """"";"
	Тогда
		Текст = Лев(Текст, СтрДлина(Текст) - 2);
	КонецЕсли; 
	ПолеТекста.УстановитьТекст(Текст);
	УстановитьПризнакМодифицированностиФормы();
	
КонецПроцедуры

Функция ВычислитьПолучитьФорму(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = НРег(МассивПараметров[0]);
	Если Лев(ПервыйПараметр, 1) = """" Тогда
		ИмяФормы = ирОбщий.ТекстИзВыраженияВстроенногоЯзыкаЛкс(ПервыйПараметр);
	Иначе
		Если ирОбщий.ЛиИмяПеременнойЛкс(ПервыйПараметр) Тогда
			Найденные = ирОбщий.НайтиРегВыражениеЛкс(ПредшествующийТекст, "\s" + ПервыйПараметр + "\s*=\s*""(" + шИмя + ")""");
			Если Найденные.Количество() > 0 Тогда
				ИмяФормы = Найденные[0].Подгруппы[0];
			КонецЕсли;
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ИмяФормы) Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	Если Найти(ИмяФормы, ".") = 0 Тогда
		Если ирОбщий.СтрокиРавныЛкс("ПолучитьОбщуюФорму", Слово) Тогда
			МетаФорма = Метаданные.ОбщиеФормы.Найти(ИмяФормы);
		Иначе
			ОбъектМД = РодительскаяСтруктураТипа.Метаданные;
			#Если Сервер И Не Сервер Тогда
				ОбъектМД = Метаданные.Справочники.ирАлгоритмы;
			#КонецЕсли
			Если ТипЗнч(ОбъектМД) <> Тип("ОбъектМетаданных") Тогда
				Возврат Неопределено;
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяФормы) Тогда
				МетаФорма = ОбъектМД.Формы.Найти(ИмяФормы);
			ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуСписка", Слово) Тогда     
				МетаФорма = ОбъектМД.ОсновнаяФормаСписка;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс("ПолучитьФормуВыбора", Слово) Тогда     
				МетаФорма = ОбъектМД.ОсновнаяФормаДляВыбора;
			Иначе
				ИменаСвойствОсновнойФормы = Новый Массив();
				ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФорма");
				ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФормаОбъекта");
				ИменаСвойствОсновнойФормы.Добавить("ОсновнаяФормаЗаписи");
				Для Каждого ИмяСвойстваОсновнойФормы Из ИменаСвойствОсновнойФормы Цикл
					Попытка
						МетаФорма = ОбъектМД[ИмяСвойстваОсновнойФормы];
						Прервать;
					Исключение
					КонецПопытки;
				КонецЦикла;
			КонецЕсли;
			Если МетаФорма = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		ИмяФормы = МетаФорма.ПолноеИмя(); 
	КонецЕсли;
	Форма = ирКэш.ПассивнаяФормаПоИмениЛкс(НРег(ИмяФормы));
	Если Форма <> Неопределено Тогда
		СлужебныеДанныеФормы = ирОбщий.СлужебныеДанныеФормыЛкс(Форма);
		Если СлужебныеДанныеФормы <> Неопределено Тогда
			СлужебныеДанныеФормы.ИмяФормы = ИмяФормы;
		КонецЕсли;
		Результат = мПлатформа.НоваяТаблицаСтруктурТипа();
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
		мПлатформа.ДобавитьВТаблицуСтруктурТипов(Результат, СтруктураТипа);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ВычислитьКоллекцияДобавить(Знач РодительскаяСтруктураТипа, Знач МассивПараметров, Знач Слово = "", Знач ПредшествующийТекст = "") 
	Если МассивПараметров.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПервыйПараметр = НРег(МассивПараметров[0]);
	Если Не ирОбщий.СтрНачинаетсяСЛкс(ПервыйПараметр, "тип(""", Истина) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяТипа = ирОбщий.ТекстИзВыраженияВстроенногоЯзыкаЛкс(ирОбщий.ТекстМеждуМаркерамиЛкс(ПервыйПараметр, "тип(", ")"));
	Попытка
		ТипЭлемента = Тип(ИмяТипа);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	Результат = мПлатформа.НоваяТаблицаСтруктурТипа();
	СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(ТипЭлемента);
	мПлатформа.ДобавитьВТаблицуСтруктурТипов(Результат, СтруктураТипа);
	Возврат Результат;

КонецФункции

// Добавляет переменную локального контекста.
//
// Параметры:
//  ИмяПеременной - Строка;
//  ДопустимыеТипы - Строка, ТаблицаЗначений;
//
Процедура ДобавитьПеременнуюЛокальногоКонтекста(ИмяПеременной, ДопустимыеТипы) Экспорт

	НоваяСтрока = ДобавитьСловоЛокальногоКонтекста(ИмяПеременной);
	Если ТипЗнч(ДопустимыеТипы) = Тип("Строка") Тогда 
		МассивСериализованныхТипов = ирОбщий.СтрРазделитьЛкс(ДопустимыеТипы, ";");
		//ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
		ТаблицаСтруктурТипов = НоваяСтрока.ТаблицаСтруктурТипов;
		Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
			СтруктураТипа.Вставить("СтрокаОписания", НоваяСтрока); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
		КонецЦикла;
		НоваяСтрока.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	Иначе
		НоваяСтрока.ТаблицаСтруктурТипов = ДопустимыеТипы;
	КонецЕсли; 

КонецПроцедуры

// Удаляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка.
//
Процедура УдалитьСловоЛокальногоКонтекста(Слово, ТипСлова) Экспорт

	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", НРег(Слово));
	СтрокиСлова = ТаблицаЛокальногоКонтекста(ТипСлова).НайтиСтроки(КлючСтроки);
	Если СтрокиСлова.Количество() > 0 Тогда
		СтрокиСлова[0].Владелец().Удалить(СтрокиСлова[0]);
	КонецЕсли;

КонецПроцедуры

// Устанавливает доступность действий, изменяющих данные.
//
// Параметры:
//  НовыйТолькоПросмотр - Булево.
//
Процедура УстановитьТолькоПросмотр(НовыйТолькоПросмотр) Экспорт 

	ФормаКласса = ПолучитьФорму("ФормаМакет");
	МассивКоллекцийКнопок = Новый Массив;
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы["КоманднаяПанель" + Формат(ЯзыкПрограммы, "ЧН=")].Кнопки);
	МассивКоллекцийКнопок.Добавить(ФормаКласса.ЭлементыФормы.КоманднаяПанельОбщая.Кнопки);
	Для Каждого КнопкиМакета Из МассивКоллекцийКнопок Цикл
		Для Каждого КнопкаМакета Из КнопкиМакета Цикл
			Если КнопкаМакета.ТипКнопки <> ТипКнопкиКоманднойПанели.Действие Тогда 
				Продолжить;
			КонецЕсли;
			КонечноеИмя = ирКлиент.СформироватьИмяЭлементаУправленияЭкземпляраЛкс(ЭтотОбъект, КнопкаМакета.Имя);
			Кнопка = КоманднаяПанель.Кнопки.Найти(КонечноеИмя);
			Если Кнопка.ИзменяетДанные Тогда 
				Кнопка.Доступность = Не НовыйТолькоПросмотр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // УстановитьТолькоПросмотр()

Процедура ОформитьЯчейкуТипаЗначения(ОформлениеСтроки, ДанныеСтроки) Экспорт 
	
	Если Истина
		И ОформлениеСтроки.Ячейки.ТипЗначения.Видимость 
		И ЗначениеЗаполнено(ДанныеСтроки.ТипЗначения) 
		//И Найти(ДанныеСтроки.ТипЗначения, ",") = 0
	Тогда
		СтрокаИменТипов = ирОбщий.ПервыйФрагментЛкс(ДанныеСтроки.ТипЗначения, "[");
		мРегВыражение = ирКэш.ВычислительРегВыраженийЛкс();
		#Если Сервер И Не Сервер Тогда
			мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
		#КонецЕсли
		мРегВыражение.Global = Истина;
		мРегВыражение.Pattern = "\(.*?\)";
		СтрокаИменТипов = мРегВыражение.Заменить(СтрокаИменТипов, "");
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(СтрокаИменТипов);
		Исключение
			ОписаниеТипов = Неопределено;
		КонецПопытки; 
		Если ОписаниеТипов <> Неопределено Тогда
			Типы = ОписаниеТипов.Типы();
			Если Типы.Количество() > 0 Тогда
				КартинкаТипа = ирКлиент.КартинкаТипаЛкс(Типы[0]);
				Если КартинкаТипа <> Неопределено Тогда
					ОформлениеСтроки.Ячейки.ТипЗначения.УстановитьКартинку(КартинкаТипа);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Выполняет шаблон текста.
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьШаблонТекста()
	
	Если ПолеТекста.ТолькоПросмотр() Тогда
		Возврат;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрочитатьНачалоИКонецТекущейСтроки();
	//РазобратьКонтекстСтроки();
	НадежноУстановитьФокус = Ложь;
	ПоследняяПозицияКурсора = 0;
	ТаблицаШаблоновТекста = мПлатформа.ПолучитьТаблицуШаблоновТекста(ИмяКласса);
	КонечныйТекстЗамены = " ";
	Если Ложь
		Или ТаблицаШаблоновТекста = Неопределено 
		Или ТаблицаШаблоновТекста.Количество() = 0
	Тогда
		//
	Иначе
		мРегВыражение.Global = Ложь; 
		СтрокаРазделителейШаблоновТекста = ";.,:()[]";
		мРегВыражение.Pattern = "([^\s" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(СтрокаРазделителейШаблоновТекста) + "]*)$";
		Результат = мРегВыражение.НайтиВхождения(мТекущаяСтрокаНачало);
		Если Результат.Количество() > 0 Тогда
			НачалоМаркера = Результат[0].SubMatches(0);
			Если ЗначениеЗаполнено(НачалоМаркера) Тогда
				//СтрокаШаблона = ТаблицаШаблоновТекста.Найти(НРег(НачалоМаркера), "ШаблонБезКвадратныхСкобок");
				СтрокаШаблона = Неопределено;
				Для каждого ТекСтрокаШаблона Из ТаблицаШаблоновТекста Цикл
					Если ТекСтрокаШаблона.Шаблон = НРег(НачалоМаркера) Тогда
						СтрокаШаблона = ТекСтрокаШаблона;
						Прервать;
					КонецЕсли;
					МинимальнаяДлинаСовпадения = Найти(ТекСтрокаШаблона.Шаблон, "[");
					Если МинимальнаяДлинаСовпадения > 0 Тогда
						Если СтрДлина(НачалоМаркера) < МинимальнаяДлинаСовпадения - 1 Тогда
							Продолжить;
						КонецЕсли; 
						ШаблонБезСкобок = СтрЗаменить(ТекСтрокаШаблона.Шаблон, "[", "");
						ШаблонБезСкобок = СтрЗаменить(ШаблонБезСкобок, "]", "");
						Если Найти(ШаблонБезСкобок, НРег(НачалоМаркера)) = 1 Тогда
							СтрокаШаблона = ТекСтрокаШаблона;
							Прервать;
						КонецЕсли;
					КонецЕсли; 
				КонецЦикла;
				Если СтрокаШаблона = Неопределено Тогда
					НачалоМаркера = "";
				Иначе
					мРегВыражение.Global = Истина;
					мРегВыражение.MultiLine = Ложь;
					мРегВыражение.Pattern = "(<\?\s*(""[^""\^]*"")?(?:,\s*(" + мПлатформа.шИмя + "))?>)|(.|\r|\n)";
					Результат = мРегВыражение.НайтиВхождения(СтрокаШаблона.Замена);
					КонечныйТекстЗамены = "";
					КешПараметров = Новый ТаблицаЗначений;
					КешПараметров.Колонки.Добавить("ИмяПараметра");
					КешПараметров.Колонки.Добавить("ЗначениеПараметра");
					Для Каждого Match Из Результат Цикл
						УправляющаяКонструкция = Match.SubMatches(0);
						Если ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(УправляющаяКонструкция) Тогда
							КонечныйТекстЗамены = КонечныйТекстЗамены + Match.SubMatches(3);
						Иначе
							ИмяПараметраШаблона = Match.SubMatches(1);
							ТипШаблона = Match.SubMatches(2);
							Если ТипШаблона = "КонструкторОписанияТипов" Тогда
								КонечныйТекстЗамены = ТекстИзКонструктораОписанияТипов();
							ИначеЕсли ТипШаблона = "ТекстЗапроса" Тогда
								//ВызватьКонструкторЗапросов();
							ИначеЕсли Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(ИмяПараметраШаблона) Тогда
								ИмяПараметраШаблона = Сред(ИмяПараметраШаблона, 2, СтрДлина(ИмяПараметраШаблона) - 2);
								ВведеннаяСтрока = "";
								Если ИмяПараметраШаблона <> "" Тогда
									СтрокаКэша = КешПараметров.Найти(ИмяПараметраШаблона, "ИмяПараметра");
									Если СтрокаКэша <> Неопределено Тогда
										ВведеннаяСтрока = СтрокаКэша.ЗначениеПараметра;
									Иначе
										СтрокаКэша = КешПараметров.Добавить();
										СтрокаКэша.ИмяПараметра = ИмяПараметраШаблона;
										НадежноУстановитьФокус = Истина;
										ВвестиЗначение(ВведеннаяСтрока, ИмяПараметраШаблона, Тип("Строка"));
										СтрокаКэша.ЗначениеПараметра = ВведеннаяСтрока;
									КонецЕсли;
								КонецЕсли; 
								КонечныйТекстЗамены = КонечныйТекстЗамены + ВведеннаяСтрока;
							Иначе
								ПоследняяПозицияКурсора = СтрДлина(КонечныйТекстЗамены) + 1;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					ЗаменаТабуляции = ирОбщий.СтрокаПовторомЛкс(" ", мШиринаТабуляции);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если КонечныйТекстЗамены <> Неопределено Тогда
		КонечныйТекстЗаменыТД = Новый ТекстовыйДокумент;
		КонечныйТекстЗаменыТД.УстановитьТекст(КонечныйТекстЗамены);
		лКонечнаяСтрока = 0;
		лКонечнаяКолонка = 0;
		Если ПоследняяПозицияКурсора > 0 Тогда
			мПолеТекстаВременное.УстановитьТекст(КонечныйТекстЗамены);
			Если ПоследняяПозицияКурсора <= СтрДлина(КонечныйТекстЗамены) Тогда
				мПолеТекстаВременное.УстановитьГраницыВыделения(ПоследняяПозицияКурсора, ПоследняяПозицияКурсора);
				мПолеТекстаВременное.ПолучитьГраницыВыделения(лКонечнаяСтрока, лКонечнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
			Иначе
				лКонечнаяСтрока = КонечныйТекстЗаменыТД.КоличествоСтрок();
				лКонечнаяКолонка = СтрДлина(КонечныйТекстЗаменыТД.ПолучитьСтроку(КонечныйТекстЗаменыТД.КоличествоСтрок())) + 1;
			КонецЕсли;
		КонецЕсли;
		ЧислоСтрокЗамены = КонечныйТекстЗаменыТД.КоличествоСтрок();
		СтрокаДобавка = КонечныйТекстЗаменыТД.ПолучитьСтроку(1);
		ДлинаНачалаСтроки = мКонечнаяКолонка - СтрДлина(НачалоМаркера) - 1;
		НачалоСтроки = Лев(мТекущаяСтрокаНачало, ДлинаНачалаСтроки);
		мТекущаяСтрокаНачало = НачалоСтроки + СтрокаДобавка;
		ТекущаяСтрока = мТекущаяСтрокаНачало;
		Если ЧислоСтрокЗамены = 1 Тогда
			ТекущаяСтрока = ТекущаяСтрока + мТекущаяСтрокаКонец;
		КонецЕсли;
		ПолеТекста.ЗаменитьСтроку(мКонечнаяСтрока, "" + ТекущаяСтрока);
		ДлинаРазвернутогоНачалаСтроки = СтрДлина(СтрЗаменить(НачалоСтроки, Символы.Таб, ЗаменаТабуляции));
		ЧислоТабуляций = ДлинаРазвернутогоНачалаСтроки / мШиринаТабуляции;
		ЧислоПробелов = ДлинаРазвернутогоНачалаСтроки % мШиринаТабуляции;
		НачалоНовойСтроки = ирОбщий.СтрокаПовторомЛкс(Символы.Таб, ЧислоТабуляций);
		НачалоНовойСтроки = НачалоНовойСтроки + ирОбщий.СтрокаПовторомЛкс(" ", ЧислоПробелов);
		Для Счетчик = 2 По ЧислоСтрокЗамены - 1 Цикл
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(Счетчик);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + Счетчик - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки);
		КонецЦикла;
		Если ЧислоСтрокЗамены > 1 Тогда
			ТекущаяСтрокаВставки = КонечныйТекстЗаменыТД.ПолучитьСтроку(ЧислоСтрокЗамены);
			ПолеТекста.ВставитьСтроку(мКонечнаяСтрока + ЧислоСтрокЗамены - 1, НачалоНовойСтроки + ТекущаяСтрокаВставки + мТекущаяСтрокаКонец);
		КонецЕсли;
		Если лКонечнаяСтрока > 0 Тогда
			Если лКонечнаяСтрока = 1 Тогда
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоСтроки);
			Иначе
				лКонечнаяКолонка = лКонечнаяКолонка + СтрДлина(НачалоНовойСтроки);
			КонецЕсли;
			лКонечнаяСтрока = лКонечнаяСтрока + мКонечнаяСтрока - 1;
			мКонечнаяКолонка = лКонечнаяКолонка;
			мКонечнаяСтрока = лКонечнаяСтрока;
		Иначе
			Если ЧислоСтрокЗамены > 0 Тогда
				мКонечнаяСтрока = мКонечнаяСтрока + ЧислоСтрокЗамены - 1;
			КонецЕсли; 
			Если ЧислоСтрокЗамены > 1 Тогда
				мКонечнаяКолонка = СтрДлина(НачалоСтроки + ТекущаяСтрокаВставки) + 1;
			Иначе
				мКонечнаяКолонка = мКонечнаяКолонка + СтрДлина(КонечныйТекстЗамены) - СтрДлина(НачалоМаркера);
			КонецЕсли;
		КонецЕсли;
		мНачальнаяСтрока = мКонечнаяСтрока;
		мНачальнаяКолонка = мКонечнаяКолонка;
	КонецЕсли;
	УстановитьФокус();

КонецПроцедуры

Функция ТекстИзКонструктораОписанияТипов()
	
	ОписаниеТипов = ирКлиент.РедактироватьОписаниеРедактируемыхТиповЛкс();
	Если ОписаниеТипов <> Неопределено Тогда
		Результат = ирОбщий.ВыражениеВстроенногоЯзыкаСозданиеОписанияТиповЛкс(ОписаниеТипов);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Процедура КонструкторОписанияТипов()
	
	НовыйТекст = ТекстИзКонструктораОписанияТипов();
	Если ЗначениеЗаполнено(НовыйТекст) Тогда
		ПолеТекста.ВыделенныйТекст(НовыйТекст);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОкружитьВыделенныеСтроки(Знач НачалоОкружения, Знач КонецОкружения, Знач СмещатьВправо = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерНачальнойСтроки = ПолучитьНомерТекущейСтроки(Истина);
	ВыделенныйТекст = ПолеТекста.ВыделенныйТекст();
	Смещение = "";
	Если СмещатьВправо Тогда
		Смещение = Символы.Таб;
	КонецЕсли;
	СмещениеПервойСтроки = Лев(ВыделенныйТекст, СтрДлина(ВыделенныйТекст) - СтрДлина(СокрЛ(ВыделенныйТекст)));
	ПолеТекста.ВставитьТекст(
	"" + СмещениеПервойСтроки + НачалоОкружения + "
	|" + Смещение + ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс("", ВыделенныйТекст, Смещение) + "
	|" + СмещениеПервойСтроки + КонецОкружения);
	НомерНачальнойКолонки = СтрДлина(СмещениеПервойСтроки) + 1;
	ПолеТекста.УстановитьГраницыВыделения(НомерНачальнойСтроки, НомерНачальнойКолонки, НомерНачальнойСтроки, НомерНачальнойКолонки,, ФормаВладелец);
	УстановитьПризнакМодифицированностиФормы();

КонецПроцедуры

Функция ПредставлениеЗначенияВЯзыкеЗапросов(Знач Значение, Знач ВыводитьСообщение = Ложь, Знач ПараметрыДиалектаSQL = Неопределено, Знач Английский1С = Неопределено) Экспорт 
	
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = "";
	ТипЗначенияПараметра = ТипЗнч(Значение);
	ОбъектМД = Метаданные.НайтиПоТипу(ТипЗначенияПараметра);
	Если ОбъектМД <> Неопределено Тогда
		КорневойТип = ирОбщий.ПервыйФрагментЛкс(ОбъектМД.ПолноеИмя());
		Если ирОбщий.ЛиКорневойТипСсылкиЛкс(КорневойТип) Тогда
			Если ирОбщий.ЛиТипСсылкиТочкиМаршрутаЛкс(ТипЗначенияПараметра) Тогда 
				Результат = "ТочкаМаршрута." + Значение.Имя;
			ИначеЕсли Значение.Пустая() Тогда
				Результат = "ПустаяСсылка";
			ИначеЕсли ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТип) Тогда
				Результат = XMLСтрока(Значение);
			ИначеЕсли ирОбщий.ЛиКорневойТипОбъектаСПредопределеннымЛкс(КорневойТип) Тогда
				Если Значение.Предопределенный Тогда
					Результат = ирОбщий.ПолучитьМенеджерЛкс(ОбъектМД).ПолучитьИмяПредопределенного(Значение);
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияБухгалтерии") Тогда 
		Результат = "ВидДвиженияБухгалтерии." + Значение;
	ИначеЕсли ТипЗначенияПараметра = Тип("ВидДвиженияНакопления") Тогда 
		Результат = "ВидДвиженияНакопления." + Значение;
	КонецЕсли; 
	Если ЗначениеЗаполнено(Результат) Тогда
		Если ОбъектМД <> Неопределено Тогда
			Результат = ОбъектМД.ПолноеИмя() + "." + Результат;
		КонецЕсли; 
		Результат = "ЗНАЧЕНИЕ(" + Результат + ")";
	ИначеЕсли ТипЗначенияПараметра = Тип("Неопределено") Тогда
		Результат = СловоЯзыкаЗапросов("UNDEFINED", ПараметрыДиалектаSQL, Английский1С);
	ИначеЕсли ТипЗначенияПараметра = Тип("Null") Тогда
		Результат = "NULL";
	Иначе 
		Если ПараметрыДиалектаSQL = Неопределено Тогда
			ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
		КонецЕсли;
		Если ТипЗначенияПараметра = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
			ТипЗначенияПараметра = ТипЗнч(Значение);
		КонецЕсли; 
		Если ТипЗначенияПараметра = Тип("Дата") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = СловоЯзыкаЗапросов("DATETIME", ПараметрыДиалектаSQL, Английский1С) + "(" + XMLСтрока(Год(Значение)) + ", " + XMLСтрока(Месяц(Значение)) + ", " + XMLСтрока(День(Значение));
				Если НачалоДня(Значение) <> Значение Тогда
					Результат = Результат + ",  " + XMLСтрока(Час(Значение)) + ", " + XMLСтрока(Минута(Значение)) + ", " + XMLСтрока(Секунда(Значение));
				КонецЕсли;
				Результат = Результат + ")";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ПараметрыДиалектаSQL.Диалект, "WQL") Тогда
				Значение = ирОбщий.ПолучитьЛитералДатыДляWQLЛкс(Значение);
			Иначе// Если ирОбщий.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗначенияПараметра = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = СловоЯзыкаЗапросов("TRUE", ПараметрыДиалектаSQL, Английский1С);
			Иначе
				Результат = СловоЯзыкаЗапросов("FALSE", ПараметрыДиалектаSQL, Английский1С);
			КонецЕсли; 
		ИначеЕсли ТипЗначенияПараметра = Тип("Строка") Тогда
			Если ПараметрыДиалектаSQL.Это1С Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Если Результат = "" Тогда
		Если ВыводитьСообщение Тогда
			ирОбщий.СообщитьЛкс(ирОбщий.СтрШаблонЛкс("Литеральное представление значения ""%1"" в языке запросов не предусмотрено", ирОбщий.РасширенноеПредставлениеЗначенияЛкс(Значение)));
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция СловоЯзыкаЗапросов(Ключ, ПараметрыДиалектаSQL = Неопределено, Английский1С = Неопределено) Экспорт

	Если ПараметрыДиалектаSQL = Неопределено Тогда
		ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
	КонецЕсли;
	Если Английский1С = Неопределено Тогда
		Английский1С = мАнглийский1С;
	КонецЕсли;
	Результат = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("AS", Ключ) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		СтрокаТерминала = мТерминалыЯзыкаЗапросов.Найти(Ключ, "Ключ");
		Если ПараметрыДиалектаSQL <> Неопределено И ПараметрыДиалектаSQL.Это1С Тогда 
			Если СтрокаТерминала = Неопределено Тогда
				ВызватьИсключение "Не найден терминал """ + Ключ + """ языка запросов 1C";
			КонецЕсли; 
			Если Не Английский1С Тогда
				Результат = СтрокаТерминала.Русский;
			Иначе
				Результат = СтрокаТерминала.Английский;
			КонецЕсли; 
		Иначе
			Результат = Ключ;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция НайтиВыбранныеТаблицыВТекстеЗапроса(Знач СтрокаЗапросаПакета, Знач НачальнаяПозицияЗапроса, Знач ПолеТекстаЗапроса) Экспорт 
	#Если Сервер И Не Сервер Тогда
		СтрокаЗапросаПакета = Новый ДеревоЗначений;
	#КонецЕсли
	СтрокаЗапросаПакета.СложныйАнализВыполнен = Истина;
	//Шаблон = шИЗ;
	Шаблон = "((?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "[\s\S]*?)(?:$|\sОБЪЕДИНИТЬ(?:\s+ВСЕ)?\s+|\sUNION(?:\s+ALL)?\s+|\sУПОРЯДОЧИТЬ\s+[^\)]*$|\ORDER\s+[^\)]*$)";
	ВхожденияИЗ = ирОбщий.НайтиРегВыражениеЛкс(СтрокаЗапросаПакета.Текст, Шаблон);
	НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса;
	Для Каждого ВхождениеИЗ Из ВхожденияИЗ Цикл
		Если ВхожденияИЗ.Количество() > 1 Тогда 
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета.Строки.Вставить(0);
			Если Истина
				И СтрокаЗапросаПакета.ТипУзла = "<CreateRoot>" 
				И СтрокаЗапросаПакета.Строки.Количество() = 1 
			Тогда
				СтрокаЧастиОбъединения.ТипУзла = "<CreateQuery>";
			Иначе
				СтрокаЧастиОбъединения.ТипУзла = "<SelectQuery>";
			КонецЕсли;
			СтрокаЧастиОбъединения.СложныйАнализВыполнен = Истина;
			СтрокаЧастиОбъединения.Порядок = -СтрокаЗапросаПакета.Строки.Количество();
			СтрокаЧастиОбъединения.Имя = "Выборка";
			КонечнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.Подгруппа0);
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозицияЧасти, КонечнаяПозицияЧасти);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозицияЧасти, КонечнаяПозицияЧасти - НачальнаяПозицияЧасти);
			НачальнаяПозицияЧасти = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + СтрДлина(ВхождениеИЗ.ТекстВхождения);
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаЧастиОбъединения, ПолеТекстаЗапроса);
		Иначе
			СтрокаЧастиОбъединения = СтрокаЗапросаПакета;
		КонецЕсли;
		Найденные = ирОбщий.НайтиРегВыражениеЛкс(ВхождениеИЗ.ТекстВхождения, шОписаниеТаблицыСЗахватом);
		Для Каждого Найденное Из Найденные Цикл
			НачальнаяПозиция = НачальнаяПозицияЗапроса + ВхождениеИЗ.ПозицияВхождения + Найденное.ПозицияВхождения;
			КонечнаяПозиция = НачальнаяПозиция + СтрДлина(Найденное.Подгруппа0);
			Если Лев(Найденное.Подгруппа0, 1) = "(" Тогда
				НачальнаяПозиция = НачальнаяПозиция + 1;
				КонечнаяПозиция = КонечнаяПозиция - 1;
				ТипУзла = "<FromUnion>";
			Иначе
				ТипУзла = "<TableWithName>";
			КонецЕсли; 
			ПолеТекстаЗапроса.УстановитьГраницыВыделения(НачальнаяПозиция, КонечнаяПозиция);
			ТекстИсточника = ПолеТекстаЗапроса.ВыделенныйТекст;
			//ТекстИсточника = Сред(СлужебноеПолеТекста.Получитьтекст(), НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция);
			КорневойТипТаблицы = ирОбщий.ПервыйФрагментЛкс(СокрЛ(ТекстИсточника));
			Если Ложь
				Или Найденное.Подгруппа4 = "ЧИСЛО" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или ТекстИсточника = "КОНЕЦ" // Ложное срабатываение ВЫРАЗИТЬ ВЫБОР ... КОНЕЦ КАК ЧИСЛО
				Или (Истина
					// {ГДЕ (АналитикаУчета.Договор) КАК Договор}
					// ОБЪЕДИНИТЬ ВЫБРАТЬ АналитикаУчета.Партнер КАК Партнер
					И мПараметрыДиалектаSQL.Это1С
					И Найти(ТекстИсточника, ".") > 0
					И Не ирОбщий.ЛиКорневойТипТаблицыБДЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.ЛиКорневойТипПеречисленияЛкс(КорневойТипТаблицы) 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "ВЫБРАТЬ") 
					И Не ирОбщий.СтрНачинаетсяСЛкс(СокрЛ(ТекстИсточника), "SELECT") 
					)   
			Тогда
				Продолжить;
			КонецЕсли;
			СтрокаИсточника = СтрокаЧастиОбъединения.Строки.Вставить(0);
			СтрокаИсточника.Порядок = -СтрокаЧастиОбъединения.Строки.Количество();
			СтрокаИсточника.Имя = Найденное.Подгруппа4;
			СтрокаИсточника.ТипУзла = ТипУзла;
			ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(СтрокаИсточника, ПолеТекстаЗапроса);
		КонецЦикла;
	КонецЦикла;
КонецФункции

Процедура ЗаполнитьСтрокуУпрощеннойСтруктурыЗапроса(Знач СтрокаДерева, Знач ПолеТекстаЗапроса)
	
	лНачальнаяСтрока = 0;
	лНачальнаяКолонка = 0;
	лКонечнаяСтрока = 0;
	лКонечнаяКолонка = 0;
	ПолеТекстаЗапроса.ПолучитьГраницыВыделения(лНачальнаяСтрока, лНачальнаяКолонка, лКонечнаяСтрока, лКонечнаяКолонка);
	СтрокаДерева.Текст = ПолеТекстаЗапроса.ВыделенныйТекст;
	ГраницыДвумерные = Новый Структура();
	ГраницыДвумерные.Вставить("НачальнаяСтрока", лНачальнаяСтрока);
	ГраницыДвумерные.Вставить("НачальнаяКолонка", лНачальнаяКолонка);
	ГраницыДвумерные.Вставить("КонечнаяСтрока", лКонечнаяСтрока);
	ГраницыДвумерные.Вставить("КонечнаяКолонка", лКонечнаяКолонка);
	СтрокаДерева.СтрокаДанных = ГраницыДвумерные;

КонецПроцедуры

///////////////////
// Редактор HTML

Процедура РедакторHTML_Инициировать(ПолеHTML) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ФормаКласса = мПлатформа.ПолучитьМакетКомпоненты(ЭтотОбъект);
	КнопкиМакета = ФормаКласса.ЭлементыФормы.КПРедакторHTML.Кнопки.КонтекстноеМеню.Кнопки;
	КонтекстноеМеню = ПолеHTML.КонтекстноеМеню;
	Если КонтекстноеМеню = Неопределено Тогда
		КонтекстноеМеню = ФормаВладелец.ЭлементыФормы.Добавить(Тип("КоманднаяПанель"), "КонтекстноеМеню" + ПолеHTML.Имя, Ложь);
		КонтекстноеМеню.ИсточникДействий = ПолеHTML;
		ПолеHTML.КонтекстноеМеню = КонтекстноеМеню;
	КонецЕсли;
	ирКлиент.ДобавитьКнопкиКоманднойПанелиКомпонентыЛкс(ЭтотОбъект, КнопкиМакета, КонтекстноеМеню,,, Истина);
	
	ПолеТекстаHTML = ирКлиент.ОболочкаПоляТекстаЛкс(ПолеHTML);
	#Если Сервер И Не Сервер Тогда
		ПолеТекстаHTML = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ПолеТекстаHTML.Инициировать();
	РедакторHTML = ПолеHTML.Документ.defaultView;
	Инфо = Новый СистемнаяИнформация();
	РедакторHTML.minimap(Ложь);
	РедакторHTML.init(Инфо.ВерсияПриложения);
	Если ЯзыкПрограммы = 1 Тогда
		РедакторHTML.setLanguageMode("bsl_query");
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		РедакторHTML.setLanguageMode("dcs_query");
	КонецЕсли; 
	РедакторHTML.setOption("disableContextQueryConstructor", Истина);
	РедакторHTML.setOption("disableNativeSuggestions", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeSignatures", Истина); // События не перестают вызываться
	РедакторHTML.setOption("disableNativeHovers", Истина); // События не перестают вызываться
	РедакторHTML.setOption("skipInsertSuggestionAcceptor", Истина); // Отключаем вставку точки при выборе слова из списка https://github.com/salexdv/bsl_console/issues/120#issuecomment-844372676
	РедакторHTML.setOption("skipAcceptionSelectedSuggestion", Истина); // Отключаем стандартную обработку вставки активного пункта подсказки. Практически 'СтандартнаяОбработка = Ложь'
	РедакторHTML.setOption("renderQueryDelimiters", Истина); // Разделители запросов пакета https://github.com/salexdv/bsl_console/issues/218
	//РедакторHTML.enableBeforeSignatureEvent(Истина);    
	РедакторHTML.setOption("generateBeforeSignatureEvent", Истина);
	//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
	РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
	//РедакторHTML.enableSelectSuggestEvent(Истина);
	РедакторHTML.setOption("generateSelectSuggestEvent", Истина);
	//РедакторHTML.enableBeforeHoverEvent(Истина);
	РедакторHTML.setOption("generateBeforeHoverEvent", Истина);
	//РедакторHTML.enableModificationEvent(Истина);
	РедакторHTML.setOption("generateModificationEvent", Истина);
	РедакторHTML.disableKeyBinding(2082); // CTRL(2048)+D(34) - CTRL+D
	РедакторHTML.disableKeyBinding(2118); // CTRL(2048)+D(70) - F12
	РедакторHTML.setActiveSuggestionAcceptors("."); // По нажатию точки выполняется вставка активного слова и ввод точки // Много нежелательных срабатываний
	
КонецПроцедуры 

Функция ДобавитьПодсказкуПоЗначениюВыражения(Знач ЗначениеВыражения = Неопределено, Знач ОбъектноеВыражение, Знач ПодсказкаМассив, СтруктураТипа = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПодсказкаМассив = Новый Массив;
	#КонецЕсли
	ЕстьОписаниеТипа = Ложь;
	Если СтруктураТипа = Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеВыражения, ЯзыкПрограммы);
	КонецЕсли;
	ИмяТипаЗначения = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	СтрокаОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.Найти(НРег(ИмяОбщегоТипа), "НСлово");
	Если СтрокаОбщегоТипа <> Неопределено Тогда
		ЕстьОписаниеТипа = ЗначениеЗаполнено(СтрокаОбщегоТипа.ПутьКОписанию);
	КонецЕсли;
	Если ИмяТипаЗначения = "Строка" Тогда
		ПодсказкаЗначения = "Знач: """ + ЗначениеВыражения + """";
	Иначе
		Если ТипЗнч(ЗначениеВыражения) = Тип("Строка") Тогда
			ПодсказкаЗначения = ЗначениеВыражения;
		Иначе
			ПодсказкаЗначения = ирОбщий.РасширенноеПредставлениеЗначенияЛкс(ЗначениеВыражения,, Ложь, Истина);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ЗначениеВыражения) = Тип("Неопределено") 
			Или ТипЗнч(ЗначениеВыражения) = Тип("Null")
		Тогда
			ПодсказкаЗначения = "Знач: " + ПодсказкаЗначения;
		Иначе
			ПодсказкаЗначения = "[Знач](" + ОбъектноеВыражение + "): " + ПодсказкаЗначения;
		КонецЕсли; 
		Если ПодсказкаЗначения = ИмяТипаЗначения Тогда
			ПодсказкаЗначения = "";
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + " ";
		КонецЕсли; 
		Если ЕстьОписаниеТипа Тогда
			ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
			ПодсказкаЗначения = ПодсказкаЗначения + "[[" + ИмяТипаЗначения + "]](" + ИмяСсылкиТипа + ")";
			мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, СтруктураТипа);
		Иначе
			ПодсказкаЗначения = ПодсказкаЗначения + "[" + ИмяТипаЗначения + "]";
		КонецЕсли; 
	КонецЕсли; 
	ПодсказкаМассив.Добавить(ПодсказкаЗначения);
	Возврат ИмяТипаЗначения;

КонецФункции

Функция ДобавитьПодсказкуПоДопустимымТипам(Знач ИмяТипаЗначения, Знач ПодсказкаМассив, Знач ОбъектноеВыражение) Экспорт 
	
	ТаблицаСтруктурТипов = ТаблицаСтруктурТиповТекущегоВыражения(Истина, Истина, Ложь);
	Если Истина
		И ЯзыкПрограммы = 1 
		И ТаблицаСтруктурТипов[0].ИмяОбщегоТипа = "ВременнаяТаблица"
		И ТипЗнч(КонтекстВыполнения) = Тип("Запрос")
	Тогда
		ВременныйЗапрос = Новый Запрос;
		ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
		ИмяВременнойТаблицы = ТаблицаСтруктурТипов[0].ВиртуальнаяТаблица.Выражение;
		ВременныйЗапрос.Текст = "ВЫБРАТЬ КОЛИЧЕСТВО(*) ИЗ " + ИмяВременнойТаблицы;
		КоличествоСтрокВТаблице = ВременныйЗапрос.Выполнить().Выгрузить()[0][0];
		ДобавитьПодсказкуПоЗначениюВыражения(ИмяВременнойТаблицы + "(" + КоличествоСтрокВТаблице + ")", ОбъектноеВыражение, ПодсказкаМассив, ТаблицаСтруктурТипов[0]);
	КонецЕсли; 
	ПредставлениеДопустимыхТипов = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов, Истина);
	Если Истина
		И ПредставлениеДопустимыхТипов <> "?"
		И ПредставлениеДопустимыхТипов <> "ОбщийМодуль"
		И ПредставлениеДопустимыхТипов <> "ВременнаяТаблица"
		И ЗначениеЗаполнено(ПредставлениеДопустимыхТипов)
		И ПредставлениеДопустимыхТипов <> ИмяТипаЗначения
	Тогда
		ИмяСсылкиТипа = "_Тип" + XMLСтрока(мСтруктурыТиповПодсказкиУдержания.Количество());
		мСтруктурыТиповПодсказкиУдержания.Вставить(ИмяСсылкиТипа, ТаблицаСтруктурТипов);
		ПредставлениеДопустимыхТипов = "[Допустимые типы](" + ИмяСсылкиТипа + "): " + ПредставлениеДопустимыхТипов;
		ПодсказкаМассив.Добавить(ПредставлениеДопустимыхТипов);
	КонецЕсли;
	Если ПредставлениеДопустимыхТипов <> "ОбщийМодуль" Тогда
		ПодсказкаМассив.Добавить("[Определение](" + XMLСтрока(мКонечнаяСтрока) + "," + XMLСтрока(мКонечнаяКолонка) + ")");
	КонецЕсли; 
	Возврат ПредставлениеДопустимыхТипов;

КонецФункции

Процедура ОткрытьОписаниеТипаПоГиперссылке(Знач ИмяОбщегоТипа) Экспорт 
	
	Если Истина
		И ирОбщий.СтрНачинаетсяСЛкс(ИмяОбщегоТипа, "_Тип")
		И мСтруктурыТиповПодсказкиУдержания.Свойство(ИмяОбщегоТипа) 
	Тогда 
		СтруктураТипа = мСтруктурыТиповПодсказкиУдержания[ИмяОбщегоТипа];
		Если ТипЗнч(СтруктураТипа) = Тип("ТаблицаЗначений") Тогда
			ТаблицаДляПользователя = мПлатформа.ТаблицаСтруктурТиповДляПользователя(СтруктураТипа, Ложь);
			СписокВыбора = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из ТаблицаДляПользователя Цикл
				Если ирОбщий.СтрокиРавныЛкс(СтрокаТаблицы.Имя, "null") Тогда
					Продолжить;
				КонецЕсли; 
				СписокВыбора.Добавить(СтрокаТаблицы.СтруктураТипа, СтрокаТаблицы.Имя);
			КонецЦикла;
			СписокВыбора = ирОбщий.СвернутьСписокЗначенийПоПредставлениюЛкс(СписокВыбора);
			Если СписокВыбора.Количество() = 1 Тогда
				СтруктураТипа = СписокВыбора[0];
			Иначе
				СтруктураТипа = СписокВыбора.ВыбратьЭлемент("Выберите тип значения"); 
				Если СтруктураТипа = Неопределено Тогда
					Возврат;
				КонецЕсли; 
			КонецЕсли; 
			СтруктураТипа = СтруктураТипа.Значение;
		КонецЕсли; 
		ОткрытьОпределениеСтруктурыТипа(СтруктураТипа, Истина);
	Иначе
		ирКлиент.ОткрытьОписаниеТипаПоИмениТипаЛкс(ИмяОбщегоТипа);
	КонецЕсли; 

КонецПроцедуры

// антибаг редактора https://github.com/salexdv/bsl_console/issues/78#issuecomment-836447865
Функция ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово) Экспорт 
	
	Возврат ирОбщий.ТекстМеждуМаркерамиЛкс(ВыбранноеСлово, "Элемент ", ",", Истина);

КонецФункции

Процедура РедакторHTML_ПередПоказомПодсказкиУдержания(Знач Событие, Знач ФункцияВычислитьВыражение) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	НомерКолонки23 = Событие.params.column;
	НомерСтроки23 = Событие.params.line; 
	ТекущееСлово = Событие.params.word;
	мСтруктурыТиповПодсказкиУдержания = Новый Структура;
	Если ТекущееСлово = Неопределено Тогда 
		Возврат;
	КонецЕсли; 
	КончитьОбработкуКоманды();
	ОбъектноеВыражение = ТекущееОбъектноеВыражение(НомерСтроки23, НомерКолонки23,, Ложь);
	ПодсказкаМассив = Новый Массив;
	Если Истина
		И (Ложь
			Или Найти(ОбъектноеВыражение, "(") = 0 
			Или ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "(") 
			Или ирОбщий.СтрНачинаетсяСЛкс(ОбъектноеВыражение, "("))
		И (Ложь
			Или ирОбщий.ЛиИмяПеременнойЛкс(Лев(ОбъектноеВыражение, 1)) 
			Или Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра
			Или Лев(ОбъектноеВыражение, 1) = "(")
	Тогда
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		ИмяТипаЗначения = "";
		Если Ложь
			Или (ЯзыкПрограммы > 0 И Лев(ОбъектноеВыражение, 1) = мПараметрыДиалектаSQL.ПрефиксПараметра)
			Или (ЯзыкПрограммы = 0 И Не ирОбщий.СтрКончаетсяНаЛкс(ОбъектноеВыражение, "("))
		Тогда
			УспехЗначения = Истина;
			ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ОбъектноеВыражение, УспехЗначения)");
			Если УспехЗначения Тогда
				ИмяТипаЗначения = ДобавитьПодсказкуПоЗначениюВыражения(ЗначениеВыражения, ОбъектноеВыражение, ПодсказкаМассив);
			КонецЕсли; 
		КонецЕсли; 
		ПредставлениеДопустимыхТипов = ДобавитьПодсказкуПоДопустимымТипам(ИмяТипаЗначения, ПодсказкаМассив, ОбъектноеВыражение);
	КонецЕсли; 
	КончитьОбработкуКоманды();
	СтруктураПодсказки = Новый Соответствие;
	СтруктураПодсказки.Вставить(ТекущееСлово.word, ПодсказкаМассив);
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.setCustomHovers(ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки));

КонецПроцедуры

Процедура РедакторHTML_ПередПоказомСигнатуры(НомерПараметра, ИмяМетодаОтРедактора, НомерСигнатуры, Триггер) Экспорт 
	
	Если РазрешеноСобытиеПередПоказомАвтодополнения = Ложь Или НомерСигнатуры > 0 Тогда
		// https://github.com/salexdv/bsl_console/issues/182
		РазрешеноСобытиеПередПоказомАвтодополнения = Истина;
		Возврат;
	КонецЕсли; 
	Если Триггер <> Неопределено И Не АвтоматическаяПодсказкаПоВызовуМетода() Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSignatureList();
	Если Не ЛиДоступноОткрытиеСвободнойФормы() Тогда 
		КончитьОбработкуКоманды();
		ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
		СтруктураПодсказки = СтруктураПодсказкиМетода(, Триггер <> Неопределено);
		Если СтруктураПодсказки.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		ВариантыСинтаксиса = Новый Соответствие;
		ВариантыСинтаксиса.Вставить(ирОбщий.ПоследнийФрагментЛкс(ИмяМетодаОтРедактора, " "), СтруктураПодсказки);
		РедакторHTML.setCustomSignatures(ирОбщий.ОбъектВСтрокуJSONЛкс(ВариантыСинтаксиса));
		//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
		РазрешеноСобытиеПередПоказомАвтодополнения = Ложь;
		РедакторHTML.triggerSigHelp();
		//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
		РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		//ИмяМетодаОтРедактора = ФормаВызовМетода.ИмяМетода;
		//НомерПараметра = мНомерПараметра - 1;
	КонецЕсли;

КонецПроцедуры

Функция СтруктураПодсказкиМетода(Знач ПараметрПостояннаяСтруктураТипа = Неопределено, Знач ТолькоПолезноеОписание = Истина, Знач ДляСпискаАвтодополнения = Ложь)
	
	СтруктураПодсказки = Новый Массив;
	ФормаВызовМетода = ФормаВызовМетода();
	ФормаВызовМетода.ПараметрПостояннаяСтруктураТипа = ПараметрПостояннаяСтруктураТипа;
	ФормаВызовМетода.ОбновитьИлиЗакрытьФорму(, Истина);
	Если Не ФормаВызовМетода.ЕстьПолезнаяИнформация И ТолькоПолезноеОписание Тогда
		Возврат СтруктураПодсказки;
	КонецЕсли; 
	Для ИндексВарианта = 0 По ФормаВызовМетода.ВариантыСинтаксиса.Количество() - 1 Цикл
		Если Истина
			И ФормаВызовМетода.ВариантыСинтаксиса.Количество() > 1 
		Тогда
			ФормаВызовМетода.УстановитьВариантСинтаксисаПоИндексу(ИндексВарианта);
		КонецЕсли; 
		ПодсказкаСлова = Новый Структура();
		ПараметрыМетода = Новый Массив;
		КраткиеОписанияПараметров = Новый Массив;
		Для Каждого СтрокаПараметра Из ФормаВызовМетода.ТаблицаПараметров Цикл
			ЛиНеОбязательный = ФормаВызовМетода.ЛиНеОбязательныйПараметр(СтрокаПараметра);
			СтруктураПараметра = Новый Структура();
			КраткоеПредставлениеПараметра = "" 
			//+ ?(СтрокаПараметра.Знач = "Знач", "`", СтрокаПараметра.Знач) 
			+ СтрокаПараметра.Имя 
			+ ?(ЛиНеОбязательный, "?", "");
			// Мало пользы, лишние неудобства при поиске нужного параметра. Поэтому пока отключено
			//Если ЗначениеЗаполнено(СтрЗаменить(СтрокаПараметра.ТипЗначения, "?", "")) Тогда
			//	КраткоеПредставлениеПараметра = КраткоеПредставлениеПараметра + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 20) + "]";
			//КонецЕсли; 
			КраткиеОписанияПараметров.Добавить(КраткоеПредставлениеПараметра);
			СтруктураПараметра.Вставить("label", КраткоеПредставлениеПараметра);
			ОписаниеПараметра = 
			"Обяз.: " + ?(Не ЛиНеОбязательный, "Да", "Нет, " + СтрокаПараметра.Значение) + ";  Возвр.: " + ?(Не ЗначениеЗаполнено(СтрокаПараметра.Знач), "?", ?(СтрокаПараметра.Знач = "Знач", "Нет", "Да")) + "
			|Тип: " + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(СтрокаПараметра.ТипЗначения), 200) + ".";
			Если ЗначениеЗаполнено(СтрокаПараметра.Описание) Тогда
				ОписаниеПараметра = ОписаниеПараметра + "
				|> " + СтрокаПараметра.Описание;
			КонецЕсли; 
			СтруктураПараметра.Вставить("documentation", ОписаниеПараметра);
			ПараметрыМетода.Добавить(СтруктураПараметра);
		КонецЦикла;
		ПредставлениеМетода = "";
		Если Не ДляСпискаАвтодополнения Тогда
			ПредставлениеМетода = ПредставлениеМетода + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(ФормаВызовМетода.ИмяМетода, 13);
		КонецЕсли; 
		ПредставлениеМетода = ПредставлениеМетода + "(" + ирОбщий.СтрСоединитьЛкс(КраткиеОписанияПараметров, ", ") + ")";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТипЗначенияМетода) Тогда
			Если Не ДляСпискаАвтодополнения Тогда
				ПредставлениеМетода = ПредставлениеМетода + " [" + ирОбщий.ПредставлениеЗначенияСОграничениемДлиныЛкс(СокрЛП(ФормаВызовМетода.ТипЗначенияМетода), 15) + "]";
			КонецЕсли; 
		КонецЕсли; 
		ПодсказкаСлова.Вставить("label", ПредставлениеМетода);
		ПодсказкаСлова.Вставить("parameters", ПараметрыМетода);
		ОписаниеМетода = "";
		Если ЗначениеЗаполнено(ФормаВызовМетода.ТекущийВариант) Тогда
			ОписаниеМетода = ОписаниеМетода + "Вариант: " + ФормаВызовМетода.ТекущийВариант + "." + Символы.ПС;
		КонецЕсли;
		ОписаниеМетода = ОписаниеМетода + ФормаВызовМетода.ОписаниеМетода;
		ПодсказкаСлова.Вставить("documentation", ОписаниеМетода);
		СтруктураПодсказки.Добавить(ПодсказкаСлова);
	КонецЦикла;
	Возврат СтруктураПодсказки;

КонецФункции

Процедура РедакторHTML_ПередПоказомАвтодополнения(Триггер, ПоследнееВыражение, ПоследнееСлово)  Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	//РедакторHTML.hideSuggestionsList();
	ПоказатьСписок = МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово);
	//Сообщить(Триггер);
	Если ПоказатьСписок Тогда 
		Если Триггер = "backspace" Тогда
			//РедакторHTML.enableBeforeShowSuggestEvent(Ложь);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
			РедакторHTML.showPreviousCustomSuggestions();
			//РедакторHTML.enableBeforeShowSuggestEvent(Истина);
			РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
		Иначе
			ФормаВызовМетода = ФормаВызовМетода();
			Если ФормаВызовМетода.Открыта() Тогда
				ФормаВызовМетода.Закрыть();
			КонецЕсли; 
			КончитьОбработкуКоманды();
			ФормаВладелец.КлсПолеТекстаПрограммыОбновитьКонтекст(ЭтотОбъект);
			РазобратьТекущийКонтекст(,,,,, Истина);
			Если ЯзыкПрограммы = 0 И Триггер = """" Тогда
				ПоказатьСписок = мЭтоСтроковыйЛитерал;
			ИначеЕсли Истина
				И Триггер <> "space"
				И ЯзыкПрограммы = 1 
				И мЭтоОбъявлениеПсевдонима 
			Тогда
				ПоказатьСписок = Ложь;
			Иначе
				ПоказатьСписок = Не (мКонтекст = "" И Триггер = ".");
			КонецЕсли; 
			Если Не ПоказатьСписок Тогда 
				Возврат;
			КонецЕсли;
			//РедакторHTML.enableSuggestActivationEvent(Истина, Истина);  // Второй параметр включает отображение типов для всех слов списка автодополнения https://github.com/salexdv/bsl_console/issues/119
			РедакторHTML.setOption("generateSuggestActivationEvent", Истина);
			РедакторHTML.setOption("alwaysDisplaySuggestDetails", Истина);
			
			УспехЗаполнения = ЗаполнитьТаблицуСлов(, мКонкретныйТипКонтекста, мСтруктураТипаКонтекста, Триггер = "space", Истина, Ложь);
			Если Истина
				И УспехЗаполнения
				И (Ложь
					Или Триггер = "space"
					Или ТаблицаСлов.Количество() > 0)
			Тогда
				СтруктураПодсказки = Новый Массив;
				КодыТиповСлов = Новый Структура;
				СоответствиеТипаСлова();
				Для Каждого СтрокаСоответствия Из мСоответствиеТиповСловHTML Цикл
					Если Не ЗначениеЗаполнено(СтрокаСоответствия.Имя) Тогда
						Продолжить;
					КонецЕсли; 
					КодыТиповСлов.Вставить(СтрокаСоответствия.Имя, СоответствиеТипаСлова(СтрокаСоответствия.Имя).Код);
				КонецЦикла; 
				Для Каждого СтрокаСлова Из ТаблицаСлов Цикл
					ПодсказкаСлова = Новый Структура();
					ПодсказкаСлова.Вставить("name", СтрокаСлова.Слово);
					//ТекстВставки = СтрокаСлова.Слово;
					//ПодсказкаСлова.Вставить("text", ТекстВставки); // Закомментировал, т.к. пользы от этого нет, а вред есть https://github.com/salexdv/bsl_console/issues/171
					ПодсказкаСлова.Вставить("kind", КодыТиповСлов[СтрокаСлова.ТипСлова]);
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					Если СтрокаСлова.ТипСлова = "Конструкция" Тогда
						ПодсказкаСлова.Вставить("sort", "-1"); // https://www.hostedredmine.com/issues/963233
					КонецЕсли;
					ПодсказкаСлова.Вставить("detail", СтрокаСлова.ТипЗначения);
					ПодсказкаСлова.Вставить("documentation", "_"); // Нужно чтобы окно детального описания открывалось
					СтруктураПодсказки.Добавить(ПодсказкаСлова);
				КонецЦикла;
				СтрокаСпискаАвтодополненияHTML = ирОбщий.ОбъектВСтрокуJSONЛкс(СтруктураПодсказки);
				Если СтрокаСпискаАвтодополненияHTML <> Неопределено Тогда
					РедакторHTML.setOption("showSnippetsOnCustomSuggestions", мСтруктураТипаКонтекста.ИмяОбщегоТипа = "Локальный"); // Штатные сниппеты https://github.com/salexdv/bsl_console/issues/200
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Ложь);
					РедакторHTML.showCustomSuggestions(СтрокаСпискаАвтодополненияHTML);
					РедакторHTML.setOption("generateBeforeShowSuggestEvent", Истина);
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

//.
// Параметры:
//    Триггер - Строка - 
//    ПоследнееВыражение - Строка - 
//    ПоследнееСлово - Строка - 
// Возвращаемое значение:
//    Булево - 
Функция МожноПоказатьСписокСлов(Триггер, ПоследнееВыражение, ПоследнееСлово) Экспорт
	Последние2Символа = Прав(ПоследнееВыражение, 2);
	ПрефиксПараметра = мПараметрыДиалектаSQL.ПрефиксПараметра;
	ОтображатьСписок = Ложь
		Или Триггер = "space"
		Или (Истина
			И АвтоматическаяПодсказкаАвтодополненияHTML()
			И (Ложь
				Или Триггер = Неопределено // ввод буквы или после выбора слова списка вводом "."
				Или Триггер = "." И Последние2Символа <> ".."
				Или ЯзыкПрограммы <> 0 И Триггер = ПрефиксПараметра И Последние2Символа <> (ПрефиксПараметра + ПрефиксПараметра)
				Или ЯзыкПрограммы = 0 И Триггер = """" И Последние2Символа <> """"""
				Или ирОбщий.ЛиИмяПеременнойЛкс(Триггер) // Иначе слишком часто вызывается затратное обновление списка слов локального контекста
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "новый")
				Или ЯзыкПрограммы = 0 И ирОбщий.СтрокиРавныЛкс(ПоследнееСлово, "new")));
	Возврат ОтображатьСписок;
КонецФункции

Функция СоответствиеТипаСлова(Знач ВстроенныйТипСлова = "", Знач ИмяКлюча = "Имя")
	
	Если мСоответствиеТиповСловHTML = Неопределено Тогда
		мСоответствиеТиповСловHTML = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ТипыСловHTML"));
		#Если Сервер И Не Сервер Тогда
			мСоответствиеТиповСловHTML = Новый ТаблицаЗначений;
		#КонецЕсли
		мСоответствиеТиповСловHTML.Колонки.Добавить("НКод");
		мСоответствиеТиповСловHTML.Индексы.Добавить("Имя");
		мСоответствиеТиповСловHTML.Индексы.Добавить("НКод");
		Для Каждого СтрокаТЗ Из мСоответствиеТиповСловHTML Цикл
			СтрокаТЗ.НКод = НРег(СтрокаТЗ.Код);
		КонецЦикла;
	КонецЕсли;
	НайденнаяСтрока = мСоответствиеТиповСловHTML.Найти(ВстроенныйТипСлова, ИмяКлюча);
	//Если НайденнаяСтрока = Неопределено Тогда
	//	НайденнаяСтрока = мСоответствиеТиповСловHTML[0];
	//КонецЕсли;
	Возврат НайденнаяСтрока;

КонецФункции

Процедура РедакторHTML_ПриВыбореСтрокиАвтодополнения(Триггер, ПоследнееВыражение, ВыбранноеСлово, ТипСловаHTML, ТекстВставки, ПоследнееСлово) 
	
	Если ирОбщий.СтрНачинаетсяСЛкс(Триггер, "force-") Тогда
		ПараметрЗакрытия = Прав(Триггер, 1);
		Если Найти(ПоследнееВыражение, ".") > 0 Тогда
			ВыделенныйТекст(ПараметрЗакрытия);
			Возврат;
		КонецЕсли; 
	Иначе
		ПараметрЗакрытия = Истина;
	КонецЕсли; 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideSuggestionsList();
	КончитьОбработкуКоманды();
	РазобратьТекущийКонтекст(,,,,, Истина);
	ОтборСлов = Новый Структура("Слово", ЧистоеСловоСпискаПодсказкиHTML(ВыбранноеСлово));
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		мНачальнаяКолонка = мНачальнаяКолонка - СтрДлина(ПоследнееСлово);
		УстановитьГраницыВыделения();
		РедакторHTML.insertSnippet(ТекстВставки);
		Возврат;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТипСлова)  Тогда
		ОтборСлов.Вставить("ТипСлова", ТипСлова);
	КонецЕсли; 
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(ОтборСлов);
	Если НайденныеСтроки.Количество() = 0 Тогда
		//Возврат;
		НоваяСтрока = ТаблицаСлов.Добавить();
		НоваяСтрока.Слово = ВыбранноеСлово;
		НоваяСтрока.ТипСлова = "Свойство";
		НайденныеСтроки = ирОбщий.ЗначенияВМассивЛкс(НоваяСтрока);
	КонецЕсли; 
	СтрокаТаблицыСлов = НайденныеСтроки[0];
	ВставитьВыбранноеСловоАвтодополнения(СтрокаТаблицыСлов,, ПараметрЗакрытия);
	Если ПараметрЗакрытия = "." Тогда
		РедакторHTML.triggerSuggestions();
	КонецЕсли; 
	Если мОткрытьСправкуПоПараметру = Истина Тогда
		Если ЛиДоступноОткрытиеСвободнойФормы() Тогда 
			ОткрытьСправкуПоПараметру(, Ложь); 
		Иначе
			РедакторHTML.triggerSigHelp();
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Функция ТипСловаИзТипаСловаHTML(Знач ТипСловаHTML)
	
	Перем ТипСлова;
	
	ТипСлова = СоответствиеТипаСлова(ирОбщий.ПоследнийФрагментЛкс(ТипСловаHTML, "-"), "НКод").Имя;
	Возврат ТипСлова;

КонецФункции

Функция ЛиДоступноОткрытиеСвободнойФормы()
	
	Возврат Не (Ложь
		Или ирКэш.ЛиСеансТолстогоКлиентаУПЛкс() 
		Или ФормаВладелец <> Неопределено И ФормаВладелец.МодальныйРежим);

КонецФункции

Процедура РедакторHTML_ОбработатьСобытие(Событие) Экспорт 
	//Сообщить("Отладка. " + Событие.event);
	Попытка
		Если Событие.event = "EVENT_BEFORE_SIGNATURE" Тогда
			РедакторHTML_ПередПоказомСигнатуры(Событие.params.activeParameter, Событие.params.word, Событие.params.activeSignature, Событие.params.triggerCharacter);
		ИначеЕсли Событие.event = "EVENT_ON_SELECT_SUGGEST_ROW" Тогда
			РедакторHTML_ПриВыбореСтрокиАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.selected, Событие.params.kind, Событие.params.insert_text, Событие.params.last_word);
		ИначеЕсли Ложь
			Или Событие.event = "EVENT_ON_ACTIVATE_SUGGEST_ROW"
			Или Событие.event = "EVENT_ON_DETAIL_SUGGEST_ROW"
		Тогда
			РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Событие.params.trigger, Событие.params.focused, Событие.params.row_id, Событие.params.sideDetailIsOpened, Событие.params.kind);
		ИначеЕсли Событие.event = "EVENT_BEFORE_SHOW_SUGGEST" Тогда
			РедакторHTML_ПередПоказомАвтодополнения(Событие.params.trigger, Событие.params.last_expression, Событие.params.last_word);
		КонецЕсли;
	Исключение
		// Антибаг платформы https://www.hostedredmine.com/issues/962188
		ирОбщий.СообщитьЛкс(ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

Процедура РедакторHTML_ПриАктивацииСтрокиАвтодополнения(Триггер, ТекущееСлово, НомерСлова, ЛиОтдельноеОписаниеАктивно, ТипСловаHTML) Экспорт 
	
	// Показывать надо обязательно каждый раз, т.к. редактор забывает предыдущие уточнения типа
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТипСлова = ТипСловаИзТипаСловаHTML(ТипСловаHTML);
	Если ТипСлова = "Шаблон" Тогда
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	СтрокаТаблицыСлов = ТаблицаСлов.Найти(ЧистоеСловоСпискаПодсказкиHTML(ТекущееСлово), "Слово");
	Если СтрокаТаблицыСлов <> Неопределено Тогда
		ТаблицаСтруктурТипов = УточнитьТипЗначенияВСтрокеТаблицыСлов(мСтруктураТипаКонтекста, СтрокаТаблицыСлов, ЛиОтдельноеОписаниеАктивно);
		СтруктураОписания = Новый Массив;
		Если мСтруктураТипаКонтекста.Конструктор Тогда
			ДетальноеОписаниеДляСписка = "";
		Иначе
			ДетальноеОписаниеДляСписка = СтрокаТаблицыСлов.ТипЗначения;
			Если ЗначениеЗаполнено(ДетальноеОписаниеДляСписка) Тогда
				СтруктураОписания.Добавить("> Тип: " + ДетальноеОписаниеДляСписка);
			КонецЕсли; 
		КонецЕсли; 
		Если ЛиОтдельноеОписаниеАктивно И ТаблицаСтруктурТипов <> Неопределено Тогда 
			Если Ложь
				Или мСтруктураТипаКонтекста.Конструктор
				Или СтрокаТаблицыСлов.ТипСлова = "Метод" 
			Тогда
				Если мСтруктураТипаКонтекста.Конструктор Тогда
					СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
					СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
					ТаблицаСтруктурТипов = мПлатформа.СвойстваТипаПредопределенные(СтруктураТипа, СтрокаТаблицыСлов.Слово, "Конструктор",, ЯзыкПрограммы, Конфигурация)[0].ТаблицаСтруктурТипов;
				КонецЕсли; 
				//ПараметрыМетода = мПлатформа.ПараметрыМетодаПлатформы(ТаблицаСтруктурТипов[0]);
				СтруктураПодсказкиМетода = СтруктураПодсказкиМетода(ТаблицаСтруктурТипов[0], Триггер <> Неопределено, Истина);
				Если СтруктураПодсказкиМетода.Количество() > 0 Тогда
					СтруктураОписания.Вставить(0, "> Параметры: " + СтруктураПодсказкиМетода[0].label);
					Если СтруктураПодсказкиМетода.Количество() > 1 Тогда
						СтруктураОписания.Вставить(0, "> Варианты: " + СтруктураПодсказкиМетода.Количество());
					КонецЕсли; 
					ОписаниеСлова = СтруктураПодсказкиМетода[0].documentation;
					Если ЗначениеЗаполнено(ОписаниеСлова) Тогда
						СтруктураОписания.Добавить("> Описание: " + ОписаниеСлова);
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		СтруктураОписания.Добавить("> Определение: " + СтрокаТаблицыСлов.Определение);
		ДетальноеОписаниеОтдельное = ирОбщий.СтрСоединитьЛкс(СтруктураОписания, Символы.ПС);
		Если Триггер = "hover" Тогда
			РедакторHTML.setSuggestItemDetailById(НомерСлова, ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное);
		Иначе
			МаксВысотаТочек = 800;
			РедакторHTML.setActiveSuggestDetail(ДетальноеОписаниеДляСписка, ДетальноеОписаниеОтдельное, МаксВысотаТочек);
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура РедакторHTML_ОтключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	// Коды клавиш https://microsoft.github.io/monaco-editor/api/enums/monaco.keycode.html
	РедакторHTML.disableKeyBinding(512+16); // ALT(512)+ArrowUp(16)
	РедакторHTML.disableKeyBinding(512+18); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ВключитьСочетанияПереключенияСигнатуры() Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	// https://github.com/salexdv/bsl_console/issues/130
	РедакторHTML.enableKeyBinding(528); // ALT(512)+ArrowUp(16)
	РедакторHTML.enableKeyBinding(530); // ALT(512)+ArrowDown(18)
	
КонецПроцедуры

Процедура РедакторHTML_ОбработатьКликНаГиперссылке(Событие, ФункцияПерейтиКОпределению, ФункцияВычислитьВыражение) Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	Если ПолеТекста.ОбработатьКликНаГиперссылке(Событие) Тогда 
		Возврат;
	КонецЕсли; 
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.hideHoverList();
	ЗаголовокГиперссылки = Событие.params.label;
	ЗначениеГиперссылки = Событие.params.href;
	Если ЗаголовокГиперссылки = "Определение" Тогда
		Координаты = ирОбщий.СтрРазделитьЛкс(ЗначениеГиперссылки, ",");
		НомерСтроки = Число(Координаты[0]);
		НомерКолонки = Число(Координаты[1]);
		Если Не Вычислить("ФормаВладелец." + ФункцияПерейтиКОпределению + "(НомерСтроки, НомерКолонки)") Тогда 
			ПерейтиКОпределению(НомерСтроки, НомерКолонки);
		КонецЕсли; 
	ИначеЕсли ЗаголовокГиперссылки = "Знач" Тогда
		УспехВычисления = Истина;
		ЗначениеВыражения = Вычислить("ФормаВладелец." + ФункцияВычислитьВыражение + "(ЗначениеГиперссылки, УспехВычисления)");
		Если УспехВычисления Тогда
			ирКлиент.ОткрытьЗначениеЛкс(ЗначениеВыражения);
		КонецЕсли; 
	ИначеЕсли Ложь
		Или Лев(ЗаголовокГиперссылки, 1) = "["
		Или ЗаголовокГиперссылки = "Допустимые типы" 
	Тогда
		ОткрытьОписаниеТипаПоГиперссылке(ЗначениеГиперссылки);
	Иначе
		ОткрытьКонтекстнуюСправку(ЗначениеГиперссылки);
	КонецЕсли;
КонецПроцедуры

Процедура КомандаРедактораHTML(Команда)
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.editor.trigger("", Команда);
КонецПроцедуры

Процедура ЗаменитьВхожденияHTML()
	КомандаРедактораHTML("editor.action.changeAll");
КонецПроцедуры

Процедура СочетанияКлавишHTML()
	ирКлиент.ОткрытьТекстЛкс(ПолучитьМакет("СочетанияКлавишHTML").ПолучитьТекст(), "Сочетания клавиш HTML редактора", "Обычный", Истина, "СочетанияКлавишHTML");
КонецПроцедуры

Процедура ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока)
	
	Конструктор = Новый КонструкторФорматнойСтроки();
	Попытка
		Конструктор.Текст = ФорматнаяСтрока;
	Исключение
		Инфо = ИнформацияОбОшибке();
		ирОбщий.СообщитьЛкс("Ошибка в тексте форматной строки:" + Символы.ПС + Инфо.Причина.Описание);
		Возврат;
	КонецПопытки;
	Если Конструктор.ОткрытьМодально() Тогда
		Результат = Конструктор.Текст;
		Результат = СтрЗаменить(Результат, "'", "");
		Результат = """" + Результат + """";
		ВыделенныйТекст(Результат);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КонструкторФорматнойСтроки()
	
	ФорматнаяСтрока = СтрЗаменить(СтрЗаменить(ВыделитьТекстовыйЛитерал(), "|", ""), """", "");
	ОткрытьКонструкторФорматнойСтроки(ФорматнаяСтрока);
	
КонецПроцедуры

Процедура НайтиСледующееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.nextMatch();

КонецПроцедуры

Процедура НайтиПредыдущееHTML()
	
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	РедакторHTML = ПолеТекста.РедакторHTML();
	РедакторHTML.previousMatch();
	
КонецПроцедуры

Процедура РедакторHTML_Перерисовать() Экспорт 
	#Если Сервер И Не Сервер Тогда
		ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	//ПолеТекста.Перерисовать();
	//ОбновитьПодсказкуПоВызовуМетода();
КонецПроцедуры

Процедура ПанельРедактораКодаПриСменеСтраницы(Знач ПанельРедактора, Знач Поле1, Знач Поле2, Знач ИсходныйТекст) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		Поле1 = Обработки.ирОболочкаПолеТекста.Создать();
		Поле2 = Обработки.ирОболочкаПолеТекста.Создать();
	#КонецЕсли
	ТекущаяСтраница = ПанельРедактора.ТекущаяСтраница;
	Если ТекущаяСтраница = ПанельРедактора.Страницы.РедакторHTML Тогда
		ЭтотОбъект.ПолеТекста = Поле2;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле1, ИсходныйТекст);
	Иначе
		ЭтотОбъект.ПолеТекста = Поле1;
		ПолеТекста.ЗагрузитьСостояниеИзПоляТекстаЛкс(Поле2, ИсходныйТекст);
	КонецЕсли;

КонецПроцедуры

#КонецЕсли

// Добавляет правило вычисления типа значения функции.
// При вызове правила вычисляется "Правило(<СтрокаАргументов>)", а оно должно вернуть ТаблицаСтруктурТипов.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено;
//  *Метаданные  - Произвольный, *Неопределено;
//
Процедура ДобавитьПравилоВычисленияФункции(Слово, Правило, ТипКонтекста = "Локальный") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("НСлово", Нрег(Слово));
	КлючСтроки.Вставить("ТипКонтекста", ТипКонтекста);
	НайденныеСтроки = мПравилаВычисленияФункций.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = мПравилаВычисленияФункций.Добавить();
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	НоваяСтрока.Правило = Правило;
	НоваяСтрока.Слово = Слово;

КонецПроцедуры

Процедура УстановитьКонфигурациюМетаданных(пКонфигурация = Неопределено, пКонтекстВыполнения = Неопределено, Знач ДиалектSQL = Неопределено, РасширенноеПолучениеМетаданныхADO = Ложь) Экспорт

	//Если ЯзыкПрограммы = 1 Тогда
		Если ДиалектSQL = Неопределено Тогда
			Если пКонфигурация <> Неопределено Тогда
				ЭтотОбъект.Конфигурация = пКонфигурация;
			Иначе
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			КонецЕсли; 
			Если ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
				ЭтотОбъект.мДиалектSQL = "1С";
			Иначе
				ЭтотОбъект.мДиалектSQL = "MSSQL";
				Попытка
					Пустышка = Конфигурация.Provider;
				Исключение
					Пустышка = Неопределено;
				КонецПопытки;
				Если Пустышка <> Неопределено Тогда
					// Это ADODB.Connection
					Если Конфигурация.State = 1 Тогда
						ДиалектSQL = Конфигурация.Properties("DBMS Name").Value;
					Иначе
						// Не меняем мДиалектSQL!
					КонецЕсли; 
				Иначе
					ДиалектSQL = "WQL";
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
			Иначе
				ЭтотОбъект.Конфигурация = пКонфигурация;
			КонецЕсли; 
		КонецЕсли;
		Если мДиалектыSQL = Неопределено Тогда
			Если мПлатформа.мДиалектыSQL = Неопределено Тогда
				мПлатформа.мДиалектыSQL = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ПолучитьМакет("ДиалектыSQL"),,, Ложь, Истина);
			КонецЕсли; 
			ЭтотОбъект.мДиалектыSQL = мПлатформа.мДиалектыSQL;
		КонецЕсли; 
		Если мДиалектыSQL.Найти(ДиалектSQL, "Диалект") <> Неопределено Тогда 
			ЭтотОбъект.мДиалектSQL = ДиалектSQL;
		КонецЕсли; 
		ЭтотОбъект.мПараметрыДиалектаSQL = мДиалектыSQL.Найти(мДиалектSQL, "Диалект");
		ЭтотОбъект.мРасширенноеПолучениеМетаданныхADO = РасширенноеПолучениеМетаданныхADO = Истина;
	//Иначе
	//	Если пКонфигурация <> Неопределено Тогда
	//		ЭтотОбъект.Конфигурация = пКонфигурация;
	//	Иначе
	//		ЭтотОбъект.Конфигурация = мПлатформа.мМетаданные;
	//	КонецЕсли; 
	//КонецЕсли;
	
	//Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
	//	мДоступныеТаблицыПолучены = Истина;
	//ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
	//	//ЗаполнитьДоступныеТаблицыWQL(); // Слишком долго
	//	мДоступныеТаблицыПолучены = Истина;
	//Иначе
	//	мДоступныеТаблицыПолучены = Ложь;
	//КонецЕсли; 
	ЭтотОбъект.КонтекстВыполнения = пКонтекстВыполнения;

КонецПроцедуры

// Очишает таблицу слов локального контекста.
//
// Параметры:
//  Нет.
//
Процедура ОчиститьТаблицуСловЛокальногоКонтекста() Экспорт
	Если мМетодМодуля = Неопределено Тогда
		// Для консоли кода без режима Модуль
		Возврат;
	КонецЕсли;
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова();
	ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова("Метод");
КонецПроцедуры

Процедура ОчиститьТаблицуСловЛокальногоКонтекстаПоТипуСлова(Знач ТипСлова = "Свойство")
	ОтборСтрок = Новый Структура("ПозицияСОписанием", Неопределено);
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	ВыбранныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(ОтборСтрок);
	Для Каждого ВыбраннаяСтрока Из ВыбранныеСтроки Цикл
		ВыбраннаяСтрока.ТаблицаСтруктурТипов = Неопределено; // Мультиметка4529884 Разрываем циклические ссылки во вложенной колонке СтрокаОписания. Возможно уже не нужно
		ТаблицаЛокальногоКонтекста.Удалить(ВыбраннаяСтрока);
	КонецЦикла;
КонецПроцедуры

Функция ПроверитьТекстИВернутьОшибку(ТекстДляПроверки = Неопределено, СтартоваяСтрока = 0, СтартоваяКолонка = 0, Контекст = Неопределено, СамаяВложеннаяПричина = Ложь) Экспорт

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ТекстИнициализации = "";
	Если ЯзыкПрограммы = 0 Тогда 
		Если мМодульМетаданных <> Неопределено Тогда
			Для Каждого ЛокальноеСлово Из мМодульМетаданных.Переменные Цикл
				Если ТипТекста = "Алгоритм" Тогда
					ТекстИнициализации = ЛокальноеСлово.Имя + " = 0; " + ТекстИнициализации;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Для Каждого СтрокаПараметра Из Параметры Цикл
			Если ТипТекста = "Алгоритм" И СтрокаПараметра.Вход Тогда
				ТекстИнициализации = СтрокаПараметра.Имя + " = 0; " + ТекстИнициализации;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 

	Если ТекстДляПроверки = Неопределено Тогда
		ТекстДляПроверки = ПолеТекста.ПолучитьТекст();
		Если Не ЭтоМодуль И мМодульМетаданных <> Неопределено И мМодульМетаданных.Методы.Количество() > 0 Тогда
			ВызватьИсключение "Текст программы не допускает определения методов";
		КонецЕсли;
	КонецЕсли; 
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	Если ЯзыкПрограммы = 1 Тогда
		ТекстЗапроса = ТекстДляПроверки;
		Если ТекстЗапроса <> "" Тогда
			Если ТипТекста = "Выражение" Тогда
				лКонтекстВыполнения = КонтекстВыполнения;
				лМетодВыполнения = МетодВыполнения;
				Попытка
					ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстЗапроса, Истина);
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
				КонецПопытки;
				СтартоваяСтрока = -1;
			Иначе
				Если мДиалектSQL <> "1С" Тогда
					РезультатРазбора = Ложь;
					#Если Клиент Тогда
					РезультатРазбора = ЗагрузитьТекстВКонструктор(ТекстЗапроса);
					#КонецЕсли
					Если Не РезультатРазбора Тогда
						ИнформацияОбОшибке = 1;
					КонецЕсли; 
				Иначе
					Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
						ПроверочныйЗапрос = Новый Запрос;
						ПроверочныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
						ПроверочныйЗапрос.Текст = ТекстЗапроса;
						Попытка
							ПроверочныйЗапрос.НайтиПараметры();
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					Иначе
						КонструкторЗапроса = Новый КонструкторЗапроса;
						КонструкторЗапроса.РежимКомпоновкиДанных = РежимКомпоновкиДанных;
						Попытка
							КонструкторЗапроса.Текст = ТекстЗапроса;
						Исключение
							ИнформацияОбОшибке = ИнформацияОбОшибке();
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
	ИначеЕсли ЯзыкПрограммы = 0 Тогда 
		ТекстДляВыполнения = ТекстИнициализации;
		Если ТипТекста = "Выражение" Тогда
			Если ТекстДляПроверки = "" Тогда
				ТекстДляПроверки = 0;
			КонецЕсли;
			ТекстДляВыполнения = ТекстДляВыполнения + "?(Истина, 0, " + Символы.ПС + ТекстДляПроверки + Символы.ПС + ")";
		Иначе
			//ТекстДляВыполнения = ТекстДляВыполнения + "Если Ложь Тогда " + Символы.ПС + ТекстДляПроверки + Символы.ПС + " КонецЕсли"; // Заменено 06.12.2011
			ТекстДляВыполнения = "Если Ложь Тогда Попытка " + ТекстДляВыполнения + Символы.ПС + ТекстДляПроверки + Символы.ПС + " Исключение КонецПопытки КонецЕсли";
		КонецЕсли;
		Если Нрег(Контекст) = Нрег("Сервер") Тогда
			лКонтекстВыполнения = ирСервер;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		ИначеЕсли Контекст <> Неопределено Тогда 
			лКонтекстВыполнения = Контекст;
			лМетодВыполнения = "ВыполнитьАлгоритм";
		Иначе
			лКонтекстВыполнения = КонтекстВыполнения;
			лМетодВыполнения = МетодВыполнения;
		КонецЕсли; 
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляВыполнения, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		СтартоваяСтрока = - 1;
	ИначеЕсли ЯзыкПрограммы = 2 Тогда
		лКонтекстВыполнения = КонтекстВыполнения;
		лМетодВыполнения = МетодВыполнения;
		Попытка
			ИнформацияОбОшибке = мПлатформа.ВыполнитьПрограммныйКодВКонтексте(лКонтекстВыполнения, лМетодВыполнения, ТекстДляПроверки, Истина);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
	КонецЕсли;
	Если СамаяВложеннаяПричина И ИнформацияОбОшибке <> Неопределено Тогда
		#Если Сервер И Не Сервер Тогда
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		#КонецЕсли
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
	КонецЕсли; 
	Возврат ИнформацияОбОшибке;

КонецФункции

// Выполняет проверку синтаксиса программного кода или текста запроса.
//
// Параметры:
//  *СообщатьОбУспешнойПроверке - Булево, *Ложь;
//  *ТекстДляПроверки - Строка, *Неопределено - проверяемый текст (используется весь текст или этот).
//
// Возвращаемое значение:
//  Булево - результат проверки.
//
Функция ПроверитьПрограммныйКод(СообщатьОбУспешнойПроверке = Ложь, ТекстДляПроверки = Неопределено, Контекст = Неопределено) Экспорт
	
	СтартоваяСтрока = 0;
	СтартоваяКолонка = 0;
	ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляПроверки, СтартоваяСтрока, СтартоваяКолонка, Контекст);
	Если ЗначениеЗаполнено(Контекст) Тогда
		ПредставлениеКонтекста = " (Проверка " + Контекст + ")";
	КонецЕсли; 
	Если ИнформацияОбОшибке <> Неопределено Тогда
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
			#Если Клиент Тогда
			Если ФормаВладелец <> Неопределено Тогда
				ФормаВладелец.ТекущийЭлемент = ПолеТекста.ЭлементФормы;
			КонецЕсли; 
			ирКлиент.ПоказатьОшибкуВТекстеПрограммыЛкс(ПолеТекста, СтартоваяСтрока, СтартоваяКолонка, ЯзыкПрограммы, , ИнформацияОбОшибке,, ПредставлениеКонтекста);
			#КонецЕсли
		Иначе
			// Ошибка обработана и отображена ранее
		КонецЕсли; 
	Иначе
		Если СообщатьОбУспешнойПроверке Тогда
			СообщитьОбУспешнойПроверке(ПредставлениеКонтекста);
		КонецЕсли;
	КонецЕсли;
	Возврат ИнформацияОбОшибке = Неопределено;
	
КонецФункции

Процедура СообщитьОбУспешнойПроверке(Знач ПредставлениеКонтекста = "") Экспорт 
	
	ирОбщий.СообщитьСУчетомМодальностиЛкс(ирОбщий.ПредставлениеИзИдентификатораЛкс(ПолеТекста.ЭлементФормы.Имя) 
		+ ПредставлениеКонтекста + ": Синтаксических ошибок не обнаружено!");

КонецПроцедуры

Процедура СброситьРезультатРазбораПозицииВТексте()
	
	мНомерПараметра = 0;
	мНачалоКонтекста = "";
	мНачалоСлова = "";
	мКонецКонтекста = "";
	выхЕстьТочкаСправа = Ложь;
	мРодительскийКонтекст = "";
	мКонтекст = "";
	мЭтоСтроковыйЛитерал = Ложь;
	мЭтоОбъявлениеПсевдонима = Ложь;
	мЭтоКонструктор = Ложь;
	мАргументы = "";
	мПервыйФактическийПараметр = "";
	мФактическиеПараметры = Новый Массив;

КонецПроцедуры

// Заменяет все печатаемые символы, кроме идентификаторов в кавычках, внутри комментариев и строковых литералов на заданный символ.
//
// Параметры:
//  Текст        - Строка;
//  СимволЗамена - Строка.
//
// Возвращаемое значение:
//   Строка.
//
Функция ЗалитьКомментарииИСтроковыеЛитералы(Знач Текст, СимволЗамена = " ", ЗалитьСтроковыеЛитералы = Ложь, ЗалитьУсловия = Истина) Экспорт 

	мРегВыражение.Global = Истина;
	мРегВыражение.Multiline = Ложь;
	
	// Количество символов в тексте меняется, но позиции строк сохраняются
	Если Ложь
		Или ЯзыкПрограммы = 1
		Или ЯзыкПрограммы = 2
	Тогда
		////RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шСтрокаЗапроса   + ")|(.|\n|\r)";
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шСтрокаЗапроса + ")|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(?:" + "//:([^\n]*)" + ")|(?:" + "//[^\n]*" + ")|(" + шСтрокаЗапроса + ")|([\s\S])";
		ШаблонЗамены = "$1$2$3$4";
	ИначеЕсли ЯзыкПрограммы = 0 Тогда
		//RegExp.Pattern = "(""" + шИмя+ "(?:\." + шИмя + ")*"")|(" + "//(:)?[^\n]*" + ")|(" + шСтрокаПрограммы + ")|(.|\n|\r)";
		шОднострочнаяСтрокаПрограммыСКавычки = """(?:(?:"""")|[^""\n])*""?"; 
		шОднострочнаяСтрокаПрограммыСЧерты = "(?:(\n)\s*\|(?:(?:"""")|[^""\n])*""?)";
		//	+ шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "|(.|\n|\r)";
		мРегВыражение.Pattern = "(""" + шИмя + "(?:\.[" + шБуква + "\d]+)*"")" // имена ProgId от COM объектов бывают "Forms.TextBox.1"
			+ "|(""(?:" + шИмя + "\s*,\s*)*" + шИмя + """)" // создание структуры
			+ "|" + "//:([^\n]*)" + "|" + "//[^\n]*"
			+ "|"+ "(?:" + "#[^\n]*" + ")" // Инструкции препроцессора
			+ "|";  
		ШаблонЗамены = "$1$2$3$4";
		Если ЗалитьСтроковыеЛитералы Тогда
			мРегВыражение.Pattern = мРегВыражение.Pattern + шОднострочнаяСтрокаПрограммыСКавычки + "|" + шОднострочнаяСтрокаПрограммыСЧерты + "";
			ШаблонЗамены = ШаблонЗамены + "$5";
		Иначе
			// http://www.hostedredmine.com/issues/885452
		КонецЕсли; 
		мРегВыражение.Pattern = мРегВыражение.Pattern + "|([\s\S])";
	КонецЕсли;
	ЗалитыйТекст = мРегВыражение.Заменить(Текст, ШаблонЗамены);
	
	Если Истина
		И ЗалитьУсловия 
		И СтрДлина(ЗалитыйТекст) < 10000 // Долго на больших текстах!
	Тогда 
		// Заливаем условия, чтобы проверка равенства в них не считалась присвоением
		// В будущем можно отказаться от этого блока и собирать все возможные типы, а потом давать юзеру выбирать.
		Если ЯзыкПрограммы = 0 Тогда
			мРегВыражение.Pattern = "(" + шЕсли + ")|(" + шПока + ")";
			ЗалитыйТекстОригинал = ЗалитыйТекст;
			Результат = мРегВыражение.НайтиВхождения(ЗалитыйТекстОригинал);
			ЗалитыйТекст = Новый ЗаписьXML;
			ЗалитыйТекст.УстановитьСтроку("");
			ТекущаяПозицияВОригинале = 1;
			Для Каждого Match Из Результат Цикл
				НайденныйТекст = Неопределено;
				НачалоТокена = "";
				КонецТокена = "";
				Если Match.SubMatches(0) <> Неопределено Тогда
					НайденныйТекст = Match.SubMatches(0);
					НачалоТокена = Match.SubMatches(1);
					КонецТокена = Match.SubMatches(3);
				ИначеЕсли Match.SubMatches(4) <> Неопределено Тогда
					НайденныйТекст = Match.SubMatches(4);
					НачалоТокена = Match.SubMatches(5);
					КонецТокена = Match.SubMatches(7);
				КонецЕсли;
				ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале, Match.FirstIndex + 1 - ТекущаяПозицияВОригинале));
				ЗалитыйТекст.ЗаписатьБезОбработки(НачалоТокена + мРегВыражение.Заменить(Сред(НайденныйТекст, 1 + СтрДлина(НачалоТокена), СтрДлина(НайденныйТекст) - СтрДлина(НачалоТокена) - СтрДлина(КонецТокена)), СимволЗамена)
					+ КонецТокена);
				ТекущаяПозицияВОригинале = Match.FirstIndex + 1 + СтрДлина(Match.Value); 
			КонецЦикла;
			ЗалитыйТекст.ЗаписатьБезОбработки(Сред(ЗалитыйТекстОригинал, ТекущаяПозицияВОригинале));
			ЗалитыйТекст = ЗалитыйТекст.Закрыть();
		КонецЕсли; 
	КонецЕсли; 
	Возврат ЗалитыйТекст;

КонецФункции

Процедура ЗаполнитьЛокальныеСвойстваИМетодыПоТексту(ОчиститьТаблицуСлов = Истина, Знач ВключатьКонструкции = Истина, УчитыватьРодительскийКонтекст = Ложь, ОбновитьТекстДляАнализа = Истина,
	ВключатьГлобальныйКонтекст = Ложь, Знач ТекстДляАнализа = "", Знач ТекстСинтаксическиКорректен = Ложь, Знач ТолькоСвойства = Ложь) Экспорт 

	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
		мРегВыражение = Обработки.ирОболочкаРегВыражение.Создать();
	#КонецЕсли
	Если ирОбщий.ПроверитьПлатформаНеWindowsЛкс(, "Заполнение параметров", Истина) Тогда
		Возврат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		Если Ложь
			Или ОбновитьТекстДляАнализа 
			Или мТекстБезТекстовыхЛитералов = ""
		Тогда
			Если ЗначениеЗаполнено(мТекстБлока) Тогда
				ТекстДляАнализа = мТекстБлока;
			Иначе
				ТекстДляАнализа = ПолеТекста.ПолучитьТекст();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТекстДляАнализа) Тогда
		мТекстБезТекстовыхЛитералов = ЗалитьКомментарииИСтроковыеЛитералы(ТекстДляАнализа,, Истина, Ложь);
	ИначеЕсли ОбновитьТекстДляАнализа Тогда 
		мТекстБезТекстовыхЛитералов = ТекстДляАнализа;
	КонецЕсли; 
	Если ОчиститьТаблицуСлов Тогда
		ТаблицаСлов.Очистить();
	КонецЕсли;
	
	Если ВключатьКонструкции Тогда
		Если ЯзыкПрограммы = 0 Тогда
			СписокСловЯзыка = мПлатформа.КлючевыеСловаВстроенногоЯзыка();
		ИначеЕсли ЯзыкПрограммы = 1 Тогда
			ВключаяРусские = ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация");
			СписокСловЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов(РежимКомпоновкиДанных, ВключаяРусские, Истина);
		ИначеЕсли ЯзыкПрограммы = 2 Тогда
			//СписокСловЯзыка = мПлатформа.КлючевыеСловаЯзыкаЗапросов();
			СписокСловЯзыка = Новый СписокЗначений;
			СписокСловЯзыка.Добавить("РАЗЛИЧНЫЕ"); // Криво https://www.hostedredmine.com/issues/931487
		КонецЕсли;
		Для Каждого ЭлементСписка Из СписокСловЯзыка Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Слово = ЭлементСписка.Значение;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипСлова = "Конструкция";
			НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;
	КонецЕсли;
	Если ВключатьГлобальныйКонтекст Тогда
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа();
		СтруктураТипа.ИмяОбщегоТипа = "Глобальный";
		СтруктураТипа.Метаданные = Метаданные;
		ТаблицаГлобальногоКонтекста = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,, Конфигурация,, Ложь,,, мФлагиКомпиляции);
		Для Каждого СтрокаСлова Из ТаблицаГлобальногоКонтекста Цикл
			НоваяСтрока = ТаблицаСлов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСлова); 
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			//НоваяСтрока.Слово = ЭлементСписка.Значение;
			//НоваяСтрока.ТипСлова = "Конструкция";
			//НоваяСтрока.Определение = "Предопределенный";
		КонецЦикла;
	КонецЕсли;
	
	//Поиск использованных свойств и методов данного контекста.
	мРегВыражение.Global = Истина;
	Если Ложь
		Или Не УчитыватьРодительскийКонтекст
		Или мРодительскийКонтекст = ""
	Тогда
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъъ)|(ъъъъ)";
		Иначе
			Шаблон = "(?:(?:[^." + шБуква + "\d]|^)\s*(" + шИмя + ")(?=\s*\())"
					+ "|(" + шПараметрЗапроса + ")";
		КонецЕсли;
		Шаблон = Шаблон + "|(?:[^." + шБуква + "\d]|^)\s*(" + шИмя + ")(?=(?:\.(?:" + шИмя + ")?)+|[^\(?:\." + шБуква + "\d]|$)";
		КоличествоПодгрупп = 3;
	Иначе
		Если ТолькоСвойства Тогда
			Шаблон = "(ъъъъ)";
		Иначе
			Шаблон = "(?:[^." + шБуква + "\d]|^)\s*(?:" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")(?=\s*\())";
		КонецЕсли;
		Шаблон = Шаблон + "|(?:[^." + шБуква + "\d]|^)\s*(?:" + ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(мРодительскийКонтекст) + "\.(" + шИмя + ")(?=[^\(?:" + шБуква + "\d]|$))";
		КоличествоПодгрупп = 2;
	КонецЕсли;
	ТаблицаСловТЗ = ТаблицаСлов.Выгрузить(, "НСлово, ТипСлова, Частота");
	ТаблицаСловТЗ.Индексы.Добавить("НСлово");
	Если ЯзыкПрограммы = 0 Тогда
		мРегВыражение.Pattern = "(?:" + шСтрокаПрограммы + "|" + шКомментарий + "|(?:Новый|New)\s+" + шИмя + ")";
	Иначе
		мРегВыражение.Pattern = "(?:" + шСтрокаПрограммы + "|" + шКомментарий + ")";
	КонецЕсли;
	ВременныйТекст = мРегВыражение.Заменить(мТекстБезТекстовыхЛитералов, "");
	мРегВыражение.Pattern = Шаблон;
	Результат = мРегВыражение.НайтиВхождения(ВременныйТекст,, Истина);
	Счетчик = 0;
	Для Каждого Match Из Результат Цикл
		Счетчик = Счетчик + 1;
		Если Счетчик = МаксСловНаходитьВТекстеПрограммы Тогда
			// Обрезка контекста для ускорения
			Прервать;
		КонецЕсли;
		Подгруппа1 = Match.SubMatches(0);
		Подгруппа2 = Match.SubMatches(1);
		Если КоличествоПодгрупп = 3 Тогда
			Подгруппа3 = Match.SubMatches(2);
		Иначе
			Подгруппа3 = Неопределено;
		КонецЕсли; 
		Если Подгруппа1 <> Неопределено Тогда
			Слово = Подгруппа1;
			ТипСлова = "Метод";
		ИначеЕсли Подгруппа2 <> Неопределено Тогда
			Слово = Подгруппа2;
			ТипСлова = "Свойство";
		ИначеЕсли Подгруппа3 <> Неопределено Тогда 
			Слово = Подгруппа3;   
			ТипСлова = "Свойство";
			Если Истина
				И ОчиститьТаблицуСлов
				И ВключатьГлобальныйКонтекст
				И ЗначениеЗаполнено(ТекстДляАнализа)
				И ТекстСинтаксическиКорректен
				И (Ложь
					Или Не УчитыватьРодительскийКонтекст
					Или мРодительскийКонтекст = "")
			Тогда 
				// Подмена контекста нужна, чтобы избежать бесконечной рекурсии через вызов КонсольКода.ЗаполнитьПараметрыВыхода в режиме ЭтоМодуль
				КонтекстВыполненияПроверки = ?(мФлагиКомпиляции.Сервер, ирСервер, ирОбщий);
				// Вызов из консоли кода для заполнения выходных параметров. https://www.hostedredmine.com/issues/947841
				ИнформацияОбОшибке = ПроверитьТекстИВернутьОшибку(ТекстДляАнализа + ";Сообщить(" + Слово + ")",,, КонтекстВыполненияПроверки);
				Если ИнформацияОбОшибке <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		Иначе 
			Продолжить;
		КонецЕсли;
		СтруктураКлюча = Новый Структура("НСлово", НРег(Слово));
		НайденныеСтроки = ТаблицаСловТЗ.НайтиСтроки(СтруктураКлюча);
		НоваяСтрока = Неопределено;
		Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			Если Ложь
				Или ЯзыкПрограммы = 1
				Или (Истина
					И ТипСлова = "Метод" 
					И НайденнаяСтрока.ТипСлова = "Метод")
				Или (Истина
					И ТипСлова <> "Метод" 
					И НайденнаяСтрока.ТипСлова <> "Метод")
			Тогда
				НоваяСтрока = НайденнаяСтрока;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если НоваяСтрока = Неопределено Тогда 
			НоваяСтрока = ТаблицаСлов.Добавить();
			НоваяСтрока.Определение = "Статистический";
			НоваяСтрока.Слово = Слово;
			НоваяСтрока.НСлово = НРег(НоваяСтрока.Слово);
			НоваяСтрока.ТипСлова = ТипСлова;
			НоваяСтрока.ТипЗначения = "??";
			НоваяСтрока = ТаблицаСловТЗ.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураКлюча);
		КонецЕсли;
		НоваяСтрока.Частота = НоваяСтрока.Частота + 1;
	КонецЦикла;
	ТаблицаСлов.ЗагрузитьКолонку(ТаблицаСловТЗ.ВыгрузитьКолонку("Частота"), "Частота");

КонецПроцедуры

Процедура ОбновитьТипЗначенияИзТаблицыСтруктурТипов(Знач НоваяСтрока, Знач ТаблицаСтруктурТипов, ЗаменитьСуществующий = Истина) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	СтарыйТипЗначения = НоваяСтрока.ТипЗначения;
	Если Лев(СтарыйТипЗначения, 2) = "??" Тогда
		НовыйТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов);
		Если Истина
			И ЗначениеЗаполнено(НовыйТипЗначения) 
			И Найти(НРег(СтарыйТипЗначения), НРег(НовыйТипЗначения)) > 0 
			И НовыйТипЗначения <> "??"
		Тогда
			НовыйТипЗначения = "";
		КонецЕсли; 
		ОстатокТипа = Сред(СтарыйТипЗначения, 4);
		Если ОстатокТипа <> "" И Найти(НовыйТипЗначения, ОстатокТипа) = 1 Тогда
			НоваяСтрока.ТипЗначения = НовыйТипЗначения;
		Иначе
			НоваяСтрока.ТипЗначения = СтрЗаменить(СтарыйТипЗначения, "??", НовыйТипЗначения);
		КонецЕсли;
		Если Не ЗначениеЗаполнено(НоваяСтрока.ТипЗначения) Тогда
			НоваяСтрока.ТипЗначения = "?";
		ИначеЕсли Лев(НоваяСтрока.ТипЗначения, 1) = "," Тогда 
			НоваяСтрока.ТипЗначения = СокрЛ(Сред(НоваяСтрока.ТипЗначения, 2));
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ЗаменитьСуществующий
		Или Не ЗначениеЗаполнено(СтарыйТипЗначения) 
		Или Найти(СтарыйТипЗначения, "<") > 0
	Тогда 
		НоваяСтрока.ТипЗначения = мПлатформа.ПредставлениеМассиваСтруктурТипов(ТаблицаСтруктурТипов);
	КонецЕсли;

КонецПроцедуры

Функция СобратьКомментарийМетода(ОписаниеМетода = "", Знач СтрокаРезультата = Неопределено, ЗначенияПараметров = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		ЗначенияПараметров = Новый Структура;
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ПрефиксОписанияПараметра = "//    ";
	КомментарийМетода = Новый Массив;
	Для Каждого Параметр Из Параметры Цикл
		ТаблицаСвойств = Неопределено;
		Если Не ЗначениеЗаполнено(Параметр.ТипЗначения) Тогда
			ЗначениеПараметра = Параметр.Значение;
			Если ЗначенияПараметров <> Неопределено И ЗначенияПараметров.Свойство(Параметр.Имя) Тогда
				ЗначениеПараметра = ЗначенияПараметров[Параметр.Имя];
			КонецЕсли;
			СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ЗначениеПараметра);    
			ИмяОбщегоТипа = мПлатформа.ИмяТипаИзСтруктурыТипа(СтруктураТипа);
			ТаблицаЗначений = Неопределено;
			Если Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("Структура") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ФиксированнаяСтруктура")
			Тогда
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Свойство");
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("ТаблицаЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("ДеревоЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра;
			ИначеЕсли Ложь
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаТаблицыЗначений") 
				Или ТипЗнч(ЗначениеПараметра) = Тип("СтрокаДереваЗначений")
			Тогда
				ТаблицаЗначений = ЗначениеПараметра.Владелец();
			КонецЕсли; 
			Если ТаблицаЗначений <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ТаблицаЗначений);    
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(СтруктураТипа,,,,,, "Метод",,, "Найти");
				ТаблицаСвойств = мПлатформа.ТаблицаСловИзСтруктурыТипа(ТаблицаСвойств[0].ТаблицаСтруктурТипов[0],,,,,, "Свойство");
			КонецЕсли;
			Параметр.ТипЗначения = ИмяОбщегоТипа;
		КонецЕсли;
		КомментарийМетода.Добавить(ПрефиксОписанияПараметра + Параметр.Имя + " - " + Параметр.ТипЗначения + " - " + Параметр.Комментарий);
		Если ТаблицаСвойств <> Неопределено И ТаблицаСвойств.Количество() > 0 Тогда 
			КомментарийМетода[КомментарийМетода.ВГраница()] = КомментарийМетода[КомментарийМетода.ВГраница()] + ":";
			Для Каждого Свойство Из ТаблицаСвойств Цикл
				ОбновитьТипЗначенияИзТаблицыСтруктурТипов(Свойство, Свойство.ТаблицаСтруктурТипов);
				КомментарийМетода.Добавить(ПрефиксОписанияПараметра + "  * " + Свойство.Слово + " - " + Свойство.ТипЗначения + " - " + Параметр.Комментарий);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	КомментарийМетода = ирОбщий.СтрСоединитьЛкс(КомментарийМетода, Символы.ПС) + Символы.ПС;
	Если ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "//.
		|// Параметры:" + Символы.ПС + КомментарийМетода;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ОписаниеМетода) Тогда
		КомментарийМетода = Сред(ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(, ОписаниеМетода, "// ", Истина), 2) + Символы.ПС + КомментарийМетода;
	КонецЕсли;
	Если СтрокаРезультата <> Неопределено Тогда
		КомментарийМетода = КомментарийМетода + "// Возвращаемое значение:" + Символы.ПС + ПрефиксОписанияПараметра + СтрокаРезультата.ТипЗначения + " - " + СтрокаРезультата.Комментарий + Символы.ПС;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(КомментарийМетода) Тогда
		КомментарийМетода = "";
	КонецЕсли;
	Возврат КомментарийМетода;

КонецФункции

Процедура УстановитьКлиентСерверКонтекст(Знач НовыйНаСервере = Истина) Экспорт 
	//мФлагиКомпиляции.Сервер = НовыйНаСервере;
	//мФлагиКомпиляции.КлиентОбычноеПриложение = ?(НовыйНаСервере, Ложь, Неопределено);
	//мФлагиКомпиляции.КлиентУправляемоеПриложение = ?(НовыйНаСервере, Ложь, Неопределено);
	мФлагиКомпиляции = Новый Структура("Сервер", НовыйНаСервере);
	Если мМодульМетаданных <> Неопределено Тогда
		УстановитьФлагиКомпиляцииМодуля();
	КонецЕсли;
КонецПроцедуры

Процедура УстановитьФлагиКомпиляцииМодуля() Экспорт
	мМодульМетаданных.ФлагиКомпиляции = ирОбщий.СкопироватьКоллекциюЛкс(мФлагиКомпиляции);
КонецПроцедуры

// Функция - Установить текст
//
// Параметры:
//  Текст						 - 	 - 
//  Активировать				 - 	 - 
//  НачальныйТекстДляСравнения	 - 	 - 
//  СохранитьГраницыВыделения	 - 	 - 
//  ПолноеИмя	 - Строка - например Обработка.ирКонсольЗапросов.МодульОбъекта
// 
Процедура УстановитьТекст(Знач Текст, Знач Активировать = Ложь, Знач НачальныйТекстДляСравнения = Неопределено, Знач СохранитьГраницыВыделения = Ложь, Знач СжатоеИмяМодуля = Неопределено,
	Знач ИмяМодуля = Неопределено) Экспорт
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	ОчиститьИсториюПереходов();
	ПолеТекста.УстановитьТекст(Текст, Активировать, НачальныйТекстДляСравнения, СохранитьГраницыВыделения);
	ОчиститьТаблицуСловЛокальногоКонтекста();
	Если Не ЗначениеЗаполнено(СжатоеИмяМодуля) И Не ЗначениеЗаполнено(ИмяМодуля) Тогда
		мИмяМодуля = "";
		мМодульМетаданных = Неопределено;
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если ИмяМодуля <> Неопределено И СжатоеИмяМодуля = Неопределено Тогда
		Фрагменты = ирОбщий.СтрРазделитьЛкс(СжатоеИмяМодуля, ".");
		Фрагменты.Удалить(2);
		СжатоеИмяМодуля = ирОбщий.СтрСоединитьЛкс(Фрагменты);
	КонецЕсли;
	Фрагменты = ирОбщий.СтрРазделитьЛкс(СжатоеИмяМодуля, "::");
	ИмяМодуля = СжатоеИмяМодуля;    
	Если Фрагменты.Количество() > 1 Тогда
		// Внешняя обработка/отчет
		ИмяОбщегоТипа = Фрагменты[0];
		ТипМодуля = Фрагменты[2];
		//КлючПоиска = Новый Структура;
		//КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + "Объект");
		//КлючПоиска.Вставить("ЯзыкПрограммы", 0);
		//ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
		МенеджерОбъекта = ирОбщий.МенеджерВнешнегоОбъектаЛкс(ИмяОбщегоТипа, Фрагменты[1]);
		ОбъектМД = МенеджерОбъекта.Метаданные();
		Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
			СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
			СтруктураТипа.Метаданные = ОбъектМД;
		Иначе                      
			ИмяМодуля = ИмяОбщегоТипа + "::" + Фрагменты[1] + "::" + ОбъектМД.Имя + "." + "Форма" + "." + ТипМодуля;
			Форма = ирКэш.ПассивнаяФормаПоИмениЛкс(НРег(ИмяМодуля));
			ИмяМодуля = ИмяМодуля + "." + "Форма";
			Если Форма <> Неопределено Тогда
				СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Форма);
			Иначе
				СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
				СтруктураТипа.Метаданные = Метаданные;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Фрагменты = ирОбщий.СтрРазделитьЛкс(ИмяМодуля);
		ИмяОбщегоТипа = Фрагменты[0];
		Если Фрагменты.Количество() = 1 Тогда
			ИмяОбщегоТипа = "ОбъектМетаданныхКонфигурация";
		ИначеЕсли Ложь
			Или ИмяОбщегоТипа = "WebСервис"
			Или ИмяОбщегоТипа = "HttpСервис"
			Или ИмяОбщегоТипа = "ОбщийМодуль"
			Или ИмяОбщегоТипа = "ОбщаяКоманда"
		Тогда
			ОбъектМД = Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяОбщегоТипа)][Фрагменты[1]];
		ИначеЕсли Ложь
			Или ИмяОбщегоТипа = "Команда"
		Тогда 
			// Конфигуратор оставил нам только полный перебор, т.к. не показывает имя родительского объекта в заголовке
			Для Каждого СтрокаТипаМетаданных Из ирКэш.ТипыМетаОбъектов(, Ложь, Ложь) Цикл
				Для Каждого ОбъектМДЦикл Из Метаданные[СтрокаТипаМетаданных.Множественное] Цикл
					#Если Сервер И Не Сервер Тогда
						ОбъектМДЦикл = Метаданные.Обработки.ирКонсольЗапросов;
					#КонецЕсли
					Попытка
						Команды = ОбъектМДЦикл.Команды;
					Исключение
						Прервать;
					КонецПопытки;
					КомандаМД = Команды.Найти(Фрагменты[1]);
					Если КомандаМД <> Неопределено Тогда
						ОбъектМД = ОбъектМДЦикл;
						Перейти ~ВыходЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;   
			~ВыходЦикла: 
			ИмяМодуля = ОбъектМД.ПолноеИмя() + "." + ИмяМодуля;
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(Фрагменты[0], "ОбщаяФорма") Тогда
			ИмяОбщегоТипа = "Форма";
			ИмяМодуля = ИмяМодуля + "." + ИмяОбщегоТипа;
			ОбъектМД = Метаданные[ирОбщий.МножественноеИмяМДЛкс(ИмяОбщегоТипа)][Фрагменты[1]];
		Иначе
			ТипМодуля = Фрагменты[Фрагменты.ВГраница()];
			ИмяОбщегоТипа = Фрагменты[0];
			Если ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульОбъекта") Тогда
				Подтип = "Объект";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджера") Тогда
				Подтип = "Менеджер";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульНабораЗаписей") Тогда
				Подтип = "НаборЗаписей";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ТипМодуля, "МодульМенеджераЗначения") Тогда
				Подтип = "МенеджерЗначения";
			Иначе 
				ТипМодуля = "Форма";
				Подтип = "";
			КонецЕсли;
			Если ЗначениеЗаполнено(Подтип) Тогда
				Фрагменты.Удалить(Фрагменты.ВГраница());
				КлючПоиска = Новый Структура;
				КлючПоиска.Вставить("БазовыйТип", ИмяОбщегоТипа + Подтип);
				КлючПоиска.Вставить("ЯзыкПрограммы", 0);
				ИмяОбщегоТипа = мПлатформа.ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска)[0].Слово;
			Иначе
				ИмяОбщегоТипа = "Форма";
				Фрагменты.Вставить(Фрагменты.ВГраница(), ИмяОбщегоТипа);
			КонецЕсли;
			ИмяМодуля = ирОбщий.СтрСоединитьЛкс(Фрагменты, ".");
			ОбъектМД = Метаданные.НайтиПоПолномуИмени(ИмяМодуля);
			Если ЗначениеЗаполнено(ТипМодуля) Тогда
				ИмяМодуля = ИмяМодуля + "." + ТипМодуля;
			КонецЕсли;
		КонецЕсли;
		СтруктураТипа = мПлатформа.НоваяСтруктураТипа(ИмяОбщегоТипа);
		Если ОбъектМД <> Неопределено Тогда
			Если ИмяОбщегоТипа = "Форма" Тогда
				Форма = ирКэш.ПассивнаяФормаПоИмениЛкс(НРег(ОбъектМД.ПолноеИмя()));
				Если Форма = Неопределено Тогда
					ОбъектМД = Метаданные;
				Иначе
					ОбъектМД = Форма;
				КонецЕсли;
				Если ОбъектМД <> Метаданные Тогда
					СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(ОбъектМД);
				КонецЕсли;
			КонецЕсли;
			СтруктураТипа.Метаданные = ОбъектМД;
		КонецЕсли;      
	КонецЕсли; 
	Если ИмяМодуля = мИмяМодуля Тогда
		Возврат;
	КонецЕсли;   
	мИмяМодуля = ИмяМодуля;
	мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(СтруктураТипа,,, Текст);

КонецПроцедуры

Процедура ОбновитьМодульМетаданных(Знач Текст = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		мПлатформа = Обработки.ирПлатформа.Создать();
	#КонецЕсли
	Если Текст = Неопределено Тогда
		Текст = ПолеТекста.ПолучитьТекст();
	КонецЕсли; 
	СтарыйМодульМетаданных = мМодульМетаданных;
	Если мМодульМетаданных <> Неопределено И мМодульМетаданных.СтруктураТипа <> Неопределено Тогда
		мМодульМетаданных = мПлатформа.ПодготовитьМодульМетаданных(мМодульМетаданных.СтруктураТипа,,, Текст);
	Иначе
		Если Не ЗначениеЗаполнено(Текст) Тогда
			Текст = "a=1"; // Нельзя пустой, т.к. тогда будет из кэша браться
		КонецЕсли;
		мМодульМетаданных = мПлатформа.МодульМетаданных(Текст);
	КонецЕсли;           
	УстановитьФлагиКомпиляцииМодуля();
	Если Истина
		И СтарыйМодульМетаданных <> Неопределено 
		И Не ЗначениеЗаполнено(СтарыйМодульМетаданных.Имя)
		И Не ЗначениеЗаполнено(мМодульМетаданных.Имя)
	Тогда
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Методы, мМодульМетаданных.Методы);
		СкопироватьСпециальныеЭлементыМодуля(СтарыйМодульМетаданных.Переменные, мМодульМетаданных.Переменные);
	КонецЕсли;

КонецПроцедуры

Процедура ПодготовитьГлобальныйКонтекст() Экспорт  
	ГлобальныйКонтекст = мПлатформа.НоваяСтруктураТипа("Глобальный");
	мПлатформа.ТаблицаСловИзСтруктурыТипа(ГлобальныйКонтекст,, Метаданные,, Ложь,,, мФлагиКомпиляции);
	Попытка
		Пустышка = БиблиотекаКартинок["!"]; // Путем обращения к заведомо несуществующей картинке вызываем полную загрузку кэша картинок платформой. В редких случаях встречается длительное выполнение.
	Исключение
	КонецПопытки;
КонецПроцедуры

//.
// Параметры:
//    СтараяКоллекцияМодуля - Строка - 
//    НоваяКоллекцияМодуля - Строка - 
Процедура СкопироватьСпециальныеЭлементыМодуля(СтараяКоллекцияМодуля, НоваяКоллекцияМодуля) Экспорт
	Если Истина
		И СтараяКоллекцияМодуля.Количество() > 0 
		И СтараяКоллекцияМодуля[СтараяКоллекцияМодуля.Количество() - 1].ПозицияСОписанием = Неопределено
	Тогда
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтараяКоллекцияМодуля.Скопировать(Новый Структура("ПозицияСОписанием")), НоваяКоллекцияМодуля);
	КонецЕсли;
КонецПроцедуры

Процедура ОчиститьИсториюПереходов() Экспорт 
	мИсторияПереходов = Неопределено;
КонецПроцедуры
	
Процедура ЗапомнитьИсточникПерехода() Экспорт 
	Если мИсторияПереходов = Неопределено Тогда
		мИсторияПереходов = Новый Массив;
	КонецЕсли; 
	АдресУхода = ПолеТекста.ВыделениеДвумерное();
	Если Истина
		И мИсторияПереходов.Количество() > 0 
		И ирОбщий.СравнитьЗначенияСвойствЛкс(мИсторияПереходов[0], АдресУхода) 
	Тогда
		Возврат;
	КонецЕсли;
	мИсторияПереходов.Вставить(0, АдресУхода);
КонецПроцедуры

Процедура ВернутьсяИзПерехода() Экспорт 
	
	Пока Истина Цикл
		Если мИсторияПереходов = Неопределено Или мИсторияПереходов.Количество() = 0 Тогда
			Возврат;
		КонецЕсли; 
		АдресУхода = мИсторияПереходов[0];
		Если ирОбщий.СравнитьЗначенияСвойствЛкс(ПолеТекста.ВыделениеДвумерное(), АдресУхода) Тогда
			мИсторияПереходов.Удалить(0);
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ПолеТекста.УстановитьВыделениеДвумерное(АдресУхода);
	мИсторияПереходов.Удалить(0);
	
КонецПроцедуры

Функция ТаблицаСловВJSON(ИменаКолонок) Экспорт 
	
	Возврат ирОбщий.ТаблицаЗначенийВJSONЛкс(ТаблицаСлов.Выгрузить(, ИменаКолонок));
	
КонецФункции

// Добавляет слово локального контекста.
//
// Параметры:
//  Слово        - Строка;
//  ТипСлова     - Строка - "Метод", "Свойство";
//  *ТипЗначения - ОписаниеТипов, *Неопределено - ;
//  *Метаданные  - Произвольный, *Неопределено - используется, если ТипЗначения задан;
//  *ТаблицаСтруктурТипа - ТаблицаЗначений, *Неопределено;
//
Функция ДобавитьСловоЛокальногоКонтекста(Слово, ТипСлова = "Свойство", Знач ТипЗначения = Неопределено,
	пМетаданные = Неопределено, _Глобальное = Ложь, Значение = Неопределено, ТаблицаСтруктурТипов = Неопределено, Знач ИмяОбщегоТипа = "") Экспорт
	
	КлючСтроки = Новый Структура;
	КлючСтроки.Вставить("нИмя", Нрег(Слово));
	ТаблицаЛокальногоКонтекста = ТаблицаЛокальногоКонтекста(ТипСлова);
	НайденныеСтроки = ТаблицаЛокальногоКонтекста.НайтиСтроки(КлючСтроки);
	Если НайденныеСтроки.Количество() = 0 Тогда
		НоваяСтрока = ТаблицаЛокальногоКонтекста.Добавить();
		НоваяСтрока.Имя = Слово;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючСтроки);
	Иначе
		НоваяСтрока = НайденныеСтроки[0];
	КонецЕсли;
	Если ТаблицаСтруктурТипов = Неопределено Тогда
		ТаблицаСтруктурТипов = мПлатформа.НоваяТаблицаСтруктурТипа();
	КонецЕсли;
	НоваяСтрока.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	Если ЗначениеЗаполнено(ИмяОбщегоТипа) Тогда
		СтруктураТипа = ТаблицаСтруктурТипов.Добавить();
		СтруктураТипа.ИмяОбщегоТипа = ИмяОбщегоТипа;
		СтруктураТипа.Метаданные = пМетаданные;
	КонецЕсли; 
	Если Значение <> Неопределено Тогда
		СтруктураТипа = мПлатформа.СтруктураТипаИзЗначения(Значение, ЯзыкПрограммы,
			Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
		мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЕсли; 
	Если Значение <> Неопределено Тогда
		Если ТипЗначения = Неопределено Тогда
			ТипЗначения = Новый ОписаниеТипов;
		КонецЕсли; 
		ТипЗначения = Новый ОписаниеТипов(ТипЗначения, ирОбщий.ЗначенияВМассивЛкс(ТипЗнч(Значение)));
	КонецЕсли;
	Если ТипЗначения <> Неопределено Тогда
		Для Каждого Тип Из ТипЗначения.Типы() Цикл
			СтруктураТипа = мПлатформа.СтруктураТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы,
				Новый Структура("СтрокаОписания, Метаданные", НоваяСтрока, пМетаданные)); // Циклическая ссылка СтрокаОписания
			мПлатформа.ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
		КонецЦикла;
	КонецЕсли;
	НоваяСтрока.ТипЗначения = "??";
	Возврат НоваяСтрока;

КонецФункции

Функция ТаблицаЛокальногоКонтекста(Знач ТипСлова = "Свойство")
	
	Если мМодульМетаданных = Неопределено Тогда
		ОбновитьМодульМетаданных(""); 
	КонецЕсли;
	Если ТипСлова = "Метод" Тогда
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Методы;
	Иначе
		ТаблицаЛокальногоКонтекста = мМодульМетаданных.Переменные;
	КонецЕсли; 
	Возврат ТаблицаЛокальногоКонтекста;

КонецФункции

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ОбщийМодульЛкс("ирСервер");
//ирПортативный ирКлиент = ирПортативный.ОбщийМодульЛкс("ирКлиент");

мПлатформа = ирКэш.Получить(); 
#Если Сервер И Не Сервер Тогда
	мПлатформа = Обработки.ирПлатформа.Создать();
	ПолеТекста = Обработки.ирОболочкаПолеТекста.Создать();
	мМодульМетаданных = мПлатформа.МодульМетаданных("");
	ФормаВладелец = ОткрытьФорму();
	мФормаАвтодополнение = ФормаАвтодополнение();
	мФормаВызовМетода = ФормаВызовМетода();
#КонецЕсли
#Если Клиент Тогда
	мСлужебнаяФорма = мПлатформа.ПолучитьФорму("Служебная");
	СлужебноеПолеТекстаДолгое = мПлатформа.НовоеСлужебноеПолеТекста(мСлужебнаяФорма);
	мПолеТекстаВременное = мПлатформа.СлужебноеПолеТекста;
#КонецЕсли 
мПравилаВычисленияФункций = Новый ТаблицаЗначений;
мПравилаВычисленияФункций.Колонки.Добавить("Слово");
мПравилаВычисленияФункций.Колонки.Добавить("нСлово");
мПравилаВычисленияФункций.Колонки.Добавить("ТипКонтекста");
мПравилаВычисленияФункций.Колонки.Добавить("Правило");
мПравилаВычисленияФункций.Индексы.Добавить("Слово, ТипКонтекста");

НаКлиенте = Истина;
НаСервере = Истина;
мРазбиратьКонтекст = Истина;
мРасширенноеПолучениеМетаданныхADO = Ложь;
//мДоступныеТаблицыПолучены = Ложь;
мАвтоКонтекстнаяПомощь = Ложь;
мИменаОбщихТиповПоИменамКлассовCOM = Новый Соответствие;
мСтруктурыТиповПодсказкиУдержания = Новый Структура;
мДоступныеПоляТаблиц = Новый Соответствие;

мШиринаТабуляции = 4;
МаксСловНаходитьВТекстеПрограммы = 2000;

мРегВыражение = ирОбщий.НовоеРегВыражениеЛкс();
мРегВыражение.IgnoreCase = Истина;
мРегВыражение.MultiLine = Ложь;

шЛюбой = мПлатформа.шЛюбой;
шБуква = мПлатформа.шБуква;
шИмя         = мПлатформа.шИмя;
шЧисло       = мПлатформа.шЧисло;
шИндекс      = мПлатформа.шИндекс;
шСкобки      = мПлатформа.шСкобки;
шРазделитель = мПлатформа.шРазделитель;
шКомментарий = мПлатформа.шКомментарий;
шСтрокаПрограммы = мПлатформа.шСтрокаПрограммы;

шНачалоЧисла = "\d+(?:\.)?\d*";
шНачалоСкобок = "(\((?:[^\)\(]*?(?:(?:\([^\)]*?\)[^\)\(]*?)*)*\))?)";
шИмяСкобки = "(?:" + шИмя + "|\?|)" + шСкобки;

// Шаблоны программы

шСимволыПрефиксаПараметра = "&#@~\?";
шДирективаПрепроцессора = "#[^\n]*\n";
шПрефиксПараметраНеобяз = "[" + шСимволыПрефиксаПараметра + "]?";
шНачалоСтрокиПрограммы = шСтрокаПрограммы + "?"; // опасно!
шОператорПрограммы = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель + "(?:И|ИЛИ|НЕ)" + шРазделитель + ")+";

шФрагментСтрокиПрограммы = "(?:""|\|)(?:(?:"""")|[^""\n$])*(?:""|\n|$)";
шНачалоТокена = "([" + шБуква + "\d]" + шРазделитель + "+|(?:\]|\)|" + шФрагментСтрокиПрограммы + "|;|^)" + шРазделитель + "*)";
шКонецТокена = "(" + шРазделитель + "+[" + шБуква + "\d]|" + шРазделитель + "*(?:\[|\(|" + шФрагментСтрокиПрограммы + "|;|$))";
шЕсли = шНачалоТокена + "(?:Если|ИначеЕсли)"  
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\." + шРазделитель + "*Тогда|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Тогда" + шКонецТокена;
шПока = шНачалоТокена + "Пока" 
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\r|\n|.)*?" + "[^" + шБуква + "\d\.]"
	+ "Цикл" + шКонецТокена;
шВызватьИсключение = шНачалоТокена + "ВызватьИсключение" 
	+ шКонецТокена + "(?:" + шФрагментСтрокиПрограммы + "|\." + шРазделитель + "*;|\r|\n|.)*?;";

//шОписаниеФункции = "Функция" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
//	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецФункции|\r|\n|.)*?))"
//	+ "[^" + шБуква + "\d\.""]КонецФункции[^" + шБуква + "\d\.""]";

//шОписаниеПроцедуры = "Процедура" + шРазделитель + "*(" + шИмя + ")" + шРазделитель + "*\(([^\)]*)\)(" + шРазделитель + "*Экспорт)?"
//	+ "((?:(?:" + шСтрокаПрограммы + "|\." + шРазделитель + "*КонецПроцедуры|\r|\n|.)*?))"
//	+ "[^" + шБуква + "\d\.""]КонецПроцедуры[^" + шБуква + "\d\.""]";
//	
//шОписаниеПеременной = "Перем" + шРазделитель + "*(" + шИмя + ")(" + шРазделитель + "+Экспорт)?" + шРазделитель + "*;";

//шМодуль = "^((?:" + шОписаниеПеременной + "|" + шРазделитель + "|" + шДирективаПрепроцессора + ")*)"
//	+ "((?:" + шОписаниеФункции + "|" + шОписаниеПроцедуры + "|" + шДирективаПрепроцессора + "|" + шРазделитель + ")*)((?:\r|\n|.)*)$";

//шВыражениеПрограммы       = "(?:" + шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
//	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")";
//шВыражениеПрограммы       = "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
//	+ "(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")*)*";
//шВыражениеПрограммы       = "(?:" + шРазделитель + "*"
//	+ "(?:новый)" + "(?:" + шРазделитель + "(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*))?|(?:"
//	+ "(?:*" + шОператорПрограммы + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + ")*" 
//	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
//	+ шЧисло + "|" + шСтрокаПрограммы + ")";

шВыражениеПрограммы1 = "(?:(?:новый|New)" + "(?:" + шРазделитель + "(?:" + шИмя + "))?" + шРазделитель + "*" + "(?:\(""(?:" + шИмя+ "(?:\." + шИмя + ")*)""\))?"
	+ "|(?:(?:не|not)" + шРазделитель + "+)?(?:(?:(?:новый|New)" + шРазделитель + ")?" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")";
шВыражениеПрограммы = шРазделитель + "*" + шВыражениеПрограммы1 + "(?:" + шРазделитель + "*" + шОператорПрограммы + шРазделитель + "*"
	+ шВыражениеПрограммы1 + ")*";
	
шНачалоВыраженияПрограммы = "(?:" + шРазделитель + "*(?:(?:" 
	+ шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шЧисло + "|" + шСтрокаПрограммы + ")" + шРазделитель + "*" + шОператорПрограммы + ")*" 
	+ шРазделитель + "*(?:(?:" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*)|"
	+ шНачалоЧисла + "|" + шНачалоСтрокиПрограммы + ")?";

шВызовМетодаПрограммы = "(?:" + шПредИмя + "(Новый|New)\s+)?(" + шИмяСкобки + "?" + "(?:(?:\.(?:" + шИмя + ")" + шСкобки + "?)|" + шИндекс + ")*?)"
	+ "\(((?:(?:" + шВыражениеПрограммы + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияПрограммы + ")?" + шРазделитель + "*";

шПрисваивание = "(" + шРазделитель + "*=" + шРазделитель + "*((новый|New)" // Изменение для поддержки ProgID типа Forms.TextBox.1
	+ "(?:" + шРазделитель + "+(" + шИмя + "))?" + шРазделитель + "*(?:\(""(" + шИмя+ "(?:\.[" + шБуква + "\d]+)*)"")?|"
	+ "(" + шИмяСкобки + "?" + шИндекс + "?(?:\." + шИмяСкобки + "?" + шИндекс + "?)*)" + "|"
	+ "(" + шЧисло + ")|(" + шСтрокаПрограммы + ")))";

// Шаблоны запроса
шПараметрЗапроса = "[" + шСимволыПрефиксаПараметра + "][" + шБуква + "][" + шБуква + "\d]*";
шСтрокаЗапроса       = """(?:(?:"""")|[^""\n])*(?:""|\n|$)";
шНачалоСтрокиЗапроса = """(?:(?:"""")|[^""\n])*(?:""|\n|$)?";
шОператорЗапроса = "(?:(?:=|>|<|<>|<=|>=|\*|\/|\+|\-)|" + шРазделитель 
	+ "(?:И|AND|ИЛИ|OR|НЕ|NOT|МЕЖДУ|BETWEEN|ПОДОБНО|LIKE|ССЫЛКА|REFS|(?:ЕСТЬ|IS)" + шРазделитель + "+NULL|В|IN"
	+ "|В" + шРазделитель + "+ИЕРАРХИИ|IN" + шРазделитель + "+HIERARCHY)" + шРазделитель + ")+";
ШаблонВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОГДА|WHEN)" + шЛюбой + "+?(?:ТОГДА|THEN)" + шЛюбой + "+?(?:ИНАЧЕ|ELSE)" + шЛюбой + "+?(?:КОНЕЦ|END)";
ШаблонНачалаВыбора = "(?:ВЫБОР|CASE)" + шЛюбой + "+?(?:КОНЕЦ|END)?";
шИмяЗапроса = "(?:" + шИмя + "|\[[^\]]+\])";
шТаблицаЗапроса = "(" + шИмяЗапроса + "\.)*" + шИмяЗапроса + шСкобки + "?";
ШаблонСоединения = шРазделитель + "+((ПРАВОЕ|RIGHT|ЛЕВОЕ|LEFT|ВНУТРЕННЕЕ|INNER|ПОЛНОЕ|FULL|ВНЕШНЕЕ|OUTER)" + шРазделитель + "+)?(?:СОЕДИНЕНИЕ|JOIN)" 
	+ шРазделитель + "+";
	
шОписаниеТаблицы          = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + шИмяЗапроса;
шОписаниеТаблицыСЗахватом = "(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя + ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+(" + шИмяЗапроса + ")";
	
шВыражениеЗапроса = 
	"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	//+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*"
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
	      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмяСкобки + "?" + "(?:\." + шИмяСкобки + "?" + ")*)";
	
шНачалоВыраженияЗапроса = 
	"(?:" + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шСтрокаЗапроса + "|" + ШаблонВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)" + шРазделитель + "*" + шОператорЗапроса + ")*?" // Сделал захват ленивым, чтобы избежать катастрофического шагания назад
	      + шРазделитель + "*(?:" + шСкобки + "|(?:&|\?|@)" + шИмя + "|" + шЧисло + "|" + шНачалоСтрокиЗапроса + "|" + ШаблонНачалаВыбора
	+ "|" + шИмяЗапроса + шСкобки + "?" + "(?:\." + шИмяЗапроса + шСкобки + "?" + ")*)?";
	
шВызовМетодаЗапроса = "()?(" + шИмяЗапроса + шСкобки + "?" + "(?:(?:\.(?:" + шИмяЗапроса + ")" + шСкобки + "?)|" + шИндекс + ")*)"
	+ "\(((?:(?:" + шВыражениеЗапроса + ")?" + шРазделитель + "*,)*)" + "(" + шНачалоВыраженияЗапроса + ")?" + шРазделитель + "*";
	
ШаблонОписанияПоля = шВыражениеЗапроса + шРазделитель + "+КАК" + шРазделитель + "+" + шИмяЗапроса;
ШаблонВЫБРАТЬ = "(?:ВЫБРАТЬ|SELECT)(" + шРазделитель + "+(?:РАЗРЕШЕННЫЕ|ALLOWED))?(" + ШаблонОписанияПоля + ",)*" + ШаблонОписанияПоля;
шИЗ = "(?:ИЗ|FROM)" + шРазделитель + "+" + шОписаниеТаблицы + "(" + ШаблонСоединения + шОписаниеТаблицы 
	+ шРазделитель + "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "*," 
	+ шРазделитель + "*" + шОписаниеТаблицы + ")*";
шПоискОписанияТаблицы = "(" + ШаблонСоединения + ")?(" + шСкобки + "|" + шТаблицаЗапроса + "|&" + шИмя 
	+ ")" + шРазделитель + "+(?:КАК|AS)" + шРазделитель + "+" + "#Идентификатор#(" + шРазделитель 
	+ "+(?:ПО|ON)" + шРазделитель + "+" + шВыражениеЗапроса + "|" + шРазделитель + "|,|\)|$)";
	
// К нему привязаны имена методов-трансляторов событий
ИмяКласса = "ПолеТекстаПрограммы";
мМаркерСлужебногоКомментария = "{: ";
мМаркерПорядкаОтладки = "ПорядокОтладки ";
мЭтоАвтоВызов = Ложь;
СброситьРезультатРазбораПозицииВТексте();
мАнглийский1С = Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
мФлагиКомпиляции = Новый Структура;
мФлагиКомпиляции.Вставить("Сервер", Ложь);
